<goal>
I want you to fix all the issues.
The following is the current codebase
</goal>

<output_requirements>
- Don't be lazy, provide thorough, high-quality code.
- Provide complete file contents for any modified or new files.
- Write clean, well-documented code with appropriate error handling.
- Never use ellipsis (...) or placeholder comments, as an excuse to omit code for brewity.
</output_requirements>

<context>
    <codebase>
Directory structure:
└── /./
    ├── index.html
    ├── package.json
    ├── public/
    │   ├── models/
    │   │   └── playermodel.glb
    │   └── textures/
    ├── server/
    │   └── server.js
    ├── src/
    │   ├── ecs/
    │   │   ├── components.ts
    │   │   ├── config.ts
    │   │   ├── scene.ts
    │   │   ├── systems/
    │   │   │   ├── collision.ts
    │   │   │   ├── debugVis.ts
    │   │   │   ├── grass.ts
    │   │   │   ├── healthSystem.ts
    │   │   │   ├── input.ts
    │   │   │   ├── network/
    │   │   │   │   └── client.ts
    │   │   │   ├── physics.ts
    │   │   │   ├── player/
    │   │   │   │   ├── animationSystem.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── lookSystem.ts
    │   │   │   │   ├── movementSystem.ts
    │   │   │   │   └── shootSystem.ts
    │   │   │   ├── projectile.ts
    │   │   │   ├── renderSync.ts
    │   │   │   └── timeStep.ts
    │   │   ├── timeUtils.ts
    │   │   ├── utils/
    │   │   │   ├── eventUtils.ts
    │   │   │   └── mathUtils.ts
    │   │   └── world.ts
    │   ├── gameloop.ts
    │   └── main.ts
    ├── tsconfig.json
    └── vite.config.ts

================================================
File: /index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Rapier × Three × bitecs starter</title>
  <style>html,body{margin:0;height:100%;overflow:hidden}</style>
</head>
<body>
  <canvas id="c"></canvas>
  <script type="module" src="/src/main.ts"></script>
</body>
</html>


================================================
File: /package.json
================================================
{
  "name": "rapier-three-bitecs-multiplayer",
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "server": "node server/server.js"
  },
  "dependencies": {
    "@dimforge/rapier3d-compat": "^0.16.1",
    "bitecs": "^0.3.40",
    "three": "^0.176.0",
    "ws": "^8.18.0"
  },
  "devDependencies": {
    "@types/three": "^0.167.2",
    "@types/ws": "^8.5.11",
    "typescript": "^5.5.4",
    "vite": "^5.3.5",
    "vite-plugin-top-level-await": "^1.5.0",
    "vite-plugin-wasm": "^3.4.1"
  }
}


================================================
File: /server/server.js
================================================
import { WebSocketServer } from 'ws';
import * as RAPIER from '@dimforge/rapier3d-compat'; // Import Rapier for server-side logic if needed

console.log("Initializing Rapier on the server...");
await RAPIER.init();
console.log("Rapier initialized.");

const PORT = process.env.PORT || 8080;
const wss = new WebSocketServer({ port: PORT });

const players = new Map(); // playerId -> { ws, state }
let nextPlayerId = 1;

const TICK_RATE = 60; // Send updates 60 times per second
const SERVER_DT = 1 / TICK_RATE;

// --- Server-Side Rapier World (Optional but Recommended for Authority) ---
// If you want authoritative physics, uncomment and configure this.
// For this initial setup, we'll rely more on client state reporting + validation.
/*
const physicsWorld = new RAPIER.World({ x: 0, y: -9.81, z: 0 });
const playerBodies = new Map(); // playerId -> Rapier RigidBody
*/
// --- End Server-Side Physics ---

console.log(`WebSocket server started on port ${PORT}`);

wss.on('connection', (ws) => {
    const playerId = nextPlayerId++;
    console.log(`Player ${playerId} connected.`);

    const initialState = {
        id: playerId,
        position: { x: 0, y: 5, z: 0 }, // Initial spawn position
        rotation: { x: 0, y: 0, z: 0, w: 1 },
        animationState: 0, // e.g., Idle
        health: 100,
        maxHealth: 100,
        lastUpdateTime: Date.now()
    };
    players.set(playerId, { ws, state: initialState });

    // --- Server-Side Physics Body (Optional) ---
    /*
    const playerBodyDesc = RAPIER.RigidBodyDesc.dynamic()
        .setTranslation(initialState.position.x, initialState.position.y, initialState.position.z)
        .setAdditionalMass(1.0); // Give players mass
    const playerBody = physicsWorld.createRigidBody(playerBodyDesc);
    const playerColliderDesc = RAPIER.ColliderDesc.capsule(0.9, 0.3); // Match client collider
    physicsWorld.createCollider(playerColliderDesc, playerBody);
    playerBodies.set(playerId, playerBody);
    */
    // --- End Server-Side Physics Body ---

    // Send init data to the new player
    ws.send(JSON.stringify({
        type: 'init',
        playerId: playerId,
        initialState: initialState,
        // Send state of all other currently connected players
        players: Array.from(players.values())
                       .filter(p => p.state.id !== playerId) // Exclude self
                       .map(p => p.state)
    }));

    // Notify other players about the new player
    broadcast({
        type: 'playerJoined',
        playerState: initialState
    }, ws); // Exclude the new player itself

    ws.on('message', (message) => {
        try {
            const data = JSON.parse(message.toString());
            const player = players.get(playerId);
            if (!player) return;

            player.state.lastUpdateTime = Date.now(); // Keep track of activity

            switch (data.type) {
                case 'playerUpdate':
                    // Basic validation (more can be added)
                    if (isValidState(data.state)) {
                        // Update server state directly for now
                        player.state = { ...player.state, ...data.state };

                        // --- Server-Side Physics Update (Optional) ---
                        /*
                        const body = playerBodies.get(playerId);
                        if (body && data.state.position && data.state.rotation) {
                            // Apply position/rotation updates to the server-side body
                            // Add checks to prevent cheating (e.g., teleporting)
                            body.setTranslation(data.state.position, true);
                            body.setRotation(data.state.rotation, true);
                            // Or apply forces/velocities based on input in data.state
                        }
                        */
                        // --- End Server-Side Physics Update ---

                        // Don't broadcast immediately, wait for server tick
                    } else {
                        console.warn(`Invalid state update received from player ${playerId}`);
                    }
                    break;

                case 'shoot':
                    // Validate shoot request (e.g., cooldown, ammo)
                    console.log(`Player ${playerId} shot`);
                    // Broadcast the shoot event to other players
                    broadcast({
                        type: 'playerShoot',
                        playerId: playerId,
                        position: data.position,
                        direction: data.direction
                    }, ws); // Exclude shooter
                    break;

                case 'playerHit': // Message from shooter reporting they hit someone
                    const targetPlayer = players.get(data.targetId);
                    const sourcePlayer = players.get(playerId);

                    if (targetPlayer && sourcePlayer) {
                        // SERVER-AUTHORITATIVE HIT VALIDATION NEEDED HERE
                        // 1. Raycast from sourcePlayer's validated position/direction
                        // 2. Check distance, line of sight, timing, etc.
                        // 3. If valid, apply damage and broadcast

                        // --- Simplified Hit Processing (Trusting Client - NOT SECURE) ---
                        console.log(`Player ${playerId} reported hitting player ${data.targetId} on zone ${data.hitZone}`);
                        targetPlayer.state.health = Math.max(0, targetPlayer.state.health - data.damage);

                        // Notify the hit player
                        if (targetPlayer.ws.readyState === WebSocket.OPEN) {
                            targetPlayer.ws.send(JSON.stringify({
                                type: 'playerDamaged',
                                sourceId: playerId,
                                damage: data.damage,
                                hitZone: data.hitZone,
                                newHealth: targetPlayer.state.health
                            }));
                        }

                        // Confirm the hit back to the shooter
                        if (sourcePlayer.ws.readyState === WebSocket.OPEN) {
                           sourcePlayer.ws.send(JSON.stringify({
                                type: 'hitConfirmed',
                                targetId: data.targetId,
                                newHealth: targetPlayer.state.health
                           }));
                        }

                         // Broadcast health update for the target player
                        broadcast({
                            type: 'healthUpdate',
                            playerId: data.targetId,
                            health: targetPlayer.state.health
                        });


                        if (targetPlayer.state.health <= 0) {
                            console.log(`Player ${data.targetId} defeated by Player ${playerId}`);
                            // Handle player defeat (e.g., respawn logic)
                             handlePlayerDefeat(data.targetId, playerId);
                        }
                        // --- End Simplified Hit Processing ---
                    }
                    break;

                case 'pong':
                    // Client responded to ping, update last activity time
                    player.state.lastUpdateTime = Date.now();
                    break;

                default:
                    console.log(`Received unknown message type: ${data.type}`);
            }
        } catch (error) {
            console.error(`Failed to process message: ${error}`);
        }
    });

    ws.on('close', () => {
        console.log(`Player ${playerId} disconnected.`);
        const player = players.get(playerId);

        // --- Server-Side Physics Cleanup (Optional) ---
        /*
        const body = playerBodies.get(playerId);
        if (body) {
            physicsWorld.removeRigidBody(body);
            playerBodies.delete(playerId);
        }
        */
        // --- End Server-Side Physics Cleanup ---

        players.delete(playerId);
        broadcast({ type: 'playerLeft', playerId });
    });

    ws.on('error', (error) => {
        console.error(`WebSocket error for player ${playerId}: ${error}`);
        ws.close(); // Force close on error
        // Cleanup is handled by the 'close' event
    });
});

// Basic state validation
function isValidState(state) {
    if (!state) return false;
    // Add more checks: position bounds, rotation validity, etc.
    if (state.position && (isNaN(state.position.x) || isNaN(state.position.y) || isNaN(state.position.z))) return false;
    if (state.rotation && (isNaN(state.rotation.x) || isNaN(state.rotation.y) || isNaN(state.rotation.z) || isNaN(state.rotation.w))) return false;
    if (state.health && (isNaN(state.health) || state.health < 0)) return false; // Health shouldn't be NaN or negative before server processes death
    if (state.animationState && isNaN(state.animationState)) return false;
    return true;
}

// Function to broadcast messages to all connected clients (optionally excluding one)
function broadcast(data, senderWs = null) {
    const message = JSON.stringify(data);
    players.forEach((player) => {
        if (player.ws !== senderWs && player.ws.readyState === WebSocket.OPEN) {
            player.ws.send(message);
        }
    });
}

function handlePlayerDefeat(defeatedPlayerId, killerPlayerId) {
    // Notify everyone about the defeat
    broadcast({ type: 'playerDefeated', defeatedId: defeatedPlayerId, killerId: killerPlayerId });

    // Schedule respawn
    setTimeout(() => {
        const player = players.get(defeatedPlayerId);
        if (player && player.ws.readyState === WebSocket.OPEN) { // Check if player still connected
            // Reset state and assign new spawn position
            const spawnPosition = { x: (Math.random() - 0.5) * 20, y: 5, z: (Math.random() - 0.5) * 20 }; // Example random spawn
            player.state.position = spawnPosition;
            player.state.health = player.state.maxHealth;
            player.state.animationState = 0; // Reset to Idle

            // --- Server-Side Physics Reset (Optional) ---
            /*
            const body = playerBodies.get(defeatedPlayerId);
            if (body) {
                body.setTranslation(spawnPosition, true);
                body.setLinvel({ x: 0, y: 0, z: 0 }, true);
                body.setAngvel({ x: 0, y: 0, z: 0 }, true);
            }
            */
           // --- End Server-Side Physics Reset ---


            console.log(`Player ${defeatedPlayerId} respawning.`);

            // Notify the respawned player
            player.ws.send(JSON.stringify({
                type: 'respawn',
                newState: player.state
            }));

            // Notify others about the respawn (sends the full new state)
             broadcast({
                 type: 'playerRespawned',
                 playerState: player.state
             }, player.ws);

        } else {
             console.log(`Player ${defeatedPlayerId} disconnected before respawn.`);
        }
    }, 3000); // 3-second respawn delay
}

// Server-side game loop for physics and state broadcasting
let lastTickTime = Date.now();
function gameLoop() {
    const now = Date.now();
    const delta = (now - lastTickTime) / 1000; // Delta time in seconds
    lastTickTime = now;

    // --- Server-Side Physics Step (Optional) ---
    // physicsWorld.step();
    // --- End Server-Side Physics Step ---

    // Gather current state of all players
    const worldState = {
        type: 'worldState',
        timestamp: Date.now(),
        players: []
    };

    players.forEach((player, playerId) => {
         // --- Update player state from physics world (Optional) ---
         /*
         const body = playerBodies.get(playerId);
         if (body) {
             const pos = body.translation();
             const rot = body.rotation();
             player.state.position = { x: pos.x, y: pos.y, z: pos.z };
             player.state.rotation = { x: rot.x, y: rot.y, z: rot.z, w: rot.w };
             // You might also derive animationState from velocity here
         }
         */
        // --- End Update from physics ---
        worldState.players.push(player.state);
    });

    // Broadcast the world state to all players
    if (worldState.players.length > 0) {
        broadcast(worldState);
    }

     // Heartbeat / Keep-alive ping
    players.forEach((player) => {
        if (player.ws.readyState === WebSocket.OPEN) {
             if (now - player.state.lastUpdateTime > 10000) { // Check for inactivity (e.g., 10 seconds)
                 player.ws.ping(); // Send WebSocket ping
             }
        }
    });

}

setInterval(gameLoop, 1000 / TICK_RATE); // Run game loop at TICK_RATE Hz

// Basic keep-alive/timeout check
setInterval(() => {
    const now = Date.now();
    players.forEach((player, playerId) => {
        if (now - player.state.lastUpdateTime > 30000) { // 30 seconds timeout
            console.log(`Player ${playerId} timed out.`);
            player.ws.terminate(); // Force close connection
            // Cleanup is handled by the 'close' event
        }
    });
}, 10000); // Check every 10 seconds

================================================
File: /src/ecs/components.ts
================================================
import { Types, defineComponent } from 'bitecs';

/** World-space transform (pos-quat - Standardized order) */
export const Transform = defineComponent({
  x: Types.f32, y: Types.f32, z: Types.f32,
  qx: Types.f32, qy: Types.f32, qz: Types.f32, qw: Types.f32
});

/** Linear velocity – used for projectiles & potentially network prediction */
export const Velocity = defineComponent({ x: Types.f32, y: Types.f32, z: Types.f32 });

/** TTL in milliseconds (bullets) */
export const Lifespan = defineComponent({ ttl: Types.f32, born: Types.f32 });

/** Debug visualization flag - used to store current debug state */
export const DebugVis = defineComponent({ active: Types.ui8 });

/** First-person controller state (Local Player Only) */
export const FPController = defineComponent({
  pitch: Types.f32,        // Camera pitch angle
  vertVel: Types.f32,      // Vertical velocity
  moveState: Types.ui8,    // 0=Grounded, 1=Jumping, 2=Falling
  lastGrounded: Types.f32, // Time when last grounded
  lastJump: Types.f32,     // Time when last jumped
  // lastShot removed, handled by network/server now
  jumpRequested: Types.ui8,// Jump buffer flag
  lastJumpRequest: Types.f32 // Time when jump was requested
});

/** Debug visualization mesh references */
export const DebugMeshRef = defineComponent({ id: Types.ui32 });

/** Trajectory for debug visualization */
export const Trajectory = defineComponent({
  // No data needed, just a tag to indicate an entity has a trajectory
});

/** Collision event data */
export const CollisionEvent = defineComponent({
  entity1: Types.ui32,     // First entity in collision
  entity2: Types.ui32,     // Second entity in collision
  impulse: Types.f32,      // Collision impulse magnitude
  time: Types.f32          // When collision occurred
});

/** Foreign-object indirection – store handles in JS Maps */
export const RigidBodyRef = defineComponent({ id: Types.ui32 });
export const MeshRef      = defineComponent({ id: Types.ui32 });

/** Tags */
// Player tag is now split into LocalPlayer and RemotePlayer
export const Projectile = defineComponent();
export const CubeTag    = defineComponent();

// --- New Multiplayer Components ---

/** Identifies the local player entity */
export const LocalPlayer = defineComponent();

/** Identifies a remote player entity */
export const RemotePlayer = defineComponent();

/** Stores the server-assigned network ID */
export const NetworkId = defineComponent({ id: Types.ui32 });

/** Stores player health */
export const Health = defineComponent({
  current: Types.f32,
  max: Types.f32
});

/** Stores the current animation state (enum defined elsewhere) */
export const AnimationState = defineComponent({ state: Types.ui8 });

/** Stores target network state for interpolation */
export const InterpolationTarget = defineComponent({
  targetX: Types.f32, targetY: Types.f32, targetZ: Types.f32,
  targetQX: Types.f32, targetQY: Types.f32, targetQZ: Types.f32, targetQW: Types.f32,
  timestamp: Types.f32 // Timestamp of the target state from the server
});

================================================
File: /src/ecs/config.ts
================================================
/**
 * Global configuration values
 */

export const PlayerConfig = {
  // Movement
  WALK_SPEED: 8,
  SPRINT_FACTOR: 1.8,
  AIR_CONTROL: 0.7,
  JUMP_VEL: 14,
  GRAVITY: 20,
  TERMINAL_FALL: -20,

  // Timing
  JUMP_CD_MS: 300,
  COYOTE_MS: 150,
  JUMP_BUFFER_MS: 200,

  // Look
  MOUSE_SENSITIVITY: 0.0035,

  // Health
  MAX_HEALTH: 100
};

export const WeaponConfig = {
  // SHOOT_CD_MS removed - server now controls this
  BULLET_SPEED: 40,
  BULLET_TTL_MS: 5000, // Used for visual effect lifetime
  BULLET_SPAWN_DISTANCE: 1.5,
  // Added example damage values (server should determine actual damage)
  DAMAGE_BODY: 30,
  DAMAGE_HEAD: 100,
  DAMAGE_LIMB: 15
};

export const PhysicsConfig = {
  IMPACT_FORCE: 20.0,
  SOLVER_ITERATIONS: 4,
  CCD_SUBSTEPS: 4,
  VELOCITY_THRESHOLD: 30.0
};

export const TimeStepConfig = {
  FIXED_DT: 1/60,
  MAX_STEPS: 5,
  MAX_FRAME_TIME: 0.25,
  MIN_DT: 1/240
};

export const SceneConfig = {
  GROUND_COLOR: 0x1a5f2a,
  GROUND_SIZE: 200,
  SKY_COLOR: 0x87CEEB,
  CUBE_STACK_SIZE: 6,
  EXTRA_CUBES: 20,
  CUBE_RESTITUTION: 0.4,
  CUBE_FRICTION: 0.5,
  AMBIENT_LIGHT_INTENSITY: 0.8,
  DIRECTIONAL_LIGHT_INTENSITY: 1.0
};

// Movement state enum values
export const MovementState = {
  GROUNDED: 0,
  JUMPING: 1,
  FALLING: 2
};

// Animation state enum values (Example)
export const PlayerAnimationState = {
  IDLE: 0,
  WALKING: 1,
  RUNNING: 2,
  JUMPING: 3,
  FALLING: 4,
  SHOOTING: 5, // Added
  AIMING: 6,   // Added
  DEATH: 7     // Added
};

// Network configuration
export const NetworkConfig = {
    SERVER_URL: `ws://${window.location.hostname}:8080`, // Adjust hostname/port if needed
    UPDATE_INTERVAL_MS: 50, // Send local player updates 20 times per second
    INTERPOLATION_DELAY_MS: 100, // Delay applied to remote player interpolation
    PING_INTERVAL_MS: 5000 // Send ping every 5 seconds
};

================================================
File: /src/ecs/scene.ts
================================================
/**********************************************************************
 * scene.ts – Three + Rapier initialisation & scene population
 *********************************************************************/
import * as THREE  from 'three';
import { addComponent, addEntity } from 'bitecs';
import {
  CubeTag, MeshRef, RigidBodyRef, Transform
} from './components';
import { ECS, ECSContext } from './world';
import { SceneConfig } from './config';

/* ------------------------------------------------------------------ */
/* createContext – bootstrap renderer / physics / camera              */
export async function createContext(
  canvas: HTMLCanvasElement,
  RAPIER: typeof import('@dimforge/rapier3d-compat')
): Promise<ECSContext> {
  /* Rapier ---------------------------------------------------------- */
  const rapier = RAPIER;
  const physics = new rapier.World({ x: 0, y: -9.81, z: 0 });

  /* Three renderer -------------------------------------------------- */
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type    = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(SceneConfig.SKY_COLOR);
  scene.fog        = new THREE.FogExp2(0x88BBFF, 0.0025);

  const camera = new THREE.PerspectiveCamera(
    75, window.innerWidth / window.innerHeight, 0.1, 1000
  );

  // Set up window resize handler
  setupWindowResize(camera, renderer);

  // Create context object
  const ctx: ECSContext = {
    rapier, physics,
    three: { scene, camera, renderer },
    maps : { mesh: new Map(), rb: new Map() }
  };

  // Set up lighting, sky and ground
  setupLighting(ctx);
  setupSky(ctx);
  setupGround(ctx);

  return ctx;
}

/* ------------------------------------------------------------------ */
/* Helper function to set up window resize handling                   */
function setupWindowResize(camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer) {
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

/* ------------------------------------------------------------------ */
/* Helper function to set up scene lighting                           */
function setupLighting(ctx: ECSContext) {
  const scene = ctx.three.scene;
  
  // Add ambient light
  scene.add(new THREE.AmbientLight(
    0xffffff, SceneConfig.AMBIENT_LIGHT_INTENSITY
  ));

  // Add directional light with shadows
  const dirLight = new THREE.DirectionalLight(
    0xffffff, SceneConfig.DIRECTIONAL_LIGHT_INTENSITY
  );
  dirLight.position.set(5, 10, 7);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.set(2048, 2048);
  dirLight.shadow.camera.left = -20;
  dirLight.shadow.camera.right = 20;
  dirLight.shadow.camera.top = 20;
  dirLight.shadow.camera.bottom = -20;
  dirLight.shadow.camera.near = 0.5;
  dirLight.shadow.camera.far  = 50;
  scene.add(dirLight);
}

/* ------------------------------------------------------------------ */
/* Helper function to create sky dome                                 */
function setupSky(ctx: ECSContext) {
  const scene = ctx.three.scene;
  const sky = new THREE.SphereGeometry(400, 32, 15).scale(-1, 1, 1);
  scene.add(new THREE.Mesh(
    sky, 
    new THREE.MeshBasicMaterial({ 
      color: SceneConfig.SKY_COLOR, 
      side: THREE.BackSide 
    })
  ));
}

/* ------------------------------------------------------------------ */
/* Helper function to create ground plane                             */
function setupGround(ctx: ECSContext) {
  const scene = ctx.three.scene;
  const { rapier, physics } = ctx;
  
  const HALF_H = 0.05;                 // 0.1 m thick collider
  const GROUND_Y = -HALF_H;
  const SIZE = SceneConfig.GROUND_SIZE;

  // Create ground mesh
  const groundMesh = new THREE.Mesh(
    new THREE.PlaneGeometry(SIZE, SIZE).rotateX(-Math.PI / 2),
    new THREE.MeshStandardMaterial({ 
      color: SceneConfig.GROUND_COLOR, 
      roughness: 0.8, 
      metalness: 0.2 
    })
  );
  groundMesh.receiveShadow = true;
  groundMesh.position.y    = GROUND_Y;
  scene.add(groundMesh);

  // Create ground collider
  const groundBody = physics.createRigidBody(
    rapier.RigidBodyDesc.fixed().setTranslation(0, GROUND_Y, 0)
  );
  physics.createCollider(
    rapier.ColliderDesc.cuboid(SIZE/2, HALF_H, SIZE/2), groundBody
  );
}

/* ------------------------------------------------------------------ */
/* populateScene – central cube stack + scattered cubes               */
export function populateScene(world: ECS, ctx: ECSContext): void {
  const { rapier, physics, maps, three } = ctx;
  
  // Create shared geometry and materials for cube factory
  const geometries = new Map<number, THREE.BoxGeometry>();
  const materials = new Map<number, THREE.MeshStandardMaterial>();
  
  // Cube factory function with reused geometries/materials
  const makeCube = (
    x: number, y: number, z: number,
    size = 1, color = Math.random() * 0xffffff
  ) => {
    /* Three mesh ---------------------------------------------------- */
    // Reuse or create geometry
    if (!geometries.has(size)) {
      geometries.set(size, new THREE.BoxGeometry(size, size, size));
    }
    
    // Reuse material if same color (within tolerance) or create new
    let material: THREE.MeshStandardMaterial | undefined;
    for (const [existingColor, existingMaterial] of materials.entries()) {
      // Allow for small color differences (hex representation)
      if (Math.abs(existingColor - color) < 100) {
        material = existingMaterial;
        break;
      }
    }
    
    if (!material) {
      material = new THREE.MeshStandardMaterial({ 
        color, 
        roughness: 0.7, 
        metalness: 0.3 
      });
      materials.set(color, material);
    }
    
    const mesh = new THREE.Mesh(geometries.get(size)!, material);
    mesh.castShadow = mesh.receiveShadow = true;
    mesh.position.set(x, y, z);
    three.scene.add(mesh);

    /* Rapier body --------------------------------------------------- */
    const rb = physics.createRigidBody(
      rapier.RigidBodyDesc.dynamic()
            .setTranslation(x, y, z)
            .setCcdEnabled(true)
    );
    physics.createCollider(
      rapier.ColliderDesc.cuboid((size * 0.98) / 2, (size * 0.98) / 2, (size * 0.98) / 2)
            .setRestitution(SceneConfig.CUBE_RESTITUTION)
            .setFriction(SceneConfig.CUBE_FRICTION),
      rb
    );

    /* ECS entity ---------------------------------------------------- */
    const eid = addEntity(world);
    addComponent(world, CubeTag,     eid);
    addComponent(world, Transform,   eid);
    addComponent(world, MeshRef,     eid);
    addComponent(world, RigidBodyRef,eid);

    maps.mesh.set(eid, mesh);
    maps.rb.set(eid, rb);
    RigidBodyRef.id[eid] = rb.handle;
    
    // Update handle map
    if (world.ctx.entityHandleMap) {
      world.ctx.entityHandleMap.set(rb.handle, eid);
    }
  };

  /* Create cube stacks */
  const stackSize = SceneConfig.CUBE_STACK_SIZE;
  const halfStack = stackSize / 2;
  
  // Make a cube stack
  for (let y = 0; y < stackSize; ++y)
    for (let x = 0; x < stackSize; ++x)
      for (let z = 0; z < stackSize; ++z)
        makeCube(x - halfStack, y + 0.5, z - halfStack);

  /* extra cubes */
  for (let i = 0; i < SceneConfig.EXTRA_CUBES; i++)
    makeCube(
      (Math.random() - 0.5) * 20,
      10 + Math.random() * 10,
      (Math.random() - 0.5) * 20,
      0.5 + Math.random() * 1.5
    );
}


================================================
File: /src/ecs/systems/collision.ts
================================================
import { defineQuery, addComponent, addEntity, hasComponent } from 'bitecs';
import { Projectile, CubeTag, RigidBodyRef, CollisionEvent, Health, LocalPlayer, NetworkId } from '../components';
import { ECS } from '../world';
import { vec3Pool, createEntityPairKey } from '../utils/mathUtils';
import { PhysicsConfig, WeaponConfig } from '../config';
import { network } from './network/client';

export function initCollisionSystem(world: ECS) {
  // Queries for finding entities
  const projectileQuery = defineQuery([Projectile, RigidBodyRef]);
  const cubeQuery = defineQuery([CubeTag, RigidBodyRef]);
  const localPlayerQuery = defineQuery([LocalPlayer]);
  
  // Processed collisions cache to avoid duplicates
  const processedCollisions = new Map<bigint, number>();

  // Initialize entity handle mapping if not done already
  if (!world.ctx.entityHandleMap) {
    world.ctx.entityHandleMap = new Map<number, number>();
  }

  // Helper function to mark entities for deletion
  function markEntityForDeletion(w: ECS, eid: number) {
    const mesh = w.ctx.maps.mesh.get(eid);
    if (mesh) {
      if (!mesh.userData) mesh.userData = {};
      mesh.userData.markedForDeletion = true;
    }
  }

  return (w: ECS) => {
    const now = performance.now();

    // Clean up old processed collisions
    for (const [key, time] of processedCollisions.entries()) {
      if (now - time > 200) {
        processedCollisions.delete(key);
      }
    }

    // Skip if event queue not available
    if (!w.ctx.eventQueue) {
      return w;
    }

    // Update entity handle map for projectiles and cubes
    // This helps translate Rapier body handles to our ECS entity IDs
    for (const eid of projectileQuery(w)) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb && !w.ctx.entityHandleMap!.has(rb.handle)) {
        w.ctx.entityHandleMap!.set(rb.handle, eid);
      }
    }
    
    for (const eid of cubeQuery(w)) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb && !w.ctx.entityHandleMap!.has(rb.handle)) {
        w.ctx.entityHandleMap!.set(rb.handle, eid);
      }
    }

    // Process collision events from Rapier physics
    w.ctx.eventQueue.drainCollisionEvents((handle1: number, handle2: number, started: boolean) => {
      if (!started) return; // Only care about collision starts

      // Get entity IDs from rigid body handles
      const entity1 = w.ctx.entityHandleMap!.get(handle1);
      const entity2 = w.ctx.entityHandleMap!.get(handle2);

      if (!entity1 || !entity2) return;

      // Check entity types
      const isProjectile1 = hasComponent(w, Projectile, entity1);
      const isProjectile2 = hasComponent(w, Projectile, entity2);
      const isCube1 = hasComponent(w, CubeTag, entity1);
      const isCube2 = hasComponent(w, CubeTag, entity2);
      const isLocalPlayer1 = hasComponent(w, LocalPlayer, entity1);
      const isLocalPlayer2 = hasComponent(w, LocalPlayer, entity2);
      
      // --- Collision: Projectile <-> Cube ---
      if ((isProjectile1 && isCube2) || (isProjectile2 && isCube1)) {
        const projectileEid = isProjectile1 ? entity1 : entity2;
        const cubeEid = isCube1 ? entity1 : entity2;

        // Create a unique collision ID to prevent duplicate processing
        const collisionId = createEntityPairKey(projectileEid, cubeEid);
        if (processedCollisions.has(collisionId)) return;
        processedCollisions.set(collisionId, now);

        // Get the rigid bodies
        const cubeRB = w.ctx.maps.rb.get(cubeEid);
        const projectileRB = w.ctx.maps.rb.get(projectileEid);
        if (!cubeRB || !projectileRB) return;

        // Apply impulse to cube
        const bulletPos = projectileRB.translation();
        const cubePos = cubeRB.translation();
        
        // Calculate impact direction
        const impactDir = vec3Pool.get().set(
          cubePos.x - bulletPos.x, 
          cubePos.y - bulletPos.y, 
          cubePos.z - bulletPos.z
        ).normalize();
        
        // If direction is zero (direct center hit), use reversed bullet velocity
        if (impactDir.lengthSq() < 0.001) {
          const vel = projectileRB.linvel();
          impactDir.set(-vel.x, -vel.y, -vel.z).normalize();
        }
        
        // Apply impulse at impact point
        cubeRB.applyImpulseAtPoint(
          { 
            x: impactDir.x * PhysicsConfig.IMPACT_FORCE, 
            y: impactDir.y * PhysicsConfig.IMPACT_FORCE, 
            z: impactDir.z * PhysicsConfig.IMPACT_FORCE 
          },
          bulletPos,
          true
        );
        
        // Apply random torque for more natural movement
        cubeRB.applyTorqueImpulse(
          { 
            x: (Math.random() - 0.5) * PhysicsConfig.IMPACT_FORCE * 0.3, 
            y: (Math.random() - 0.5) * PhysicsConfig.IMPACT_FORCE * 0.3, 
            z: (Math.random() - 0.5) * PhysicsConfig.IMPACT_FORCE * 0.3 
          }, 
          true
        );

        // Mark projectile for deletion
        markEntityForDeletion(w, projectileEid);
        vec3Pool.release(impactDir);
        return; // Processed this collision
      }

      // --- Collision: Projectile <-> LocalPlayer ---
      // This should only happen with OTHER players' projectiles hitting the local player
      // The server is authoritative, but we can use this to provide immediate visual feedback
      if ((isProjectile1 && isLocalPlayer2) || (isProjectile2 && isLocalPlayer1)) {
        const projectileEid = isProjectile1 ? entity1 : entity2;
        const playerEid = isLocalPlayer1 ? entity1 : entity2;

        // Create a unique collision ID to prevent duplicate processing
        const collisionId = createEntityPairKey(projectileEid, playerEid);
        if (processedCollisions.has(collisionId)) return;
        processedCollisions.set(collisionId, now);

        console.log(`Local impact detected: projectile ${projectileEid} hit local player ${playerEid}`);
        
        // Mark projectile for deletion (visual feedback)
        markEntityForDeletion(w, projectileEid);
        
        // Server will determine actual damage via hit event,
        // but we can trigger immediate local feedback if desired:
        // For example, play hit sound, flash screen, etc.
        
        return; // Processed this collision
      }
    });

    return w;
  };
}

================================================
File: /src/ecs/systems/debugVis.ts
================================================
import { defineQuery } from 'bitecs';
import { DebugVis, Projectile, LocalPlayer, RemotePlayer, RigidBodyRef } from '../components';
import { ECS } from '../world';
import * as THREE from 'three';
import { vec3Pool } from '../utils/mathUtils';

// Maximum number of points in trajectory
const MAX_TRAJECTORY_POINTS = 100;

export function initDebugVisSystem(world: ECS) {
  const debugQuery = defineQuery([DebugVis]);
  const playerQuery = defineQuery([LocalPlayer, RigidBodyRef]);
  const projectileQuery = defineQuery([Projectile, RigidBodyRef]);
  
  // Store trajectory data
  const trajectoryLines = new Map<number, THREE.Line>();
  const trajectories = new Map<number, {
    count: number,  // Current number of points
    maxCount: number  // Maximum capacity
  }>();
  
  // Store pre-allocated buffers to avoid creating new ones each frame
  const positionBuffers = new Map<number, {
    array: Float32Array,
    attribute: THREE.BufferAttribute
  }>();
  
  // Shared line material for all trajectories
  const lineMaterial = new THREE.LineBasicMaterial({ 
    color: 0xff9900, 
    transparent: true, 
    opacity: 0.7 
  });
  
  // Create player capsule mesh for debug
  let playerCapsule: THREE.Mesh | null = null;
  
  // Create a simple cylinder geometry
  const createCylinderGeometry = (radius: number, height: number, widthSegments = 16): THREE.BufferGeometry => {
    // Create cylinder body
    return new THREE.CylinderGeometry(
      radius, radius, height - radius * 2, widthSegments, 1, true
    );
  };
  
  // Initialize the debug capsule and materials
  const wireframeMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    wireframe: true,
    transparent: true,
    opacity: 0.7
  });
  
  // Create the capsule mesh once at initialization
  const capsuleGeometry = createCylinderGeometry(0.3, 1.8, 16);
  playerCapsule = new THREE.Mesh(capsuleGeometry, wireframeMaterial);
  world.ctx.three.scene.add(playerCapsule);
  playerCapsule.visible = false; // Hidden by default
  
  return (w: ECS) => {
    // First check if debug visualization is enabled
    const debugEnts = debugQuery(w);
    const debugId = debugEnts.length > 0 ? debugEnts[0] : -1;
    const debugActive = debugId !== -1 && DebugVis.active[debugId] === 1;
    
    // Update player capsule visibility and position
    if (playerCapsule) {
      playerCapsule.visible = debugActive;
      
      // Update position if visible
      if (debugActive) {
        const playerEnts = playerQuery(w);
        if (playerEnts.length > 0) {
          const playerEid = playerEnts[0];
          const playerObj = w.ctx.maps.mesh.get(playerEid);
          if (playerObj) {
            playerCapsule.position.copy(playerObj.position);
            playerCapsule.position.y -= 0.3; // Adjust to match center of capsule
            playerCapsule.rotation.y = playerObj.rotation.y;
          }
        }
      }
    }
    
    // Update projectile trajectories
    for (const projectileEid of projectileQuery(w)) {
      // Get current position for this projectile
      const rb = w.ctx.maps.rb.get(projectileEid);
      if (!rb) continue;
      
      // Get position and add to trajectory
      const pos = rb.translation();
      const currentPos = vec3Pool.get().set(pos.x, pos.y, pos.z);
      
      // Initialize trajectory and buffer if needed
      if (!trajectories.has(projectileEid)) {
        // Create trajectory tracking object
        trajectories.set(projectileEid, {
          count: 0,
          maxCount: MAX_TRAJECTORY_POINTS
        });
        
        // Pre-allocate the Float32Array with maximum size
        const posArray = new Float32Array(MAX_TRAJECTORY_POINTS * 3);
        const posAttribute = new THREE.BufferAttribute(posArray, 3);
        positionBuffers.set(projectileEid, {
          array: posArray,
          attribute: posAttribute
        });
      }
      
      // Get the trajectory data
      const trajectory = trajectories.get(projectileEid)!;
      // Get the buffer
      const buffer = positionBuffers.get(projectileEid)!;
      
      // Add current position directly to the buffer
      if (trajectory.count < MAX_TRAJECTORY_POINTS) {
        // We have room, add at the end
        const idx = trajectory.count * 3;
        buffer.array[idx] = currentPos.x;
        buffer.array[idx + 1] = currentPos.y;
        buffer.array[idx + 2] = currentPos.z;
        trajectory.count++;
      } else {
        // Shift all points one position back using copyWithin (much faster than loop)
        buffer.array.copyWithin(0, 3);
        
        // Add new point at the end
        const idx = (trajectory.count - 1) * 3;
        buffer.array[idx] = currentPos.x;
        buffer.array[idx + 1] = currentPos.y;
        buffer.array[idx + 2] = currentPos.z;
      }
      
      // Mark buffer for update
      buffer.attribute.needsUpdate = true;
      
      // Release the pooled vector
      vec3Pool.release(currentPos);
      
      // Only update/show trajectory lines if debug is active
      if (debugActive) {
        if (trajectoryLines.has(projectileEid)) {
          // Update existing line - reuse the geometry
          const line = trajectoryLines.get(projectileEid)!;
          line.visible = true;
          
          // Get the pre-allocated buffer and update it
          const buffer = positionBuffers.get(projectileEid)!;
          
          // Update geometry to draw only the current points
          line.geometry.setDrawRange(0, trajectory.count);
          buffer.attribute.needsUpdate = true;
        } else {
          // Create new line with dynamic buffer geometry
          const geometry = new THREE.BufferGeometry();
          const buffer = positionBuffers.get(projectileEid)!;
          
          // Add attribute to geometry
          geometry.setAttribute('position', buffer.attribute);
          
          // Set initial draw range
          geometry.setDrawRange(0, trajectory.count);
          
          // Use the shared material
          const line = new THREE.Line(geometry, lineMaterial);
          trajectoryLines.set(projectileEid, line);
          w.ctx.three.scene.add(line);
        }
      } else {
        // Hide lines if debug is disabled
        if (trajectoryLines.has(projectileEid)) {
          trajectoryLines.get(projectileEid)!.visible = false;
        }
      }
    }
    
    // Clean up trajectories for removed projectiles
    for (const [eid, line] of trajectoryLines.entries()) {
      const projectileExists = projectileQuery(w).includes(eid);
      
      // Check if projectile is marked for deletion
      const mesh = w.ctx.maps.mesh.get(eid);
      const markedForDeletion = mesh?.userData?.markedForDeletion === true;
      
      if (!projectileExists || markedForDeletion) {
        // Remove the trajectory line
        w.ctx.three.scene.remove(line);
        line.geometry.dispose();
        if (line.material instanceof THREE.Material) {
          line.material.dispose();
        } else if (Array.isArray(line.material)) {
          line.material.forEach(mat => mat.dispose());
        }
        trajectoryLines.delete(eid);
        trajectories.delete(eid);
        positionBuffers.delete(eid);
      }
    }
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/grass.ts
================================================
import * as THREE from 'three';
import { ECS } from '../world';
import { defineQuery, enterQuery, exitQuery } from 'bitecs';
import { CubeTag, Transform } from '../components';

// Custom shader material class for grass
class ShaderManager {
  private static instance: ShaderManager;
  private shaderCache: Record<string, { vertex: string, fragment: string }> = {};
  
  private constructor() {
    this.initShaders();
  }

  public static getInstance(): ShaderManager {
    if (!ShaderManager.instance) {
      ShaderManager.instance = new ShaderManager();
    }
    return ShaderManager.instance;
  }

  private initShaders(): void {
    // Define grass shader
    const grassVertexShader = `
      uniform vec2 grassSize;
      uniform vec4 grassParams;
      uniform vec4 grassDraw;
      uniform float time;
      uniform vec3 playerPos;
      uniform mat4 viewMatrixInverse;

      attribute float vertIndex;

      varying vec4 vGrassParams;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      varying vec2 vUv;

      // Math utility functions
      float saturate(float x) {
        return clamp(x, 0.0, 1.0);
      }

      float linearstep(float minValue, float maxValue, float v) {
        return clamp((v - minValue) / (maxValue - minValue), 0.0, 1.0);
      }

      float easeOut(float x, float t) {
        return 1.0 - pow(1.0 - x, t);
      }

      float easeIn(float x, float t) {
        return pow(x, t);
      }

      // Hash functions
      vec2 hash22(vec2 p) {
        p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
        return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
      }

      vec4 hash42(vec2 p) {
        vec4 p4 = fract(vec4(p.xyxy) * vec4(0.1031, 0.1030, 0.0973, 0.1099));
        p4 += dot(p4, p4.wzxy + 33.33);
        return fract((p4.xxyz + p4.yzzw) * p4.zywx) * 2.0 - 1.0;
      }

      // Noise function for wind
      float noise12(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        
        // Smooth interpolation
        vec2 u = f * f * (3.0 - 2.0 * f);
        
        // Hash corners
        float a = dot(hash22(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));
        float b = dot(hash22(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));
        float c = dot(hash22(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));
        float d = dot(hash22(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));
        
        // Mix
        return mix(mix(a, b, u.x), mix(c, d, u.x), u.y) * 0.5 + 0.5;
      }

      // Matrix utility functions
      mat3 rotateX(float theta) {
        float c = cos(theta);
        float s = sin(theta);
        return mat3(
          vec3(1.0, 0.0, 0.0),
          vec3(0.0, c, -s),
          vec3(0.0, s, c)
        );
      }

      mat3 rotateY(float theta) {
        float c = cos(theta);
        float s = sin(theta);
        return mat3(
          vec3(c, 0.0, s),
          vec3(0.0, 1.0, 0.0),
          vec3(-s, 0.0, c)
        );
      }

      mat3 rotateAxis(vec3 axis, float angle) {
        axis = normalize(axis);
        float s = sin(angle);
        float c = cos(angle);
        float oc = 1.0 - c;
        
        return mat3(
          oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
          oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
          oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c
        );
      }

      void main() {
        vec3 grassOffset = vec3(position.x, 0.0, position.y);

        // Blade world position
        vec3 grassBladeWorldPos = (modelMatrix * vec4(grassOffset, 1.0)).xyz;
        float heightmapSample = 0.0;
        float heightmapSampleHeight = 1.0;

        vec4 hashVal1 = hash42(vec2(grassBladeWorldPos.x, grassBladeWorldPos.z));

        float highLODOut = smoothstep(grassDraw.x * 0.5, grassDraw.x, distance(cameraPosition, grassBladeWorldPos));
        float lodFadeIn = smoothstep(grassDraw.x, grassDraw.y, distance(cameraPosition, grassBladeWorldPos));

        // Check terrain type
        float isSandy = 0.0;
        float grassAllowedHash = hashVal1.w - isSandy;
        float isGrassAllowed = step(0.0, grassAllowedHash);

        float randomAngle = hashVal1.x * 2.0 * 3.14159;
        float randomShade = clamp(hashVal1.y * 0.5 + 0.5, 0.5, 1.0);
        float randomHeight = mix(0.75, 1.5, hashVal1.z * 0.5 + 0.5) * mix(1.0, 0.0, lodFadeIn) * isGrassAllowed * heightmapSampleHeight;
        float randomWidth = (1.0 - isSandy) * heightmapSampleHeight;
        float randomLean = mix(0.1, 0.4, hashVal1.w * 0.5 + 0.5);

        vec2 hashGrassColour = hash22(vec2(grassBladeWorldPos.x, grassBladeWorldPos.z)) * 0.5 + 0.5;
        float leanAnimation = (noise12(vec2(time * 0.35) + grassBladeWorldPos.xz * 137.423) * 2.0 - 1.0) * 0.1;

        float GRASS_SEGMENTS = grassParams.x;
        float GRASS_VERTICES = grassParams.y;

        // Figure out vertex id
        float vertID = mod(float(vertIndex), GRASS_VERTICES);

        // 1 = front, -1 = back
        float zSide = -(floor(vertIndex / GRASS_VERTICES) * 2.0 - 1.0);

        // 0 = left, 1 = right
        float xSide = mod(vertID, 2.0);

        float heightPercent = (vertID - xSide) / (GRASS_SEGMENTS * 2.0);

        // Select grass blade variation (0-4 for 5 variations)
        float bladeVariation = floor(hashVal1.x * 5.0);

        float grassTotalHeight = grassSize.y * randomHeight;
        float grassTotalWidthHigh = easeOut(1.0 - heightPercent, 2.0);
        float grassTotalWidthLow = 1.0 - heightPercent;
        float grassTotalWidth = grassSize.x * mix(grassTotalWidthHigh, grassTotalWidthLow, highLODOut) * randomWidth;

        // Shift verts
        float x = (xSide - 0.5) * grassTotalWidth;
        float y = heightPercent * grassTotalHeight;

        float windDir = noise12(grassBladeWorldPos.xz * 0.05 + 0.05 * time) * 6.28318;
        float windNoiseSample = noise12(grassBladeWorldPos.xz * 0.25 + time * 1.0) * 2.0 - 1.0;
        float windLeanAngle = mix(0.25, 1.0, clamp(windNoiseSample * 0.5 + 0.5, 0.0, 1.0));
        windLeanAngle = easeIn(windLeanAngle, 2.0) * 1.25;
        vec3 windAxis = vec3(cos(windDir), 0.0, sin(windDir));

        windLeanAngle *= heightPercent;

        float distToPlayer = distance(grassBladeWorldPos.xz, playerPos.xz);
        float playerFalloff = smoothstep(2.5, 1.0, distToPlayer);
        float playerLeanAngle = mix(0.0, 0.2, playerFalloff * linearstep(0.5, 0.0, windLeanAngle));
        vec3 grassToPlayer = normalize(vec3(playerPos.x, 0.0, playerPos.z) - vec3(grassBladeWorldPos.x, 0.0, grassBladeWorldPos.z));
        vec3 playerLeanAxis = vec3(grassToPlayer.z, 0, -grassToPlayer.x);

        randomLean += leanAnimation;

        float easedHeight = mix(easeIn(heightPercent, 2.0), 1.0, highLODOut);
        float curveAmount = -randomLean * easedHeight;

        float ncurve1 = -randomLean * easedHeight;
        vec3 n1 = vec3(0.0, (heightPercent + 0.01), 0.0);
        n1 = rotateX(ncurve1) * n1;

        float ncurve2 = -randomLean * easedHeight * 0.9;
        vec3 n2 = vec3(0.0, (heightPercent + 0.01) * 0.9, 0.0);
        n2 = rotateX(ncurve2) * n2;

        vec3 ncurve = normalize(n1 - n2);

        mat3 grassMat = rotateAxis(playerLeanAxis, playerLeanAngle) * rotateAxis(windAxis, windLeanAngle) * rotateY(randomAngle);

        vec3 grassFaceNormal = vec3(0.0, 0.0, 1.0);
        grassFaceNormal = grassMat * grassFaceNormal;
        grassFaceNormal *= zSide;

        vec3 grassVertexNormal = vec3(0.0, -ncurve.z, ncurve.y);
        vec3 grassVertexNormal1 = rotateY(3.14159 * 0.3 * zSide) * grassVertexNormal;

        grassVertexNormal1 = grassMat * grassVertexNormal1;
        grassVertexNormal1 *= zSide;

        vec3 grassVertexPosition = vec3(x, y, 0.0);
        grassVertexPosition = rotateX(curveAmount) * grassVertexPosition;
        grassVertexPosition = grassMat * grassVertexPosition;

        grassVertexPosition += grassOffset;

        vGrassParams = vec4(heightPercent, grassBladeWorldPos.y, highLODOut, xSide);
        
        const float SKY_RATIO = 0.15;
        vec3 UP = vec3(0.0, 1.0, 0.0);
        float skyFadeIn = (1.0 - highLODOut) * SKY_RATIO;
        vNormal = normalize(mix(UP, grassVertexNormal1, skyFadeIn));

        vec3 pos = grassVertexPosition;

        vec3 viewDir = normalize(cameraPosition - grassBladeWorldPos);
        vec3 viewDirXZ = normalize(vec3(viewDir.x, 0.0, viewDir.z));
        vec3 grassFaceNormalXZ = normalize(vec3(grassFaceNormal.x, 0.0, grassFaceNormal.z));

        float viewDotNormal = saturate(dot(grassFaceNormal, viewDirXZ));
        float viewSpaceThickenFactor = easeOut(1.0 - viewDotNormal, 4.0) * smoothstep(0.0, 0.2, viewDotNormal);

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        
        // Thicken effect for better visibility
        mvPosition.x += viewSpaceThickenFactor * (xSide - 0.5) * grassTotalWidth * 0.5 * zSide;
        
        gl_Position = projectionMatrix * mvPosition;
        
        vPosition = pos;
        vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
        
        // Map UV to select one of the 5 blade variations
        // Each blade is 143px wide in a 715px texture (1/5 = 0.2 of the total width)
        // X coordinate: map the xSide (0-1) to a 0.2 width segment based on variation
        float uvX = (xSide * 0.2) + (bladeVariation * 0.2);
        vUv = vec2(uvX, heightPercent);
      }
    `;
    
    const grassFragmentShader = `
      uniform vec3 diffuse;
      uniform vec3 specular;
      uniform float shininess;
      uniform float opacity;
      uniform float time;
      uniform sampler2D grassTexture;
      
      varying vec4 vGrassParams;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      varying vec2 vUv;
      
      // Light data (mimic Three.js directional light)
      struct DirectionalLight {
        vec3 direction;
        vec3 color;
      };
      
      const DirectionalLight directionalLight = DirectionalLight(
        normalize(vec3(-0.5, 0.8, 0.5)),
        vec3(1.0, 1.0, 1.0)
      );
      
      // Utility functions
      float saturate(float x) {
        return clamp(x, 0.0, 1.0);
      }
      
      float easeIn(float x, float t) {
        return pow(x, t);
      }
      
      vec3 calculateLighting(vec3 normal, vec3 viewDir, vec3 baseColor) {
        // Ambient term
        vec3 ambient = vec3(0.3) * baseColor;
        
        // Diffuse term with wrapped lighting for softer look
        float wrap = 0.5;
        float NdotL = saturate((dot(normal, directionalLight.direction) + wrap) / (1.0 + wrap));
        vec3 diffuseLight = NdotL * directionalLight.color * baseColor;
        
        // Simple specular for highlights
        vec3 halfVector = normalize(directionalLight.direction + viewDir);
        float NdotH = max(0.0, dot(normal, halfVector));
        vec3 specularLight = pow(NdotH, shininess) * specular * directionalLight.color;
        
        // Back-lighting for translucency effect
        float backLight = saturate((dot(viewDir, -directionalLight.direction) + wrap) / (1.0 + wrap));
        float backFalloff = 0.5;
        vec3 backScatter = directionalLight.color * pow(backLight, 1.0) * backFalloff * baseColor * (1.0 - vGrassParams.z);
        
        return ambient + diffuseLight + specularLight + backScatter;
      }
      
      void main() {
        // Grass color processing
        float heightPercent = vGrassParams.x;
        float lodFadeIn = vGrassParams.z;
        
        // Sample the grass texture
        vec4 texSample = texture2D(grassTexture, vUv);
        
        // Use texture color directly
        vec3 baseColor = texSample.rgb;
        
        // Apply ambient occlusion at the base for natural grounding
        float ao = mix(0.25, 1.0, easeIn(heightPercent, 2.0));
        baseColor *= ao;
        
        // Lighting calculation
        vec3 viewDir = normalize(cameraPosition - vWorldPosition);
        vec3 litColor = calculateLighting(normalize(vNormal), viewDir, baseColor);
        
        // Use alpha from texture if available
        float alpha = texSample.a;
        if (alpha < 0.5) discard; // Discard pixels with low alpha
        
        gl_FragColor = vec4(litColor, 1.0);
      }
    `;
    
    this.shaderCache['GRASS'] = {
      vertex: grassVertexShader,
      fragment: grassFragmentShader
    };
  }

  public getShader(name: string): { vertex: string, fragment: string } {
    if (!this.shaderCache[name]) {
      console.error(`Shader ${name} not found`);
      return { vertex: '', fragment: '' };
    }
    return this.shaderCache[name];
  }
}

// Custom shader material class that works with our shader system
class CustomShaderMaterial extends THREE.ShaderMaterial {
  constructor(type: string, parameters: THREE.ShaderMaterialParameters = {}) {
    const shaderManager = ShaderManager.getInstance();
    const shader = shaderManager.getShader(type);
    
    if (!parameters.uniforms) {
      parameters.uniforms = {};
    }
    
    parameters.vertexShader = shader.vertex;
    parameters.fragmentShader = shader.fragment;
    
    super(parameters);
    
    // Set some default values
    this.transparent = parameters.transparent !== undefined ? parameters.transparent : false;
    this.side = parameters.side !== undefined ? parameters.side : THREE.FrontSide;
    this.depthWrite = parameters.depthWrite !== undefined ? parameters.depthWrite : true;
    this.depthTest = parameters.depthTest !== undefined ? parameters.depthTest : true;
  }
  
  setFloat(name: string, value: number): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value = value;
    }
  }
  
  setVector2(name: string, value: THREE.Vector2): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setVector3(name: string, value: THREE.Vector3): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setVector4(name: string, value: THREE.Vector4): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setMatrix(name: string, value: THREE.Matrix4): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value: value.clone() };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setTexture(name: string, value: THREE.Texture): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value = value;
    }
  }
}

// Simple math utility functions
const setSeed = (seed: number): void => {
  // Use a simple random number generator
  Math.random = () => {
    const x = Math.sin(seed++) * 10000;
    return x - Math.floor(x);
  };
};

const randRange = (min: number, max: number): number => {
  return Math.random() * (max - min) + min;
};

// Constants for grass rendering
const NUM_GRASS = (32 * 32) * 3;
const GRASS_SEGMENTS_LOW = 1;
const GRASS_SEGMENTS_HIGH = 6;
const GRASS_VERTICES_LOW = (GRASS_SEGMENTS_LOW + 1) * 2;
const GRASS_VERTICES_HIGH = (GRASS_SEGMENTS_HIGH + 1) * 2;
const GRASS_LOD_DIST = 25;
const GRASS_MAX_DIST = 180;
const GRASS_PATCH_SIZE = 5 * 2;
const GRASS_WIDTH = 0.1;
const GRASS_HEIGHT = 1.5;

// Grass component implementation
class GrassComponent {
  private meshesLow: THREE.Mesh[] = [];
  private meshesHigh: THREE.Mesh[] = [];
  private group: THREE.Group;
  private totalTime: number = 0;
  private grassMaterialLow: CustomShaderMaterial;
  private grassMaterialHigh: CustomShaderMaterial;
  private geometryLow: THREE.InstancedBufferGeometry;
  private geometryHigh: THREE.InstancedBufferGeometry;
  private readonly _scene: THREE.Scene;
  private grassTexture: THREE.Texture;

  constructor(scene: THREE.Scene, private camera: THREE.PerspectiveCamera) {
    this._scene = scene;
    this.group = new THREE.Group();
    this.group.name = "GRASS";
    
    // Load grass texture
    this.grassTexture = new THREE.TextureLoader().load('/textures/grassblade.png');
    this.grassTexture.wrapS = THREE.ClampToEdgeWrapping;
    this.grassTexture.wrapT = THREE.ClampToEdgeWrapping;
    this.grassTexture.minFilter = THREE.LinearFilter;
    this.grassTexture.magFilter = THREE.LinearFilter;
    this.grassTexture.generateMipmaps = true;
    // The texture contains 5 blades horizontally, prevent texture bleeding between variants
    this.grassTexture.anisotropy = 16; // Improves appearance at angles
    
    // Initialize grass materials
    this.grassMaterialLow = this.createGrassMaterial(true);
    this.grassMaterialHigh = this.createGrassMaterial(false);
    
    // Create grass geometries
    this.geometryLow = this.createGrassGeometry(GRASS_SEGMENTS_LOW);
    this.geometryHigh = this.createGrassGeometry(GRASS_SEGMENTS_HIGH);
    
    // Add group to scene
    scene.add(this.group);
  }

  private createGrassMaterial(isLowDetail: boolean): CustomShaderMaterial {
    const material = new CustomShaderMaterial('GRASS', {
      uniforms: {
        grassSize: { value: new THREE.Vector2(GRASS_WIDTH, GRASS_HEIGHT) },
        grassParams: { value: new THREE.Vector4(
          isLowDetail ? GRASS_SEGMENTS_LOW : GRASS_SEGMENTS_HIGH,
          isLowDetail ? GRASS_VERTICES_LOW : GRASS_VERTICES_HIGH,
          0, 0
        )},
        grassDraw: { value: new THREE.Vector4(GRASS_LOD_DIST, GRASS_MAX_DIST, 0, 0) },
        time: { value: 0.0 },
        playerPos: { value: new THREE.Vector3(0, 0, 0) },
        viewMatrixInverse: { value: new THREE.Matrix4() },
        diffuse: { value: new THREE.Color(0xffffff) },
        specular: { value: new THREE.Color(0x111111) },
        shininess: { value: 30 },
        grassTexture: { value: this.grassTexture }
      },
      transparent: true,
      alphaTest: 0.5,
      side: THREE.DoubleSide
    });
    
    return material;
  }

  private createGrassGeometry(segments: number): THREE.InstancedBufferGeometry {
    setSeed(0);

    const VERTICES = (segments + 1) * 2;

    // Create indices
    const indices: number[] = [];
    for (let i = 0; i < segments; ++i) {
      const vi = i * 2;
      indices[i*12+0] = vi + 0;
      indices[i*12+1] = vi + 1;
      indices[i*12+2] = vi + 2;

      indices[i*12+3] = vi + 2;
      indices[i*12+4] = vi + 1;
      indices[i*12+5] = vi + 3;

      const fi = VERTICES + vi;
      indices[i*12+6] = fi + 2;
      indices[i*12+7] = fi + 1;
      indices[i*12+8] = fi + 0;

      indices[i*12+9]  = fi + 3;
      indices[i*12+10] = fi + 1;
      indices[i*12+11] = fi + 2;
    }

    // Create offsets
    const offsets: number[] = [];
    for (let i = 0; i < NUM_GRASS; ++i) {
      offsets.push(randRange(-GRASS_PATCH_SIZE * 0.5, GRASS_PATCH_SIZE * 0.5));
      offsets.push(randRange(-GRASS_PATCH_SIZE * 0.5, GRASS_PATCH_SIZE * 0.5));
      offsets.push(0);
    }

    // Create vertex IDs
    const vertID = new Uint8Array(VERTICES*2);
    for (let i = 0; i < VERTICES*2; ++i) {
      vertID[i] = i;
    }

    // Create instanced geometry
    const geo = new THREE.InstancedBufferGeometry();
    geo.instanceCount = NUM_GRASS;
    geo.setAttribute('vertIndex', new THREE.Uint8BufferAttribute(vertID, 1));
    geo.setAttribute('position', new THREE.InstancedBufferAttribute(new Float32Array(offsets), 3));
    geo.setIndex(indices);
    geo.boundingSphere = new THREE.Sphere(new THREE.Vector3(0, 0, 0), 1 + GRASS_PATCH_SIZE * 2);

    return geo;
  }

  private createGrassMesh(distToCell: number): THREE.Mesh {
    const isLowDetail = distToCell > GRASS_LOD_DIST;
    const geometry = isLowDetail ? this.geometryLow : this.geometryHigh;
    const material = isLowDetail ? this.grassMaterialLow : this.grassMaterialHigh;
    
    const mesh = new THREE.Mesh(geometry, material);
    if (!mesh) {
      throw new Error("Failed to create grass mesh");
    }
    mesh.receiveShadow = true;
    mesh.castShadow = false;
    mesh.visible = false;
    
    if (isLowDetail) {
      this.meshesLow.push(mesh);
    } else {
      this.meshesHigh.push(mesh);
    }
    
    this.group.add(mesh);
    return mesh;
  }

  update(deltaTime: number, playerPosition: THREE.Vector3): void {
    this.totalTime += deltaTime;

    // Update material time uniforms
    this.grassMaterialLow.setFloat('time', this.totalTime);
    this.grassMaterialHigh.setFloat('time', this.totalTime);
    
    // Update player position
    this.grassMaterialLow.setVector3('playerPos', playerPosition);
    this.grassMaterialHigh.setVector3('playerPos', playerPosition);
    
    // Update view matrix
    this.grassMaterialLow.setMatrix('viewMatrixInverse', this.camera.matrixWorld);
    this.grassMaterialHigh.setMatrix('viewMatrixInverse', this.camera.matrixWorld);

    // Make all grass patches invisible initially
    for (const child of this.group.children) {
      child.visible = false;
    }

    // Create frustum for culling
    const frustum = new THREE.Frustum();
    const projScreenMatrix = new THREE.Matrix4();
    projScreenMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(projScreenMatrix);
    
    // Calculate base cell position
    const baseCellPos = new THREE.Vector3().copy(this.camera.position);
    baseCellPos.divideScalar(GRASS_PATCH_SIZE);
    baseCellPos.floor();
    baseCellPos.multiplyScalar(GRASS_PATCH_SIZE);
    
    // Copy meshes arrays for reuse
    const meshesLow = [...this.meshesLow];
    const meshesHigh = [...this.meshesHigh];
    
    // Camera position flattened to XZ plane for distance calculation
    const cameraPosXZ = new THREE.Vector3(this.camera.position.x, 0, this.camera.position.z);
    
    // Spawn grass patches
    let totalGrass = 0;
    let totalVerts = 0;
    
    for (let x = -22; x < 22; x++) {
      for (let z = -22; z < 22; z++) {
        // Current cell position
        const currentCell = new THREE.Vector3(
          baseCellPos.x + x * GRASS_PATCH_SIZE, 
          0,
          baseCellPos.z + z * GRASS_PATCH_SIZE
        );
        
        // Create AABB for culling
        const aabb = new THREE.Box3().setFromCenterAndSize(
          currentCell,
          new THREE.Vector3(GRASS_PATCH_SIZE, 1000, GRASS_PATCH_SIZE)
        );
        
        // Calculate distance to cell
        const distToCell = aabb.distanceToPoint(cameraPosXZ);
        
        // Skip if too far
        if (distToCell > GRASS_MAX_DIST) {
          continue;
        }
        
        // Skip if outside frustum
        if (!frustum.intersectsBox(aabb)) {
          continue;
        }
        
        // Create or reuse grass mesh based on distance
        if (distToCell > GRASS_LOD_DIST) {
          const mesh = meshesLow.length > 0 ? meshesLow.pop()! : this.createGrassMesh(distToCell);
          mesh.position.copy(currentCell);
          mesh.visible = true;
          totalVerts += GRASS_VERTICES_LOW;
        } else {
          const mesh = meshesHigh.length > 0 ? meshesHigh.pop()! : this.createGrassMesh(distToCell);
          mesh.position.copy(currentCell);
          mesh.visible = true;
          totalVerts += GRASS_VERTICES_HIGH;
        }
        
        totalGrass += 1;
      }
    }
  }
}

let grassComponent: GrassComponent | null = null;

// Initialize the grass system
export function initGrassSystem(world: ECS) {
  const { scene, camera } = world.ctx.three;
  
  // Create the grass component on system init
  grassComponent = new GrassComponent(scene, camera as THREE.PerspectiveCamera);
  
  // Return the system function
  return function grassSystem(world: ECS) {
    // Get player position from the camera
    const playerPosition = world.ctx.three.camera.position.clone();
    
    // Update grass with elapsed time and player position
    if (grassComponent) {
      grassComponent.update(world.time.dt, playerPosition);
    }
    
    return world;
  };
} 

================================================
File: /src/ecs/systems/healthSystem.ts
================================================
import { defineQuery, hasComponent, removeEntity } from "bitecs";
import { Health, LocalPlayer, NetworkId, RemotePlayer } from "../components";
import { ECS } from "../world";
import { network } from "./network/client"; // Assuming network client is accessible

export function initHealthSystem(world: ECS) {
    const playerQuery = defineQuery([Health, NetworkId]); // Query players with health and network ID

    return (w: ECS) => {
        const entities = playerQuery(w);

        for (const eid of entities) {
            if (Health.current[eid] <= 0) {
                // Player is defeated
                if (hasComponent(w, LocalPlayer, eid)) {
                    // Handle local player death (e.g., show death screen, disable input)
                    // The server will send the actual respawn command
                    if (!w.ctx.localPlayerDefeated) { // Prevent multiple death triggers
                        console.log("Local player defeated! Waiting for server respawn...");
                        w.ctx.localPlayerDefeated = true; // Flag to prevent re-triggering
                        // Optionally disable local player controls here
                        // The 'respawn' message from the server will re-enable things
                    }
                } else if (hasComponent(w, RemotePlayer, eid)) {
                    // Handle remote player death visual/sound (optional)
                    // Server handles actual removal/respawn logic
                     // console.log(`Remote player ${NetworkId.id[eid]} visually defeated.`);
                     // Potentially trigger death animation here if not handled by worldState update
                     // Note: Server might remove the player entity shortly after defeat broadcast
                }

                // Note: Don't remove the entity here. The server controls entity lifetime.
                // The server will either send a respawn update or a playerLeft message.
            } else {
                 // If player was defeated but now has health > 0 (likely respawned)
                 if (hasComponent(w, LocalPlayer, eid) && w.ctx.localPlayerDefeated) {
                     console.log("Local player respawned.");
                     w.ctx.localPlayerDefeated = false; // Reset defeated flag
                     // Re-enable controls if they were disabled
                 }
            }
        }

        // Reset local player defeated flag if the entity is removed (e.g., disconnect)
        if (w.ctx.localPlayerDefeated && !entities.includes(world.players.get(world.ctx.localPlayerId!)!)) {
             w.ctx.localPlayerDefeated = false;
        }


        return w;
    };
}

// Add localPlayerDefeated flag to ECSContext interface in world.ts
declare module '../world' {
    interface ECSContext {
        localPlayerDefeated?: boolean;
    }
}

================================================
File: /src/ecs/systems/input.ts
================================================
import { addComponent, addEntity } from 'bitecs';
import { DebugVis } from '../components';
import { ECS } from '../world';
import { safeAddEventListener, setupEventCleanup } from '../utils/eventUtils';

// Add property to Window interface
declare global {
  interface Window {
    listenersAttached?: boolean;
  }
}

export interface InputState {
  fw: boolean; bk: boolean; lf: boolean; rt: boolean;
  sprint: boolean;
  shoot: boolean; jump: boolean;
  pointerLocked: boolean;
  dx: number; dy: number;
  debugActive: boolean;
}

export function initInputSystem(world: ECS) {
  const state: InputState = {
    fw: false, bk: false, lf: false, rt: false,
    sprint: false,
    shoot: false, jump: false,
    pointerLocked: false,
    dx: 0, dy: 0,
    debugActive: false
  };
  
  // Keep track of whether V was pressed last frame
  let vWasPressed = false;
  
  // Create a singleton debug entity and add the component to it
  const debugId = addEntity(world); // Create a new entity, don't assume ID 0
  addComponent(world, DebugVis, debugId);
  DebugVis.active[debugId] = 0; // 0 = off, 1 = on

  /* keyboard ------------------------------------------------------- */
  const key = (code: string, v: boolean) => {
    if (code === 'KeyW' || code === 'ArrowUp')    state.fw     = v;
    if (code === 'KeyS' || code === 'ArrowDown')  state.bk     = v;
    if (code === 'KeyA' || code === 'ArrowLeft')  state.lf     = v;
    if (code === 'KeyD' || code === 'ArrowRight') state.rt     = v;
    if (code === 'Space')                         state.jump   = v;
    if (code === 'ShiftLeft' || code === 'ShiftRight') state.sprint = v;
    
    // Handle V key press for debug visualization toggle
    if (code === 'KeyV') {
      // Toggle on key down only
      if (v && !vWasPressed) {
        // Toggle debug state
        const newState = DebugVis.active[debugId] === 0 ? 1 : 0;
        DebugVis.active[debugId] = newState;
        state.debugActive = newState === 1;
        console.log(`Debug visualization: ${state.debugActive ? 'ON' : 'OFF'}`);
      }
      vWasPressed = v;
    }
  };
  
  // Only attach event listeners once
  if (!window.listenersAttached) {
    safeAddEventListener(window, 'keydown', e => key((e as KeyboardEvent).code, true));
    safeAddEventListener(window, 'keyup',   e => key((e as KeyboardEvent).code, false));

    /* mouse ---------------------------------------------------------- */
    const canvas = document.getElementById('c') as HTMLCanvasElement;
    safeAddEventListener(canvas, 'click', () => canvas.requestPointerLock());

    safeAddEventListener(document, 'pointerlockchange', () => {
      state.pointerLocked = !!document.pointerLockElement;
    });

    safeAddEventListener(window, 'mousemove', e => {
      if (!state.pointerLocked) return;
      state.dx += (e as MouseEvent).movementX;
      state.dy += (e as MouseEvent).movementY;
    });

    safeAddEventListener(window, 'mousedown', e => { if ((e as MouseEvent).button === 0) state.shoot = true; });
    safeAddEventListener(window, 'mouseup',   e => { if ((e as MouseEvent).button === 0) state.shoot = false; });
    
    // Set up event cleanup
    setupEventCleanup();
    
    // Mark listeners as attached
    window.listenersAttached = true;
  }

  return (w: ECS) => { 
    // Set the input state on the world
    w.input = state;
    return w;
  };
}


================================================
File: /src/ecs/systems/network/client.ts
================================================
import {
    addComponent,
    addEntity,
    defineQuery,
    enterQuery,
    exitQuery,
    hasComponent,
    removeComponent,
    removeEntity
} from 'bitecs';
import * as THREE from 'three';
import { NetworkConfig, WeaponConfig, PlayerConfig } from '../../config';
import {
    AnimationState, Health, InterpolationTarget, LocalPlayer, MeshRef, NetworkId, RemotePlayer, RigidBodyRef, Transform, Projectile, Lifespan, Velocity
} from '../../components';
import { ECS, ECSContext } from '../../world';
import { PlayerAnimationState } from '../../config';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'; // Needed for loading remote player models
import { createVisualProjectile } from '../player/shootSystem'; // Import the visual projectile function

// --- Network State Interface ---
export interface NetworkState {
    connected: boolean;
    connecting: boolean;
    socket: WebSocket | null;
    messageQueue: any[]; // Queue for incoming messages
    pendingUpdates: Map<number, any>; // EntityId -> Last sent state for diffing (optimization)
    lastSentTime: number;
    lastPingTime: number;
}

// --- Network Singleton ---
// Using a singleton pattern for managing the WebSocket connection
class NetworkClient {
    private world: ECS | null = null;
    private state: NetworkState = {
        connected: false,
        connecting: false,
        socket: null,
        messageQueue: [],
        pendingUpdates: new Map(),
        lastSentTime: 0,
        lastPingTime: 0
    };
    private reconnectAttempts = 0;
    private maxReconnectAttempts = 5;
    private reconnectTimer: NodeJS.Timeout | null = null;
    private modelsLoaded = false; // Track if base models are loaded

    async connect(world: ECS): Promise<void> {
        if (this.state.connected || this.state.connecting) {
            console.warn("Network connection already established or in progress.");
            return;
        }

        this.world = world;
        this.world.network = this.state; // Link the state to the world
        this.state.connecting = true;
        console.log(`Attempting to connect to ${NetworkConfig.SERVER_URL}...`);

        // Preload models needed for remote players before connecting
        await this.preloadModels();

        try {
            this.state.socket = new WebSocket(NetworkConfig.SERVER_URL);

            this.state.socket.onopen = () => {
                console.log("WebSocket connection established.");
                this.state.connected = true;
                this.state.connecting = false;
                this.reconnectAttempts = 0; // Reset attempts on successful connection
                if (this.reconnectTimer) clearTimeout(this.reconnectTimer);
                this.state.lastPingTime = Date.now(); // Start ping timer
            };

            this.state.socket.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data as string);
                    // Push message to the queue to be processed by the system
                    this.state.messageQueue.push(message);
                } catch (error) {
                    console.error("Failed to parse server message:", error);
                }
            };

            this.state.socket.onerror = (error) => {
                console.error("WebSocket error:", error);
                // Error event often precedes close event, let onclose handle reconnect
            };

            this.state.socket.onclose = (event) => {
                console.log(`WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason}`);
                this.state.connected = false;
                this.state.connecting = false;
                this.state.socket = null;
                this.world!.ctx.localPlayerId = null; // Reset local player ID
                // Maybe clear existing remote players here? Or let the server handle it on re-init.
                this.scheduleReconnect();
            };
        } catch (error) {
            console.error("Failed to create WebSocket connection:", error);
            this.state.connecting = false;
            this.scheduleReconnect();
        }
    }

    private scheduleReconnect(): void {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.error("Max reconnection attempts reached. Please refresh the page.");
            return;
        }
        if (this.reconnectTimer) clearTimeout(this.reconnectTimer);

        this.reconnectAttempts++;
        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts -1), 30000); // Exponential backoff
        console.log(`Attempting to reconnect in ${delay / 1000} seconds (Attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);

        this.reconnectTimer = setTimeout(() => {
            if (this.world) {
                this.connect(this.world);
            }
        }, delay);
    }

    send(data: any): void {
        if (this.state.connected && this.state.socket) {
            this.state.socket.send(JSON.stringify(data));
        }
    }

    disconnect(): void {
        if (this.reconnectTimer) clearTimeout(this.reconnectTimer);
        this.reconnectAttempts = this.maxReconnectAttempts; // Prevent further attempts
        if (this.state.socket) {
            this.state.socket.close();
            this.state.socket = null;
        }
        this.state.connected = false;
        this.state.connecting = false;
        console.log("Network disconnected manually.");
    }

    // --- Model Preloading ---
    private async preloadModels() {
        if (this.modelsLoaded) return;
        console.log("Preloading player model for remote players...");
        const loader = new GLTFLoader();
        try {
            await loader.loadAsync('/models/playermodel.glb');
            this.modelsLoaded = true;
            console.log("Player model preloaded successfully.");
        } catch (error) {
            console.error("Failed to preload player model:", error);
        }
    }
}

export const network = new NetworkClient(); // Export singleton instance

// --- ECS Network System ---
export function initNetworkSystem(world: ECS) {
    const localPlayerQuery = defineQuery([LocalPlayer, Transform, Health, AnimationState]);
    const remotePlayerQuery = defineQuery([RemotePlayer, NetworkId, Transform, MeshRef, InterpolationTarget]);
    const networkIdMap = world.players; // Use the map from the world object

    // --- Queries for Adding/Removing Remote Players ---
    const remotePlayerEnterQuery = enterQuery(remotePlayerQuery);
    const remotePlayerExitQuery = exitQuery(remotePlayerQuery);

    // --- Message Handlers ---
    const handleInit = (data: any) => {
        console.log("Received init from server:", data);
        world.ctx.localPlayerId = data.playerId;

        // Find the local player entity (should have been created by initPlayerSystem)
        const localPlayers = localPlayerQuery(world);
        if (localPlayers.length > 0) {
            const localEid = localPlayers[0];
            // Add NetworkId if it doesn't exist, or update it
            if (!hasComponent(world, NetworkId, localEid)) {
                 addComponent(world, NetworkId, localEid);
            }
            NetworkId.id[localEid] = data.playerId;
            networkIdMap.set(data.playerId, localEid);

             // Initialize local player state from server if necessary (e.g., spawn pos)
            if (data.initialState?.position) {
                 Transform.x[localEid] = data.initialState.position.x;
                 Transform.y[localEid] = data.initialState.position.y;
                 Transform.z[localEid] = data.initialState.position.z;
                // Also update the RigidBody position if it exists
                const rb = world.ctx.maps.rb.get(localEid);
                if(rb) {
                    rb.setTranslation(data.initialState.position, true);
                     // Reset velocity after setting position
                    rb.setLinvel({ x: 0, y: 0, z: 0 }, true);
                    rb.setAngvel({ x: 0, y: 0, z: 0 }, true);
                }
            }
            if (data.initialState?.rotation) {
                Transform.qx[localEid] = data.initialState.rotation.x;
                Transform.qy[localEid] = data.initialState.rotation.y;
                Transform.qz[localEid] = data.initialState.rotation.z;
                Transform.qw[localEid] = data.initialState.rotation.w;
                 const rb = world.ctx.maps.rb.get(localEid);
                 if(rb) rb.setRotation(data.initialState.rotation, true);
            }
             if (data.initialState?.health !== undefined) {
                Health.current[localEid] = data.initialState.health;
                Health.max[localEid] = data.initialState.maxHealth || PlayerConfig.MAX_HEALTH;
             }
        } else {
            console.error("LocalPlayer entity not found during network init!");
        }

        // Add existing players from the server message
        data.players?.forEach((playerState: any) => handlePlayerJoined({ playerState }));
    };

    const handlePlayerJoined = (data: any) => {
        const playerState = data.playerState;
        if (!playerState || playerState.id === world.ctx.localPlayerId || networkIdMap.has(playerState.id)) {
            return; // Don't add self or existing players
        }
        console.log(`Player ${playerState.id} joined, creating remote entity...`);
        addRemotePlayer(world, world.ctx, playerState);
    };

    const handlePlayerLeft = (data: any) => {
        const remoteEid = networkIdMap.get(data.playerId);
        if (remoteEid !== undefined) {
            console.log(`Player ${data.playerId} left, removing entity ${remoteEid}`);
            removeRemotePlayer(world, world.ctx, remoteEid);
            networkIdMap.delete(data.playerId);
        } else {
             console.log(`Received playerLeft for unknown or already removed player ${data.playerId}`);
        }
    };

    const handleWorldState = (data: any) => {
        data.players?.forEach((playerState: any) => {
            if (playerState.id === world.ctx.localPlayerId) return; // Ignore updates for local player state

            const remoteEid = networkIdMap.get(playerState.id);
            if (remoteEid !== undefined) {
                // Update existing remote player's target state for interpolation
                if (hasComponent(world, InterpolationTarget, remoteEid)) {
                    InterpolationTarget.targetX[remoteEid] = playerState.position.x;
                    InterpolationTarget.targetY[remoteEid] = playerState.position.y;
                    InterpolationTarget.targetZ[remoteEid] = playerState.position.z;
                    InterpolationTarget.targetQX[remoteEid] = playerState.rotation.x;
                    InterpolationTarget.targetQY[remoteEid] = playerState.rotation.y;
                    InterpolationTarget.targetQZ[remoteEid] = playerState.rotation.z;
                    InterpolationTarget.targetQW[remoteEid] = playerState.rotation.w;
                    InterpolationTarget.timestamp[remoteEid] = data.timestamp; // Use server timestamp
                }
                if (hasComponent(world, AnimationState, remoteEid)) {
                    AnimationState.state[remoteEid] = playerState.animationState;
                }
                if (hasComponent(world, Health, remoteEid) && playerState.health !== undefined) {
                     Health.current[remoteEid] = playerState.health;
                }
            } else {
                // Player doesn't exist locally, add them (might happen on late join/reconnect)
                console.log(`WorldState adding missing player ${playerState.id}`);
                addRemotePlayer(world, world.ctx, playerState);
            }
        });
    };

    const handlePlayerShoot = (data: any) => {
        const shooterEid = networkIdMap.get(data.playerId);
        if (shooterEid === undefined || shooterEid === world.ctx.localPlayerId) return; // Ignore self or unknown

        // Find the shooter entity to get accurate position/direction for effects
        const shooterMesh = world.ctx.maps.mesh.get(shooterEid);
        if (shooterMesh) {
            // Use the provided position/direction from the message for spawning
            const pos = new THREE.Vector3(data.position.x, data.position.y, data.position.z);
            const dir = new THREE.Vector3(data.direction.x, data.direction.y, data.direction.z);

            // Create visual projectile for remote player shot
            createVisualProjectile(world, pos, dir, 0x00aaff);
            
            // TODO: Play shooting sound spatially from shooterMesh position
        } else {
            console.warn(`Shooter mesh not found for remote player ${data.playerId}`);
        }
    };

    const handlePlayerDamaged = (data: any) => {
        const localPlayers = localPlayerQuery(world);
        if (localPlayers.length > 0) {
            const localEid = localPlayers[0];
            console.log(`Local player (${NetworkId.id[localEid]}) took ${data.damage} damage from ${data.sourceId}`);
            if (hasComponent(world, Health, localEid)) {
                Health.current[localEid] = data.newHealth;
                // Trigger UI update or visual feedback here
                console.log(`My new health: ${Health.current[localEid]}`);
            }
        }
    };

    const handleHealthUpdate = (data: any) => {
        const targetEid = networkIdMap.get(data.playerId);
        if (targetEid !== undefined && targetEid !== world.ctx.localPlayerId) {
            if (hasComponent(world, Health, targetEid)) {
                Health.current[targetEid] = data.health;
            }
        }
    };

    const handleRespawn = (data: any) => {
        console.log("Received respawn confirmation from server", data.newState);
        const localPlayers = localPlayerQuery(world);
        if (localPlayers.length > 0) {
            const localEid = localPlayers[0];
            const newState = data.newState;

            // Forcefully set state based on server respawn data
            if (newState.position) {
                Transform.x[localEid] = newState.position.x;
                Transform.y[localEid] = newState.position.y;
                Transform.z[localEid] = newState.position.z;
                const rb = world.ctx.maps.rb.get(localEid);
                if (rb) {
                    rb.setTranslation(newState.position, true);
                    rb.setLinvel({ x: 0, y: 0, z: 0 }, true);
                    rb.setAngvel({ x: 0, y: 0, z: 0 }, true);
                }
                // Reset vertical velocity in FPController
                if(hasComponent(world, FPController, localEid)) {
                    FPController.vertVel[localEid] = 0;
                    FPController.moveState[localEid] = MovementState.GROUNDED; // Assume grounded after respawn
                }
            }
            if (newState.rotation) {
                Transform.qx[localEid] = newState.rotation.x;
                Transform.qy[localEid] = newState.rotation.y;
                Transform.qz[localEid] = newState.rotation.z;
                Transform.qw[localEid] = newState.rotation.w;
                const rb = world.ctx.maps.rb.get(localEid);
                if(rb) rb.setRotation(newState.rotation, true);
                // Also potentially update camera pitch if needed, though server usually doesn't dictate this
            }
            if (newState.health !== undefined) {
                Health.current[localEid] = newState.health;
                Health.max[localEid] = newState.maxHealth || PlayerConfig.MAX_HEALTH;
            }
            AnimationState.state[localEid] = PlayerAnimationState.IDLE; // Reset animation

            console.log(`Local player respawned at ${newState.position.x.toFixed(2)}, ${newState.position.y.toFixed(2)}, ${newState.position.z.toFixed(2)}`);
            // Trigger UI updates if necessary
        }
    };

    // --- System Logic ---
    return (w: ECS) => {
        const now = Date.now();

        // --- Process Incoming Messages ---
        while (w.network.messageQueue.length > 0) {
            const message = w.network.messageQueue.shift();
            switch (message.type) {
                case 'init': handleInit(message); break;
                case 'playerJoined': handlePlayerJoined(message); break;
                case 'playerLeft': handlePlayerLeft(message); break;
                case 'worldState': handleWorldState(message); break; // Use worldState for updates
                case 'playerShoot': handlePlayerShoot(message); break;
                case 'playerDamaged': handlePlayerDamaged(message); break; // When local player is damaged
                case 'healthUpdate': handleHealthUpdate(message); break; // For remote player health changes
                case 'respawn': handleRespawn(message); break;
                case 'hitConfirmed': /* Optional: Show hit marker for local player */ break;
                case 'playerDefeated': /* Optional: Show kill feed message */ break;
                case 'playerRespawned': /* Optional: Handle remote player visual respawn */ break;
                case 'ping': /* Server ping, client can ignore or track latency */ break;
                case 'error': console.error("Server Error:", message.message); break;
                default: console.warn("Received unhandled message type:", message.type);
            }
        }

        // --- Send Local Player Updates ---
        if (w.network.connected && now - w.network.lastSentTime > NetworkConfig.UPDATE_INTERVAL_MS) {
            const localPlayers = localPlayerQuery(w);
            if (localPlayers.length > 0) {
                const eid = localPlayers[0];
                const currentState = {
                    position: { x: Transform.x[eid], y: Transform.y[eid], z: Transform.z[eid] },
                    rotation: { x: Transform.qx[eid], y: Transform.qy[eid], z: Transform.qz[eid], w: Transform.qw[eid] },
                    animationState: AnimationState.state[eid],
                    health: Health.current[eid], // Include health
                };

                network.send({ type: 'playerUpdate', state: currentState });
                w.network.lastSentTime = now;
            }
        }

        // --- Interpolate Remote Players ---
        const remoteEntities = remotePlayerQuery(w);
        const renderTime = now - NetworkConfig.INTERPOLATION_DELAY_MS; // Target time for rendering

        for (const eid of remoteEntities) {
            const currentTimestamp = InterpolationTarget.timestamp[eid];
            const targetX = InterpolationTarget.targetX[eid];
            const targetY = InterpolationTarget.targetY[eid];
            const targetZ = InterpolationTarget.targetZ[eid];
            const targetQX = InterpolationTarget.targetQX[eid];
            const targetQY = InterpolationTarget.targetQY[eid];
            const targetQZ = InterpolationTarget.targetQZ[eid];
            const targetQW = InterpolationTarget.targetQW[eid];

            // Very simple interpolation: Move halfway towards the target each frame
            const lerpFactor = 0.2; // Adjust this for smoothness

            Transform.x[eid] += (targetX - Transform.x[eid]) * lerpFactor;
            Transform.y[eid] += (targetY - Transform.y[eid]) * lerpFactor;
            Transform.z[eid] += (targetZ - Transform.z[eid]) * lerpFactor;

            // Use Quaternion slerp for smoother rotation interpolation
            const currentQuat = new THREE.Quaternion(Transform.qx[eid], Transform.qy[eid], Transform.qz[eid], Transform.qw[eid]);
            const targetQuat = new THREE.Quaternion(targetQX, targetQY, targetQZ, targetQW);
            currentQuat.slerp(targetQuat, lerpFactor);

            Transform.qx[eid] = currentQuat.x;
            Transform.qy[eid] = currentQuat.y;
            Transform.qz[eid] = currentQuat.z;
            Transform.qw[eid] = currentQuat.w;
        }

        // --- Handle Player Model Loading for New Remote Players ---
        const entered = remotePlayerEnterQuery(w);
        for (const eid of entered) {
            const networkId = NetworkId.id[eid];
            console.log(`Remote player entity ${eid} (NetworkID: ${networkId}) entered query. Setting up model...`);
            // Ensure the setup runs only once per entity entry
            if (!world.ctx.maps.mesh.has(eid)) {
                setupRemotePlayerModel(world, world.ctx, eid, networkId);
            }
        }

        // --- Handle Cleanup for Removed Remote Players ---
        const exited = remotePlayerExitQuery(w);
        for (const eid of exited) {
            console.log(`Remote player entity ${eid} exited query. Cleaning up...`);
            removeRemotePlayer(world, world.ctx, eid);
            // The NetworkId mapping is cleaned up in handlePlayerLeft
        }

        // --- Ping Server ---
        if (w.network.connected && now - w.network.lastPingTime > NetworkConfig.PING_INTERVAL_MS) {
            network.send({ type: 'ping' });
            w.network.lastPingTime = now;
        }

        return w;
    };
}

async function addRemotePlayer(world: ECS, ctx: ECSContext, playerState: any) {
    if (ctx.localPlayerId === playerState.id) {
        console.warn(`Attempted to add local player ${playerState.id} as remote.`);
        return;
    }
    if (world.players.has(playerState.id)) {
        console.warn(`Remote player ${playerState.id} already exists.`);
        return;
    }

    const eid = addEntity(world);
    addComponent(world, RemotePlayer, eid);
    addComponent(world, NetworkId, eid);
    addComponent(world, Transform, eid);
    addComponent(world, MeshRef, eid); // Needed for RenderSync
    addComponent(world, Health, eid);
    addComponent(world, AnimationState, eid);
    addComponent(world, InterpolationTarget, eid); // For smooth movement

    NetworkId.id[eid] = playerState.id;
    Transform.x[eid] = playerState.position.x;
    Transform.y[eid] = playerState.position.y;
    Transform.z[eid] = playerState.position.z;
    Transform.qx[eid] = playerState.rotation.x;
    Transform.qy[eid] = playerState.rotation.y;
    Transform.qz[eid] = playerState.rotation.z;
    Transform.qw[eid] = playerState.rotation.w;
    Health.current[eid] = playerState.health;
    Health.max[eid] = playerState.maxHealth || PlayerConfig.MAX_HEALTH; // Use default if not provided
    AnimationState.state[eid] = playerState.animationState;

    // Initialize interpolation target to current state
    InterpolationTarget.targetX[eid] = playerState.position.x;
    InterpolationTarget.targetY[eid] = playerState.position.y;
    InterpolationTarget.targetZ[eid] = playerState.position.z;
    InterpolationTarget.targetQX[eid] = playerState.rotation.x;
    InterpolationTarget.targetQY[eid] = playerState.rotation.y;
    InterpolationTarget.targetQZ[eid] = playerState.rotation.z;
    InterpolationTarget.targetQW[eid] = playerState.rotation.w;
    InterpolationTarget.timestamp[eid] = Date.now(); // Use current time initially

    world.players.set(playerState.id, eid); // Map NetworkId to EntityId

    console.log(`Added remote player entity ${eid} for NetworkId ${playerState.id}`);

    // Model setup is now handled by the enterQuery in the system loop
}

async function setupRemotePlayerModel(world: ECS, ctx: ECSContext, eid: number, networkId: number) {
    console.log(`Setting up model for remote entity ${eid} (NetworkID: ${networkId})`);
    const loader = new GLTFLoader();
    try {
        const gltf = await loader.loadAsync('/models/playermodel.glb');
        const model = gltf.scene;

        model.scale.set(1, 1, 1); // Adjust scale as needed
        model.position.set(0, 0, 0); // Position should be at entity center, not offset
        model.rotation.y = 0; // Don't add rotation - let the transform handle it
        
        // Add animation mixer if animations exist
        let mixer: THREE.AnimationMixer | null = null;
        if (gltf.animations && gltf.animations.length > 0) {
            mixer = new THREE.AnimationMixer(model);
            // Store animations/actions for playback later
            model.userData.animations = gltf.animations; // Store animations raw data
            model.userData.mixer = mixer;
            model.userData.actions = {};
            
            gltf.animations.forEach(clip => {
                // Rename the clips to standardized names for better matching
                let clipName = clip.name.toLowerCase();
                let standardName = clip.name;
                
                if (clipName.includes('idle')) standardName = 'idle';
                else if (clipName.includes('walk')) standardName = 'walk';
                else if (clipName.includes('run')) standardName = 'run';
                else if (clipName.includes('jump')) {
                    if (clipName.includes('start')) standardName = 'jump_start';
                    else if (clipName.includes('fall')) standardName = 'jump_fall';
                    else standardName = 'jump';
                }
                
                const action = mixer.clipAction(clip);
                action.setLoop(THREE.LoopRepeat, Infinity);
                model.userData.actions[standardName] = action;
                console.log(`Animation loaded for remote player: ${standardName}`);
            });
            
            // Start idle animation by default
            if (model.userData.actions['idle']) {
                model.userData.actions['idle'].play();
            }
        }

        model.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });

        ctx.three.scene.add(model);
        ctx.maps.mesh.set(eid, model); // Link entity ID to the model
        console.log(`Model added for remote player ${networkId} (Entity ${eid})`);

    } catch (error) {
        console.error(`Failed to load model for remote player ${networkId}:`, error);
        // Optionally add a placeholder mesh on error
        const placeholder = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 1.8, 0.6),
            new THREE.MeshStandardMaterial({ color: 0xcccccc })
        );
        placeholder.position.y = 0.9;
        ctx.three.scene.add(placeholder);
        ctx.maps.mesh.set(eid, placeholder);
    }
}

function removeRemotePlayer(world: ECS, ctx: ECSContext, eid: number) {
    const mesh = ctx.maps.mesh.get(eid);
    if (mesh) {
        // Properly dispose of mesh resources
        mesh.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                child.geometry?.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach((mat) => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            }
        });
        ctx.three.scene.remove(mesh);
        ctx.maps.mesh.delete(eid);
    }
    
    // Remove Rapier body if it exists (remote players might not have one client-side)
    const rb = ctx.maps.rb.get(eid);
    if (rb) {
        ctx.physics.removeRigidBody(rb);
        ctx.maps.rb.delete(eid);
        if (ctx.entityHandleMap) {
            ctx.entityHandleMap.delete(rb.handle);
        }
    }

    // Remove the entity itself if it still exists
    if (hasComponent(world, NetworkId, eid)) { // Check if entity might have been removed already
        removeEntity(world, eid);
        console.log(`Removed remote player entity ${eid}`);
    } else {
        console.log(`Entity ${eid} already removed or invalid.`);
    }
}

================================================
File: /src/ecs/systems/physics.ts
================================================
import { defineQuery, exitQuery } from 'bitecs';
import { RigidBodyRef } from '../components';
import { ECS } from '../world';
import { PhysicsConfig, TimeStepConfig } from '../config';

export function initPhysicsSystem(_world: ECS) {
  const rbq = defineQuery([RigidBodyRef]);
  const exit = exitQuery(rbq);

  /* cleanup on entity removal */
  return (w: ECS) => {
    // Skip physics if we're not on a physics frame
    if (!w.time.shouldRunPhysics) {
      return w;
    }
    
    // Get all active rigid bodies
    const rigidBodies = [];
    for (const eid of rbq(w)) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb) rigidBodies.push(rb);
    }
    
    // Dynamically enable CCD on fast-moving objects
    for (const rb of rigidBodies) {
      try {
        // Different versions of Rapier have different APIs
        // Check if the body is dynamic (only dynamic bodies can have CCD)
        const isDynamic = rb.bodyType && 
                         rb.bodyType() === w.ctx.rapier.RigidBodyType.Dynamic;
        
        if (isDynamic) {
          const vel = rb.linvel();
          const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y + vel.z * vel.z);
          
          // Enable CCD for fast moving objects 
          // Check if this version of Rapier supports CCD toggling
          if (speed > PhysicsConfig.VELOCITY_THRESHOLD && rb.enableCcd) {
            rb.enableCcd(true);
          } 
          // Disable CCD for slower objects to improve performance
          else if (speed < PhysicsConfig.VELOCITY_THRESHOLD * 0.8 && rb.enableCcd) {
            rb.enableCcd(false);
          }
        }
      } catch (e) {
        // Skip CCD handling if the API doesn't match
      }
    }
    
    // Configure physics parameters if the API supports it
    try {
      if (w.ctx.physics.integrationParameters) {
        // Set solver iterations for more accurate simulation
        w.ctx.physics.integrationParameters.numSolverIterations = PhysicsConfig.SOLVER_ITERATIONS;
        
        // Increase CCD substeps - critical for bullet physics!
        w.ctx.physics.integrationParameters.maxCcdSubsteps = PhysicsConfig.CCD_SUBSTEPS;
      }
    } catch (e) {
      // Skip if the API doesn't support this
    }
    
    // Always use the fixed timestep from the time system
    const dt = w.time.fixedDt || TimeStepConfig.FIXED_DT;
    
    // Process physics step with fixed timestep - handle type issues with assertions
    if (w.ctx.eventQueue) {
      // Call step with the correct argument order based on Rapier type definitions
      // Type assertion needed due to version differences in Rapier API
      (w.ctx.physics.step as any)(w.ctx.eventQueue, dt);
    } else {
      // Type assertion needed due to differences in Rapier API versions
      (w.ctx.physics.step as any)(dt);
    }

    /* purge removed RigidBodies */
    for (const eid of exit(w)) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb) {
        w.ctx.physics.removeRigidBody(rb);
        w.ctx.maps.rb.delete(eid);
      }
    }
    return w;
  };
}


================================================
File: /src/ecs/systems/player/animationSystem.ts
================================================
import { defineQuery, hasComponent } from 'bitecs';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import {
    LocalPlayer, RemotePlayer, MeshRef, FPController, Transform, AnimationState, NetworkId
} from '../../components';
import { ECS } from '../../world';
import { MovementState, PlayerAnimationState } from '../../config';

// Store animations globally for reuse
let baseModelLoaded = false;
let baseModelAnimations: THREE.AnimationClip[] = [];

// Store player animation data per entity
const playerAnimationData = new Map<number, {
    mixer: THREE.AnimationMixer | null;
    actions: Record<string, THREE.AnimationAction>;
    currentAction: THREE.AnimationAction | null;
    model: THREE.Object3D | null;
}>();

// Try to harmonize animation names across different models
function getStandardizedAnimationName(clipName: string): string {
    const name = clipName.toLowerCase();
    if (name.includes('idle')) return 'idle';
    if (name.includes('walk')) return 'walk';
    if (name.includes('run')) return 'run';
    if (name.includes('jump')) {
        if (name.includes('start')) return 'jump_start';
        if (name.includes('fall')) return 'jump_fall';
        return 'jump';
    }
    if (name.includes('shoot')) return 'shoot';
    if (name.includes('death')) return 'death';
    // Default to original name if no match
    return clipName;
}

// Preload the player model for better load times
async function preloadBaseModel() {
    if (baseModelLoaded) return;
    console.log("Preloading base player model for animations...");
    const loader = new GLTFLoader();
    try {
        const gltf = await loader.loadAsync('/models/playermodel.glb');
        baseModelAnimations = gltf.animations;
        baseModelLoaded = true;
        
        // Log available animations for debugging
        console.log("Base animations loaded:");
        gltf.animations.forEach(clip => {
            console.log(`- Animation: ${clip.name} (${getStandardizedAnimationName(clip.name)})`);
        });
    } catch (error) {
        console.error("Failed to preload base player model animations:", error);
    }
}
preloadBaseModel();

export function initPlayerAnimationSystem(world: ECS) {
    // Query for all players that need animations (both local and remote)
    const playerQuery = defineQuery([MeshRef, Transform, AnimationState]);
    const localPlayerQuery = defineQuery([LocalPlayer, FPController]);

    // --- Helper Functions ---
    
    /**
     * Sets up animations for a player entity from the base model animations
     */
    function setupPlayerAnimations(eid: number, model: THREE.Object3D) {
        if (!baseModelLoaded || !model) return;

        // Find animation root (usually the model itself or an armature/skeleton)
        let animationRoot = model;
        model.traverse(node => {
            if (node.name.toLowerCase().includes('armature') || 
                node.name.toLowerCase().includes('rig') || 
                node.name.toLowerCase().includes('skeleton')) {
                animationRoot = node;
                return;
            }
        });

        // Create animation mixer
        const mixer = new THREE.AnimationMixer(animationRoot);
        const actions: Record<string, THREE.AnimationAction> = {};
        
        // Disable error logging for missing bones to avoid console spam
        const originalConsoleError = console.error;
        console.error = function() {}; // Temporarily suppress errors

        // Process all animations
        baseModelAnimations.forEach(clip => {
            try {
                const action = mixer.clipAction(clip);
                const standardName = getStandardizedAnimationName(clip.name);
                
                // Configure action for smooth looping
                if (standardName === 'idle' || standardName === 'walk' || standardName === 'run') {
                    action.setLoop(THREE.LoopRepeat, Infinity);
                } else {
                    action.setLoop(THREE.LoopOnce, 1);
                    action.clampWhenFinished = true;
                }
                
                actions[standardName] = action;
            } catch (error) {
                // Silently ignore animation errors
            }
        });

        // Restore console.error
        console.error = originalConsoleError;

        // Find default idle action and play it
        let currentAction: THREE.AnimationAction | null = null;
        if (actions['idle']) {
            currentAction = actions['idle'];
            currentAction.play();
        }

        // Store animation data for this entity
        playerAnimationData.set(eid, { mixer, actions, currentAction, model });
        console.log(`Animation setup complete for player entity ${eid}`);
    }

    /**
     * Fades smoothly from one animation to another
     */
    function fadeToAction(eid: number, actionName: string, duration: number = 0.2) {
        const data = playerAnimationData.get(eid);
        if (!data || !data.actions[actionName]) return;

        const nextAction = data.actions[actionName];
        const previousAction = data.currentAction;

        if (previousAction === nextAction) return; // Already playing

        nextAction.enabled = true;
        nextAction.setEffectiveTimeScale(1);
        nextAction.setEffectiveWeight(1);
        nextAction.time = 0; // Reset time when fading in

        if (previousAction) {
            previousAction.fadeOut(duration);
        }

        nextAction.reset().fadeIn(duration).play();
        data.currentAction = nextAction;
    }

    /**
     * Creates and attaches a player model to the local player
     */
    function createLocalPlayerModel(eid: number) {
        if (playerAnimationData.has(eid)) return; // Already set up
        
        const playerObj = world.ctx.maps.mesh.get(eid);
        if (!playerObj || !baseModelLoaded) return;
        
        console.log("Setting up local player model...");
        const loader = new GLTFLoader();
        loader.load('/models/playermodel.glb', (gltf) => {
            const model = gltf.scene.clone(); // Clone to avoid reference issues
            
            // The model should be at the center of the player
            model.position.set(0, -0.9, 0); // Offset to align with ground
            
            // Don't add rotation - let the transform system handle it
            model.rotation.y = Math.PI; // Face forward by default

            // Add model to player holder
            playerObj.add(model);
            
            // Setup animations
            setupPlayerAnimations(eid, model);
            
            console.log("Local player model loaded and attached.");
        });
    }

    // System function
    return (w: ECS, localPlayerEid?: number) => {
        // --- Check and initialize local player model if needed ---
        if (localPlayerEid !== undefined && !playerAnimationData.has(localPlayerEid)) {
            createLocalPlayerModel(localPlayerEid);
        }

        // --- Update Mixers with delta time ---
        const delta = w.time.dt;
        playerAnimationData.forEach(data => {
            if (data.mixer) data.mixer.update(delta);
        });

        // --- Determine and Set Animation State for Local Player ---
        if (localPlayerEid !== undefined && hasComponent(w, FPController, localPlayerEid)) {
            const moveState = FPController.moveState[localPlayerEid];
            let targetAnimationState = PlayerAnimationState.IDLE;

            if (moveState === MovementState.JUMPING) {
                targetAnimationState = PlayerAnimationState.JUMPING;
            } else if (moveState === MovementState.FALLING) {
                targetAnimationState = PlayerAnimationState.FALLING;
            } else if (moveState === MovementState.GROUNDED) {
                // Check horizontal velocity magnitude for walking/running
                const rb = w.ctx.maps.rb.get(localPlayerEid);
                let speedSq = 0;
                if (rb) {
                    const linvel = rb.linvel();
                    speedSq = linvel.x * linvel.x + linvel.z * linvel.z;
                }

                if (speedSq > 50) { // Running threshold
                    targetAnimationState = PlayerAnimationState.RUNNING;
                } else if (speedSq > 0.1) { // Walking threshold
                    targetAnimationState = PlayerAnimationState.WALKING;
                } else {
                    targetAnimationState = PlayerAnimationState.IDLE;
                }
            }

            // Update animation state component for network sync
            if (AnimationState.state[localPlayerEid] !== targetAnimationState) {
                AnimationState.state[localPlayerEid] = targetAnimationState;
                console.log(`Local animation state changed to: ${targetAnimationState}`);
            }
        }

        // --- Apply Animations Based on State for ALL Players ---
        const allPlayers = playerQuery(w);
        for (const eid of allPlayers) {
            const isLocal = localPlayerEid === eid;
            const data = playerAnimationData.get(eid);
            
            // Skip if no animation data yet
            if (!data) {
                const model = w.ctx.maps.mesh.get(eid);
                // Check if this is a remote player model and set it up
                if (model && baseModelLoaded && hasComponent(w, RemotePlayer, eid)) {
                    setupPlayerAnimations(eid, model);
                }
                continue;
            }

            // Get current animation state
            const currentState = AnimationState.state[eid];
            let targetActionName = 'idle'; // Default animation

            // Convert animation state enum to action name
            switch (currentState) {
                case PlayerAnimationState.WALKING: 
                    targetActionName = 'walk'; 
                    break;
                case PlayerAnimationState.RUNNING: 
                    targetActionName = 'run'; 
                    break;
                case PlayerAnimationState.JUMPING: 
                    targetActionName = 'jump_start'; 
                    break;
                case PlayerAnimationState.FALLING: 
                    targetActionName = 'jump_fall'; 
                    break;
                case PlayerAnimationState.SHOOTING: 
                    targetActionName = 'shoot'; 
                    break;
                case PlayerAnimationState.DEATH: 
                    targetActionName = 'death'; 
                    break;
                case PlayerAnimationState.IDLE:
                default: 
                    targetActionName = 'idle'; 
                    break;
            }

            // Check if we have this animation or need a fallback
            if (!data.actions[targetActionName]) {
                // Fallback logic
                if (targetActionName === 'run' && data.actions['walk']) {
                    targetActionName = 'walk';
                } else if ((targetActionName === 'jump_start' || targetActionName === 'jump_fall') && 
                           data.actions['jump']) {
                    targetActionName = 'jump';
                } else if (!data.actions['idle']) {
                    // No idle animation - just use first available animation
                    const firstAction = Object.keys(data.actions)[0];
                    if (firstAction) targetActionName = firstAction;
                    else continue; // No animations available
                } else {
                    targetActionName = 'idle'; // Default fallback
                }
            }

            // Apply animation if different from current
            if (data.actions[targetActionName] && data.currentAction !== data.actions[targetActionName]) {
                fadeToAction(eid, targetActionName);
            }
        }

        return w;
    };
}

================================================
File: /src/ecs/systems/player/index.ts
================================================
import { addComponent, addEntity } from 'bitecs';
import * as THREE from 'three';
import {
  MeshRef, RigidBodyRef, Transform, FPController, LocalPlayer, NetworkId, Health, AnimationState
} from '../../components';
import { ECS } from '../../world';
import { MovementState, PlayerAnimationState, PlayerConfig } from '../../config';
import { initPlayerMovementSystem } from './movementSystem';
import { initPlayerLookSystem } from './lookSystem';
import { initPlayerShootSystem } from './shootSystem';
import { initPlayerAnimationSystem } from './animationSystem';

export function initPlayerSystem(world: ECS) {
  const { rapier, physics, three, maps } = world.ctx;

  // Create the *local* player entity
  const pid = addEntity(world);
  addComponent(world, LocalPlayer,    pid); // Tag as LocalPlayer
  addComponent(world, NetworkId,      pid); // Will be set by server init message
  addComponent(world, Transform,      pid);
  addComponent(world, MeshRef,        pid);
  addComponent(world, RigidBodyRef,   pid);
  addComponent(world, FPController,   pid);
  addComponent(world, Health,         pid);
  addComponent(world, AnimationState, pid);

  NetworkId.id[pid] = 0; // Placeholder ID, server will assign correct one
  Health.current[pid] = PlayerConfig.MAX_HEALTH;
  Health.max[pid] = PlayerConfig.MAX_HEALTH;
  AnimationState.state[pid] = PlayerAnimationState.IDLE; // Start in Idle state

  // Initialize controller state
  FPController.pitch[pid] = 0;
  FPController.vertVel[pid] = 0;
  FPController.moveState[pid] = MovementState.GROUNDED;
  FPController.lastGrounded[pid] = performance.now();
  FPController.lastJump[pid] = 0;
  FPController.jumpRequested[pid] = 0;
  FPController.lastJumpRequest[pid] = 0;

  // --- Mesh Holder ---
  const holder = new THREE.Object3D();
  // Start position might be overridden by server 'init' message
  holder.position.set(0, 10, 0); // Start higher above the ground to prevent falling through
  three.scene.add(holder);
  maps.mesh.set(pid, holder); // Associate entity ID with the holder mesh

  // Camera setup inside the holder
  const cameraOffset = new THREE.Object3D();
  cameraOffset.position.set(0, 1.7, 0); // Eye height - slightly higher than model head
  holder.add(cameraOffset);
  cameraOffset.add(three.camera);

  // --- Rapier Body ---
  const rb = physics.createRigidBody(
    rapier.RigidBodyDesc.kinematicPositionBased()
          .setTranslation(holder.position.x, holder.position.y, holder.position.z)
          .setCcdEnabled(true) // Keep CCD enabled for player potentially
  );
  
  // Create a slightly smaller capsule collider to avoid getting stuck
  const collider = physics.createCollider(
    rapier.ColliderDesc.capsule(0.8, 0.3) // Height 0.8, Radius 0.3
      .setFriction(0.1)
      .setDensity(1.0), // Set density for KCC interactions
    rb
  );

  // --- Kinematic Character Controller ---
  const kcc = physics.createCharacterController(0.02); // Slightly larger offset
  kcc.setApplyImpulsesToDynamicBodies(true);
  kcc.enableAutostep(0.4, 0.4, true); // Adjusted auto-step parameters
  kcc.enableSnapToGround(0.5); // Increased snap distance slightly
  kcc.setSlideEnabled(true); // Enable sliding

  maps.rb.set(pid, rb);
  RigidBodyRef.id[pid] = rb.handle;

  // Store KCC and collider in world context
  world.ctx.kcc = kcc;
  world.ctx.playerCollider = collider;

  // Update entity handle map
  if (world.ctx.entityHandleMap) {
      world.ctx.entityHandleMap.set(rb.handle, pid);
  } else {
      world.ctx.entityHandleMap = new Map<number, number>();
      world.ctx.entityHandleMap.set(rb.handle, pid);
  }

  // Initialize sub-systems
  const movementSystem = initPlayerMovementSystem(world);
  const lookSystem = initPlayerLookSystem(world);
  const shootSystem = initPlayerShootSystem(world);
  const animationSystem = initPlayerAnimationSystem(world);

  // Combined system - runs sub-systems *only* for the local player
  return (w: ECS) => {
    // Get local player entity ID from network if available, otherwise use the initial one
    const localEid = w.ctx.localPlayerId !== null ? 
      world.players.get(w.ctx.localPlayerId!) : pid;
    
    if (localEid !== undefined) {
        // Run systems specifically for the local player entity
        lookSystem(w, localEid);
        movementSystem(w, localEid);
        shootSystem(w, localEid);
        animationSystem(w, localEid); // Animation system needs to run for local player
    } else {
        // Fallback in case network hasn't initialized player ID yet
        lookSystem(w, pid);
        movementSystem(w, pid);
        shootSystem(w, pid);
        animationSystem(w, pid);
    }
    
    return w;
  };
}

================================================
File: /src/ecs/systems/player/lookSystem.ts
================================================
import { defineQuery, hasComponent } from 'bitecs';
import * as THREE from 'three';
import { LocalPlayer, FPController, Transform } from '../../components'; // Added Transform
import { ECS } from '../../world';
import { InputState } from '../input';
import { PlayerConfig } from '../../config';

// Removed playerQuery, system now receives eid
// const playerQuery = defineQuery([LocalPlayer, FPController, Transform]);

export function initPlayerLookSystem(_world: ECS) {

    // Use temporary quaternion for calculations
    const deltaRotation = new THREE.Quaternion();
    const currentRotation = new THREE.Quaternion();
    const pitchQuat = new THREE.Quaternion();
    const yawQuat = new THREE.Quaternion();
    const forward = new THREE.Vector3(0, 0, -1);
    const worldUp = new THREE.Vector3(0, 1, 0);


    // System now receives world and the specific local player eid
    return (w: ECS, eid: number) => {
        const input = w.input as InputState;
        if (!input) return w;

        // Skip if pointer isn't locked or no mouse movement
        if (!input.pointerLocked || (input.dx === 0 && input.dy === 0)) {
             input.dx = input.dy = 0; // Still reset deltas
             return w;
        }

        // --- Process only the local player entity 'eid' ---
        const holder = w.ctx.maps.mesh.get(eid); // Get the Object3D holder
        if (!holder) return w;

        // --- Yaw (Horizontal Rotation) - Applied to the holder/RigidBody/Transform ---
        const yawAngle = -input.dx * PlayerConfig.MOUSE_SENSITIVITY;
        yawQuat.setFromAxisAngle(worldUp, yawAngle);

        // Get current rotation from Transform component
        currentRotation.set(Transform.qx[eid], Transform.qy[eid], Transform.qz[eid], Transform.qw[eid]);

        // Apply yaw to the current rotation
        currentRotation.multiplyQuaternions(yawQuat, currentRotation); // Yaw multiplies from the left for world Y rotation
        currentRotation.normalize();

        // Update Transform component with new rotation
        Transform.qx[eid] = currentRotation.x;
        Transform.qy[eid] = currentRotation.y;
        Transform.qz[eid] = currentRotation.z;
        Transform.qw[eid] = currentRotation.w;

         // Apply yaw rotation directly to the Object3D holder for immediate visual feedback
         // This might be slightly redundant if RenderSync handles it, but helps responsiveness.
         // Ensure holder.rotation is updated if RenderSync relies on it.
         // holder.quaternion.copy(currentRotation); // Or let RenderSync handle this from Transform

        // --- Pitch (Vertical Rotation) - Applied only to the camera ---
        const currentPitch = FPController.pitch[eid];
        let newPitch = currentPitch - input.dy * PlayerConfig.MOUSE_SENSITIVITY;
        newPitch = THREE.MathUtils.clamp(newPitch, -Math.PI / 2 * 0.99, Math.PI / 2 * 0.99); // Clamp pitch

        // Update pitch in FPController component
        FPController.pitch[eid] = newPitch;

        // Apply pitch directly to the camera object
        const camera = w.ctx.three.camera;
        if (camera) {
             // We rotate camera locally around its X axis
            pitchQuat.setFromAxisAngle(new THREE.Vector3(1, 0, 0), newPitch);
            camera.quaternion.copy(pitchQuat); // Set camera's local rotation
        }

        // Reset mouse deltas after processing
        input.dx = input.dy = 0;

        return w;
    };
}

================================================
File: /src/ecs/systems/player/movementSystem.ts
================================================
import { FPController, Transform } from '../../components';
import { ECS } from '../../world';
import { InputState } from '../input';
import { vec2Pool, vec3Pool } from '../../utils/mathUtils';
import { PlayerConfig, MovementState } from '../../config';
import * as THREE from 'three';

// Removed playerQuery, system now receives eid
// const playerQuery = defineQuery([LocalPlayer, RigidBodyRef, FPController]);

export function initPlayerMovementSystem(_world: ECS) {
  const dir = vec3Pool.get();
  const horiz = vec2Pool.get();
  let prevJump = false;

  // System now receives world and the specific local player eid
  return (w: ECS, eid: number) => {
    const input = w.input as InputState;
    if (!input) return w; // Should not happen if input system runs first

    const now = performance.now();

    // --- Process only the local player entity 'eid' ---
    const rb = w.ctx.maps.rb.get(eid);
    const kcc = w.ctx.kcc;
    const playerCollider = w.ctx.playerCollider;

    if (!rb || !kcc || !playerCollider) return w; // Skip if physics components not ready

    const holder = w.ctx.maps.mesh.get(eid); // Player's visual holder mesh
    if (!holder) return w;

    // Debugging: Log collider position relative to body
    const colliderPosition = playerCollider.translation();
    const rbPosition = rb.translation();
    const offset = { 
      x: colliderPosition.x - rbPosition.x,
      y: colliderPosition.y - rbPosition.y, 
      z: colliderPosition.z - rbPosition.z 
    };
    
    // If offset is unusually large, something's wrong - reset it
    if (Math.abs(offset.y) > 1) {
      console.warn(`Fixed collider-body offset, was: ${JSON.stringify(offset)}`);
      playerCollider.setTranslation(rbPosition);
    }

    // --- Movement state + gravity ---
    // Use KCC to check if grounded
    const grounded = kcc.computedGrounded();
    if (grounded) FPController.lastGrounded[eid] = now;

    // Set movement state based on grounded and vertical velocity
    if (grounded) {
      FPController.moveState[eid] = MovementState.GROUNDED;
    } else {
      FPController.moveState[eid] = FPController.vertVel[eid] > 0 ?
        MovementState.JUMPING : MovementState.FALLING;
    }

    // Jump buffering
    const jumpPressed = input.jump && !prevJump;
    if (jumpPressed && FPController.jumpRequested[eid] === 0) {
      FPController.jumpRequested[eid] = 1;
      FPController.lastJumpRequest[eid] = now;
    } else if (!input.jump) {
      FPController.jumpRequested[eid] = 0;
    }

    // Check if can jump using coyote time (grace period after leaving edge)
    const canJump = (grounded || now - FPController.lastGrounded[eid] < PlayerConfig.COYOTE_MS) &&
                    now - FPController.lastJump[eid] > PlayerConfig.JUMP_CD_MS;

    // Execute jump with buffering
    if (canJump && (jumpPressed || (now - FPController.lastJumpRequest[eid] < PlayerConfig.JUMP_BUFFER_MS))) {
      FPController.vertVel[eid] = PlayerConfig.JUMP_VEL;
      FPController.lastJump[eid] = now;
      FPController.jumpRequested[eid] = 0;
      console.log("JUMP EXECUTED!");
    }
    prevJump = input.jump;

    // Apply gravity or stick to ground
    if (FPController.moveState[eid] !== MovementState.GROUNDED) {
      FPController.vertVel[eid] = Math.max(
        FPController.vertVel[eid] - PlayerConfig.GRAVITY * w.time.dt,
        PlayerConfig.TERMINAL_FALL
      );
    } else {
      // Apply slight downward force when grounded to help stick to slopes
      FPController.vertVel[eid] = -2.0; // Small negative velocity when grounded
    }

    // --- Directional input ---
    dir.set(
      (input.rt ? 1 : 0) - (input.lf ? 1 : 0), // x: right - left
      0,                                        // y: always zero
      (input.bk ? 1 : 0) - (input.fw ? 1 : 0)  // z: backward - forward
    );

    if (dir.lengthSq() > 0) dir.normalize();

    // Apply player's current rotation (yaw) to the direction vector
    const playerRotation = new THREE.Quaternion(Transform.qx[eid], Transform.qy[eid], Transform.qz[eid], Transform.qw[eid]);
    dir.applyQuaternion(playerRotation);

    // Base speed with sprint and air control
    const speed = PlayerConfig.WALK_SPEED *
                  (FPController.moveState[eid] === MovementState.GROUNDED ? 1 : PlayerConfig.AIR_CONTROL) *
                  (input.sprint ? PlayerConfig.SPRINT_FACTOR : 1);

    horiz.set(dir.x * speed, dir.z * speed);

    // --- KCC integration ---
    const dt = w.time.dt; // Use variable dt for input responsiveness

    const desiredMovement = {
      x: horiz.x * dt,
      y: FPController.vertVel[eid] * dt,
      z: horiz.y * dt
    };

    // Debug logging for movement issues
    if (!isFinite(desiredMovement.x) || !isFinite(desiredMovement.y) || !isFinite(desiredMovement.z)) {
      console.error("Invalid movement values:", desiredMovement);
      desiredMovement.x = 0;
      desiredMovement.y = 0;
      desiredMovement.z = 0;
    }

    // Apply character controller movement
    kcc.computeColliderMovement(playerCollider, desiredMovement);
    const actualMovement = kcc.computedMovement();

    // Check for head collision
    if (FPController.vertVel[eid] > 0 && actualMovement.y < desiredMovement.y * 0.9) {
      FPController.vertVel[eid] = 0; // Hit ceiling
    }

    // Apply the computed movement to the rigid body for the next physics step
    const currentPos = rb.translation();
    
    // Ensure the collider moves with the rigid body
    rb.setNextKinematicTranslation({
      x: currentPos.x + actualMovement.x,
      y: currentPos.y + actualMovement.y,
      z: currentPos.z + actualMovement.z
    });

    // Update the Transform component immediately for network sync and rendering
    Transform.x[eid] = currentPos.x + actualMovement.x;
    Transform.y[eid] = currentPos.y + actualMovement.y;
    Transform.z[eid] = currentPos.z + actualMovement.z;

    // Check for ground state and update animation if needed
    // We'll apply animations in the animation system, but calculate the state here

    return w;
  };
}

================================================
File: /src/ecs/systems/player/shootSystem.ts
================================================
import { defineQuery, hasComponent, addEntity, addComponent } from 'bitecs';
import * as THREE from 'three';
import { LocalPlayer, FPController, Transform, Projectile, Lifespan, MeshRef, Velocity, RigidBodyRef } from '../../components'; // Import required components
import { ECS } from '../../world';
import { InputState } from '../input';
import { network } from '../network/client'; // Import network client
import { WeaponConfig } from '../../config';
import { vec3Pool } from '../../utils/mathUtils'; // Keep for direction calculation

// Removed playerQuery, system now receives eid
// const playerQuery = defineQuery([LocalPlayer, FPController]);

// Server now dictates shoot cooldown, but we keep local tracking for client-side feedback
let prevShoot = false;
let lastShotTime = 0; // Client-side visual feedback delay

export function initPlayerShootSystem(_world: ECS) {

    // System now receives world and the specific local player eid
    return (w: ECS, eid: number) => {
        const input = w.input as InputState;
        if (!input) return w;

        const now = performance.now();

        // --- Process only the local player entity 'eid' ---
        const shootStart = input.shoot && !prevShoot;

        // Simple client-side cooldown visual feedback (optional, server is authoritative)
        const clientSideCooldown = 200; // ms, match WeaponConfig? Or make slightly shorter
        if (shootStart && now - lastShotTime > clientSideCooldown) {
             // Get camera for shoot direction
            const camera = w.ctx.three.camera;
            if (!camera) return w; // Should not happen

            // Get direction and spawn position
            const dir = vec3Pool.get();
            const spawnPos = vec3Pool.get();

            camera.getWorldDirection(dir).normalize();
            // Spawn slightly in front of camera, aligned with view
            camera.getWorldPosition(spawnPos).addScaledVector(dir, WeaponConfig.BULLET_SPAWN_DISTANCE);

            console.log(`Local player ${w.ctx.localPlayerId} shooting.`);
            
            // Send shoot message to the server - important for multiplayer sync
            network.send({
                type: 'shoot',
                position: { x: spawnPos.x, y: spawnPos.y, z: spawnPos.z },
                direction: { x: dir.x, y: dir.y, z: dir.z }
            });

            // Create a physics-based projectile for proper world interaction
            const projectileEid = createPhysicsProjectile(w, spawnPos, dir);

            lastShotTime = now; // Update client-side timer

            vec3Pool.release(dir);
            vec3Pool.release(spawnPos);
        }

        prevShoot = input.shoot;

        return w;
    };
}

/**
 * Creates a physics-based projectile with both visual representation and rigid body physics
 * @param world - ECS world instance
 * @param position - Starting position vector
 * @param direction - Direction vector (should be normalized)
 * @returns Entity ID of the created projectile
 */
function createPhysicsProjectile(world: ECS, position: THREE.Vector3, direction: THREE.Vector3): number {
    const { rapier, physics, maps, three } = world.ctx;
    
    // Create projectile entity
    const eid = addEntity(world);
    addComponent(world, Projectile, eid);
    addComponent(world, Lifespan, eid);
    addComponent(world, MeshRef, eid);
    addComponent(world, RigidBodyRef, eid);
    addComponent(world, Transform, eid);
    addComponent(world, Velocity, eid);
    
    // Setup lifespan
    Lifespan.ttl[eid] = WeaponConfig.BULLET_TTL_MS;
    Lifespan.born[eid] = performance.now();
    
    // Setup transform
    Transform.x[eid] = position.x;
    Transform.y[eid] = position.y;
    Transform.z[eid] = position.z;
    Transform.qx[eid] = 0; Transform.qy[eid] = 0; Transform.qz[eid] = 0; Transform.qw[eid] = 1;
    
    // Setup velocity
    Velocity.x[eid] = direction.x * WeaponConfig.BULLET_SPEED;
    Velocity.y[eid] = direction.y * WeaponConfig.BULLET_SPEED;
    Velocity.z[eid] = direction.z * WeaponConfig.BULLET_SPEED;
    
    // Create visual mesh
    const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 8, 8),
        new THREE.MeshStandardMaterial({ 
            color: 0xff4400,
            emissive: 0xff2200,
            emissiveIntensity: 0.4,
            roughness: 0.3,
            metalness: 0.7
        })
    );
    mesh.castShadow = true;
    mesh.position.copy(position);
    three.scene.add(mesh);
    maps.mesh.set(eid, mesh);
    
    // Create physics rigid body with CCD enabled to prevent tunneling
    const rb = physics.createRigidBody(
        rapier.RigidBodyDesc.dynamic()
            .setTranslation(position.x, position.y, position.z)
            .setCcdEnabled(true) // Critical for fast projectiles to prevent tunneling
            .setLinvel(direction.x * WeaponConfig.BULLET_SPEED, 
                      direction.y * WeaponConfig.BULLET_SPEED, 
                      direction.z * WeaponConfig.BULLET_SPEED)
    );
    
    // Create bullet collider
    physics.createCollider(
        rapier.ColliderDesc.ball(0.08) // Match visual size
            .setDensity(2.0)
            .setFriction(0.0)
            .setRestitution(0.4), // Bounce off surfaces slightly
        rb
    );
    
    // Store rigid body and update entity-handle mapping
    maps.rb.set(eid, rb);
    RigidBodyRef.id[eid] = rb.handle;
    
    // Update entity handle map for collision detection
    if (world.ctx.entityHandleMap) {
        world.ctx.entityHandleMap.set(rb.handle, eid);
    } else {
        world.ctx.entityHandleMap = new Map<number, number>();
        world.ctx.entityHandleMap.set(rb.handle, eid);
    }
    
    return eid;
}

/** 
 * Creates a visual-only projectile for remote player shots
 * Used by network system when receiving shot events from other players
 */
export function createVisualProjectile(world: ECS, position: THREE.Vector3, direction: THREE.Vector3, color = 0x00aaff): number {
    const eid = addEntity(world);
    addComponent(world, Projectile, eid);
    addComponent(world, Lifespan, eid);
    addComponent(world, MeshRef, eid);
    addComponent(world, Transform, eid);
    addComponent(world, Velocity, eid);
    
    Lifespan.ttl[eid] = WeaponConfig.BULLET_TTL_MS;
    Lifespan.born[eid] = performance.now();
    
    Transform.x[eid] = position.x;
    Transform.y[eid] = position.y;
    Transform.z[eid] = position.z;
    Transform.qx[eid] = 0; Transform.qy[eid] = 0; Transform.qz[eid] = 0; Transform.qw[eid] = 1;
    
    Velocity.x[eid] = direction.x * WeaponConfig.BULLET_SPEED;
    Velocity.y[eid] = direction.y * WeaponConfig.BULLET_SPEED;
    Velocity.z[eid] = direction.z * WeaponConfig.BULLET_SPEED;
    
    const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 8, 8),
        new THREE.MeshBasicMaterial({ color })
    );
    mesh.position.copy(position);
    world.ctx.three.scene.add(mesh);
    world.ctx.maps.mesh.set(eid, mesh);
    
    return eid;
}

================================================
File: /src/ecs/systems/projectile.ts
================================================
import { defineQuery, hasComponent, removeEntity } from 'bitecs';
import { Lifespan, Projectile, Velocity, Transform, MeshRef, RigidBodyRef } from '../components';
import { ECS } from '../world';
import * as THREE from 'three';

export function initProjectileSystem(_world: ECS) {
  // Query for all projectiles, whether physics-based or visual-only
  const projectileQuery = defineQuery([Projectile, Lifespan]);
  
  // Separate query for visual-only projectiles (those without RigidBody)
  const visualProjectileQuery = defineQuery([Projectile, Lifespan, Velocity, Transform, MeshRef]);
  const physicsProjectileQuery = defineQuery([Projectile, Lifespan, RigidBodyRef]);

  return (w: ECS) => {
    const now = performance.now();
    const delta = w.time.dt; // Use world delta time

    const entitiesToRemove: number[] = [];

    // First update visual-only projectiles with simple kinematic movement
    for (const eid of visualProjectileQuery(w)) {
      // Skip if entity already has a RigidBody (will be handled by physics system)
      if (hasComponent(w, RigidBodyRef, eid)) continue;
      
      // --- Simple Kinematic Movement ---
      Transform.x[eid] += Velocity.x[eid] * delta;
      Transform.y[eid] += Velocity.y[eid] * delta;
      Transform.z[eid] += Velocity.z[eid] * delta;

      // Sync mesh position with Transform
      const mesh = w.ctx.maps.mesh.get(eid);
      if (mesh) {
        mesh.position.set(Transform.x[eid], Transform.y[eid], Transform.z[eid]);
      }
    }

    // Check all projectiles for lifespan and deletion flags
    for (const eid of projectileQuery(w)) {
      // --- Check Lifespan ---
      if (now - Lifespan.born[eid] > Lifespan.ttl[eid]) {
        entitiesToRemove.push(eid);
        continue;
      }

      // --- Check for Deletion Flag (from collision detection) ---
      const mesh = w.ctx.maps.mesh.get(eid);
      if (mesh?.userData?.markedForDeletion === true) {
        if (!entitiesToRemove.includes(eid)) { // Avoid duplicates
          entitiesToRemove.push(eid);
        }
      }
    }

    // --- Remove Entities ---
    for (const eid of entitiesToRemove) {
      // Get and remove the mesh
      const mesh = w.ctx.maps.mesh.get(eid);
      if (mesh) {
        w.ctx.three.scene.remove(mesh);
        if (mesh instanceof THREE.Mesh) {
          mesh.geometry?.dispose();
          if (mesh.material) {
            if (Array.isArray(mesh.material)) {
              mesh.material.forEach(material => material?.dispose());
            } else {
              mesh.material.dispose();
            }
          }
        }
        w.ctx.maps.mesh.delete(eid);
      }

      // Remove Rapier body if it exists
      const rb = w.ctx.maps.rb.get(eid);
      if (rb) {
        w.ctx.physics.removeRigidBody(rb);
        w.ctx.maps.rb.delete(eid);
        
        // Also remove from entity handle map if it exists
        if (w.ctx.entityHandleMap) {
          // Search for this entity's handle
          for (const [handle, entityId] of w.ctx.entityHandleMap.entries()) {
            if (entityId === eid) {
              w.ctx.entityHandleMap.delete(handle);
              break;
            }
          }
        }
      }

      // Remove the entity if it still exists
      if (hasComponent(w, Projectile, eid)) {
        removeEntity(w, eid);
      }
    }

    return w;
  };
}

================================================
File: /src/ecs/systems/renderSync.ts
================================================
import { defineQuery, hasComponent, exitQuery } from 'bitecs';
import { ECS } from '../world';
import {
  MeshRef, RigidBodyRef, Transform, LocalPlayer, RemotePlayer, InterpolationTarget // Added RemotePlayer, InterpolationTarget
} from '../components';
import { vec3Pool, quatPool, interpolatePositions, interpolateRotations } from '../utils/mathUtils';
import * as THREE from 'three'; // Import THREE

export function initRenderSyncSystem(_world: ECS) {
    const localPlayerQuery = defineQuery([LocalPlayer, MeshRef, RigidBodyRef]);
    const remotePlayerQuery = defineQuery([RemotePlayer, MeshRef, InterpolationTarget, Transform]); // Remote players use InterpolationTarget & Transform
    const otherRbQuery = defineQuery([MeshRef, RigidBodyRef]); // Query for non-player rigid bodies
    const allMeshQuery = defineQuery([MeshRef]); // For cleanup

    const exitMeshQuery = exitQuery(allMeshQuery);

    // Storage for interpolation - keyed by Entity ID
    const interpolationData = new Map<number, {
        prevPos: THREE.Vector3;
        prevRot: THREE.Quaternion;
        prevTimestamp: number;
    }>();

    // Reusable THREE objects
    const currentPos = new THREE.Vector3();
    const currentRot = new THREE.Quaternion();
    const targetPos = new THREE.Vector3();
    const targetRot = new THREE.Quaternion();


    return (w: ECS) => {
        const now = Date.now(); // Current render time

        // --- Cleanup exited entities ---
        for (const eid of exitMeshQuery(w)) {
            interpolationData.delete(eid);
            // Note: Mesh and RB removal is handled elsewhere (e.g., projectileSystem, networkSystem)
        }

        // --- Sync Local Player ---
        // Local player's visual mesh should follow the *kinematic* rigid body
        const localPlayers = localPlayerQuery(w);
        if (localPlayers.length > 0) {
            const eid = localPlayers[0];
            const mesh = w.ctx.maps.mesh.get(eid)!;
            const rb = w.ctx.maps.rb.get(eid);
            if (mesh && rb) {
                 // Get the *current* (potentially interpolated by Rapier) kinematic position
                 const p = rb.translation();
                 // Rotation comes from the Transform component updated by look system
                 const r = { x: Transform.qx[eid], y: Transform.qy[eid], z: Transform.qz[eid], w: Transform.qw[eid] };

                 mesh.position.set(p.x, p.y, p.z);
                 mesh.quaternion.set(r.x, r.y, r.z, r.w);
            }
        }


        // --- Sync and Interpolate Remote Players ---
        const remoteEntities = remotePlayerQuery(w);
        for (const eid of remoteEntities) {
            const mesh = w.ctx.maps.mesh.get(eid)!;
            if (!mesh) continue;

            // Get target state from InterpolationTarget component
            targetPos.set(InterpolationTarget.targetX[eid], InterpolationTarget.targetY[eid], InterpolationTarget.targetZ[eid]);
            targetRot.set(InterpolationTarget.targetQX[eid], InterpolationTarget.targetQY[eid], InterpolationTarget.targetQZ[eid], InterpolationTarget.targetQW[eid]);
            const targetTimestamp = InterpolationTarget.timestamp[eid];

             // Get current state from Transform component (this is the *visual* state)
             currentPos.set(Transform.x[eid], Transform.y[eid], Transform.z[eid]);
             currentRot.set(Transform.qx[eid], Transform.qy[eid], Transform.qz[eid], Transform.qw[eid]);


            // Simple Lerp for now - replace with time-based interpolation later
            const lerpFactor = 0.2; // Adjust for smoothness
            currentPos.lerp(targetPos, lerpFactor);
            currentRot.slerp(targetRot, lerpFactor);


            // Update the Transform component with the interpolated visual state
            Transform.x[eid] = currentPos.x;
            Transform.y[eid] = currentPos.y;
            Transform.z[eid] = currentPos.z;
            Transform.qx[eid] = currentRot.x;
            Transform.qy[eid] = currentRot.y;
            Transform.qz[eid] = currentRot.z;
            Transform.qw[eid] = currentRot.w;

            // Apply interpolated state to the mesh
            mesh.position.copy(currentPos);
            mesh.quaternion.copy(currentRot);

             // Update animation mixer if it exists on the mesh
             const animData = mesh.userData; // Assuming mixer is stored in userData
             if (animData?.mixer) {
                 animData.mixer.update(w.time.dt);
             }
        }


        // --- Sync Other Rigid Bodies (Cubes, etc.) ---
        const otherRbEntities = otherRbQuery(w);
        for (const eid of otherRbEntities) {
            // Skip if it's a player (handled above)
            if (hasComponent(w, LocalPlayer, eid) || hasComponent(w, RemotePlayer, eid)) continue;

            const mesh = w.ctx.maps.mesh.get(eid)!;
            const rb = w.ctx.maps.rb.get(eid);
            if (!mesh || !rb) continue;

             // Read directly from Rapier body for dynamic objects
             const p = rb.translation();
             const r = rb.rotation();

             // Apply directly to mesh (or use interpolation if desired)
             mesh.position.set(p.x, p.y, p.z);
             mesh.quaternion.set(r.x, r.y, r.z, r.w);

             // Update Transform component for consistency (optional for non-player RB)
             Transform.x[eid] = p.x; Transform.y[eid] = p.y; Transform.z[eid] = p.z;
             Transform.qx[eid] = r.x; Transform.qy[eid] = r.y; Transform.qz[eid] = r.z; Transform.qw[eid] = r.w;
        }

        // --- Update Transform for non-RB Meshes (if any) ---
         // This part remains the same as before, handling meshes without RBs
         for (const eid of allMeshQuery(w)) {
             if (hasComponent(w, RigidBodyRef, eid) || hasComponent(w, LocalPlayer, eid) || hasComponent(w, RemotePlayer, eid)) continue;

             const mesh = w.ctx.maps.mesh.get(eid)!;
             if (!mesh) continue;

             mesh.getWorldPosition(currentPos);
             mesh.getWorldQuaternion(currentRot);

             Transform.x[eid] = currentPos.x; Transform.y[eid] = currentPos.y; Transform.z[eid] = currentPos.z;
             Transform.qx[eid] = currentRot.x; Transform.qy[eid] = currentRot.y; Transform.qz[eid] = currentRot.z; Transform.qw[eid] = currentRot.w;
         }


        return w;
    };
}

================================================
File: /src/ecs/systems/timeStep.ts
================================================
/**
 * Time step system that manages fixed time steps for physics
 */
import { ECS } from '../world';
import { updateFixedTimestep } from '../timeUtils';
import { TimeStepConfig } from '../config';

// Fixed timestep configuration constants are now directly imported from TimeStepConfig

export function initTimeStepSystem(_world: ECS) {
  return (w: ECS) => {
    // Calculate delta time in seconds
    const now = performance.now();
    // Use a minimum delta time to prevent tiny stutters during fast displays
    const dt = Math.max(TimeStepConfig.MIN_DT, (now - w.time.then) * 0.001); // Convert ms to seconds
    w.time.then = now;
    w.time.dt = dt;
    
    // Update fixed timestep values
    updateFixedTimestep(w, dt);
    
    return w;
  };
} 

================================================
File: /src/ecs/timeUtils.ts
================================================
/**
 * Time utilities for managing fixed timestep and frame timing
 */
import { ECS } from './world';
import { TimeStepConfig } from './config';

/**
 * Update time accumulator and calculate physics steps
 */
export function updateFixedTimestep(world: ECS, deltaTime: number): void {
  // Cap deltaTime to prevent jumps after pauses/tab switches
  const dt = Math.min(deltaTime, TimeStepConfig.MAX_FRAME_TIME);
  
  // Add to accumulator
  world.time.accumulator += dt;
  
  // Calculate how many physics steps to take
  const steps = Math.floor(world.time.accumulator / TimeStepConfig.FIXED_DT);
  const clampedSteps = Math.min(steps, TimeStepConfig.MAX_STEPS);
  
  // Store in world time
  world.time.shouldRunPhysics = clampedSteps > 0;
  world.time.physicsSteps = clampedSteps;
  world.time.fixedDt = TimeStepConfig.FIXED_DT;
  
  // Calculate interpolation alpha
  if (steps > 0) {
    world.time.accumulator -= clampedSteps * TimeStepConfig.FIXED_DT;
    world.time.alpha = world.time.accumulator / TimeStepConfig.FIXED_DT;
  } else {
    world.time.alpha = 0;
  }
} 

================================================
File: /src/ecs/utils/eventUtils.ts
================================================
/**
 * Event utility functions for proper listener management
 */

// Track attached listeners for cleanup
const attachedListeners: Array<{
  target: EventTarget;
  type: string;
  listener: EventListenerOrEventListenerObject;
  options?: boolean | AddEventListenerOptions;
}> = [];

/**
 * Safely attach an event listener with tracking for easy cleanup
 * @param target The EventTarget to attach to (window, document, etc.)
 * @param type Event type (click, keydown, etc.)
 * @param listener The event listener function
 * @param options Optional addEventListener options
 */
export function safeAddEventListener(
  target: EventTarget,
  type: string,
  listener: EventListenerOrEventListenerObject,
  options?: boolean | AddEventListenerOptions
): void {
  target.addEventListener(type, listener, options);
  attachedListeners.push({ target, type, listener, options });
}

/**
 * Remove all previously attached event listeners
 */
export function removeAllEventListeners(): void {
  for (const { target, type, listener, options } of attachedListeners) {
    target.removeEventListener(type, listener, options);
  }
  attachedListeners.length = 0;
}

/**
 * Setup handlers to clean up event listeners on page unload
 */
export function setupEventCleanup(): void {
  // Only set up once
  if ((window as any).__eventCleanupInitialized) return;
  
  window.addEventListener('beforeunload', removeAllEventListeners);
  (window as any).__eventCleanupInitialized = true;
} 

================================================
File: /src/ecs/utils/mathUtils.ts
================================================
/**
 * Math utilities including vector/quaternion pooling
 */
import * as THREE from 'three';

// Default pool size configuration
export const ObjectPoolConfig = {
  INITIAL_SIZE: 20  // Reduced from 50 to conserve memory
};

// A simple vector/quaternion pool to avoid allocations
class ObjectPool<T> {
  private pool: T[] = [];
  private createFn: () => T;
  private resetFn: (obj: T) => void;
  
  constructor(createFn: () => T, resetFn: (obj: T) => void, initialSize = ObjectPoolConfig.INITIAL_SIZE) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    
    // Pre-allocate initial pool
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn());
    }
  }
  
  get(): T {
    if (this.pool.length === 0) {
      return this.createFn();
    }
    return this.pool.pop()!;
  }
  
  release(obj: T): void {
    this.resetFn(obj);
    this.pool.push(obj);
  }
}

// Vector3 pool
export const vec3Pool = new ObjectPool<THREE.Vector3>(
  () => new THREE.Vector3(),
  (v) => v.set(0, 0, 0)
);

// Quaternion pool
export const quatPool = new ObjectPool<THREE.Quaternion>(
  () => new THREE.Quaternion(),
  (q) => q.set(0, 0, 0, 1)
);

// Euler pool
export const eulerPool = new ObjectPool<THREE.Euler>(
  () => new THREE.Euler(),
  (e) => e.set(0, 0, 0)
);

// Vector2 pool
export const vec2Pool = new ObjectPool<THREE.Vector2>(
  () => new THREE.Vector2(),
  (v) => v.set(0, 0)
);

// Interpolation helpers
export function interpolatePositions(
  dest: THREE.Vector3,
  prev: THREE.Vector3, 
  current: THREE.Vector3, 
  alpha: number
): THREE.Vector3 {
  return dest.lerpVectors(prev, current, alpha);
}

export function interpolateRotations(
  dest: THREE.Quaternion,
  prev: THREE.Quaternion, 
  current: THREE.Quaternion, 
  alpha: number
): THREE.Quaternion {
  return dest.slerpQuaternions(prev, current, alpha);
}

// Convert numeric tuple to BigInt64 for use as map key
export function createEntityPairKey(a: number, b: number): bigint {
  // Ensure a < b to make the key consistent regardless of order
  if (a > b) [a, b] = [b, a];
  
  // Convert to BigInt and combine into single 64-bit value
  // This allows for efficient storage without string conversions
  return (BigInt(a) << 32n) | BigInt(b & 0xFFFFFFFF);
}

/**
 * Get direction vector from one point to another
 * @param fromPos Starting position
 * @param toPos Target position
 * @param outVec Optional output vector (if not provided, one will be pooled)
 * @returns Normalized direction vector (caller must vec3Pool.release(outVec) when done)
 */
export function directionFromTo(
  fromPos: { x: number, y: number, z: number },
  toPos: { x: number, y: number, z: number },
  outVec = vec3Pool.get()
): THREE.Vector3 {
  return outVec.set(
    toPos.x - fromPos.x,
    toPos.y - fromPos.y,
    toPos.z - fromPos.z
  ).normalize();
} 

================================================
File: /src/ecs/world.ts
================================================
import { createWorld, pipe, IWorld } from 'bitecs';
import { initInputSystem, InputState } from './systems/input';
import { initPlayerSystem }    from './systems/player';
import { initProjectileSystem }from './systems/projectile';
import { initPhysicsSystem }   from './systems/physics';
import { initRenderSyncSystem }from './systems/renderSync';
import { initDebugVisSystem }  from './systems/debugVis';
import { initCollisionSystem } from './systems/collision';
import { initTimeStepSystem }  from './systems/timeStep';
import { initGrassSystem }     from './systems/grass';
import { initNetworkSystem, NetworkState } from './systems/network/client'; // Import network system
import { initHealthSystem } from './systems/healthSystem'; // Import health system
import * as THREE from 'three';
import type * as RAPIER from '@dimforge/rapier3d-compat';

export function createECS(ctx: ECSContext) {
  const world = createWorld() as ECS;
  world.ctx  = ctx;
  world.time = {
    dt: 0,
    then: performance.now(),
    accumulator: 0
  };
  world.network = { // Initialize network state
      connected: false,
      connecting: false,
      socket: null,
      messageQueue: [],
      pendingUpdates: new Map(),
      lastSentTime: 0,
      lastPingTime: 0
  };
  world.players = new Map(); // Map NetworkId -> EntityId

  // Create Rapier event queue if not already done in scene context creation
  if (!ctx.eventQueue) {
    ctx.eventQueue = new ctx.rapier.EventQueue(true);
  }

  const pipeline = pipe(
    initTimeStepSystem(world),
    initInputSystem(world),
    initNetworkSystem(world),   // Network system runs early to process incoming messages
    initPlayerSystem(world),
    initPhysicsSystem(world),
    initCollisionSystem(world), // Keep for non-player collisions (e.g., projectile-cube)
    initProjectileSystem(world),// Manages visual lifetime of local/remote projectiles
    initHealthSystem(world),    // Handles health updates and death/respawn events
    initGrassSystem(world),
    initDebugVisSystem(world),
    initRenderSyncSystem(world) // Render sync runs last
  );

  return { world, pipeline };
}

/* Types shared with scene & systems */
export interface ECSContext {
  rapier: typeof RAPIER;
  physics: RAPIER.World;
  three: {
    scene: THREE.Scene;
    camera: THREE.Camera;
    renderer: THREE.WebGLRenderer;
  };
  maps: {
    rb: Map<number, RAPIER.RigidBody>; // EntityId -> RigidBody
    mesh: Map<number, THREE.Object3D>; // EntityId -> Mesh
  };
  eventQueue?: RAPIER.EventQueue;
  kcc?: RAPIER.KinematicCharacterController;
  playerCollider?: RAPIER.Collider;
  entityHandleMap?: Map<number, number>; // RB Handle -> EntityId
  localPlayerId: number | null; // Added to store the local player's network ID
}

// Extend IWorld with our custom properties
export interface ECS extends IWorld {
  ctx: ECSContext;
  time: {
    dt: number;
    then: number;
    accumulator: number;
    fixedDt?: number;
    alpha?: number;
    physicsSteps?: number;
    shouldRunPhysics?: boolean;
    prevPlayerPos?: THREE.Vector3;
  };
  input?: InputState;
  network: NetworkState; // Add network state object
  players: Map<number, number>; // Add map for NetworkId -> EntityId mapping
}

================================================
File: /src/gameloop.ts
================================================
/**
 * Game loop module for managing main animation loop
 */
import Stats from 'three/examples/jsm/libs/stats.module.js';
import { ECS } from './ecs/world';

/**
 * Set up stats.js performance monitor
 */
export function setupStats(): Stats {
  const stats = new Stats();
  stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
  stats.dom.style.position = 'absolute';
  stats.dom.style.left = '0px';
  stats.dom.style.top = '0px';
  document.body.appendChild(stats.dom);
  return stats;
}

/**
 * Start the game loop
 */
export function startGameLoop(world: ECS, pipeline: (w: ECS) => ECS): void {
  const stats = setupStats();
  
  // Start animation loop
  const raf = (_t: number) => {
    // Begin stats measurement
    stats.begin();
    
    // Run all systems
    pipeline(world);
    
    // Render the scene
    world.ctx.three.renderer.render(world.ctx.three.scene, world.ctx.three.camera);
    
    // End stats measurement
    stats.end();
    
    // Request next frame
    requestAnimationFrame(raf);
  };
  
  // Start the loop
  requestAnimationFrame(raf);
} 

================================================
File: /src/main.ts
================================================
import * as RAPIER from '@dimforge/rapier3d-compat';
import { createContext, populateScene } from './ecs/scene';
import { createECS } from './ecs/world';
import { startGameLoop } from './gameloop';
import { network } from './ecs/systems/network/client'; // Import network client

const canvas = document.getElementById('c') as HTMLCanvasElement;

async function main() {
  console.log("Initializing Rapier...");
  await RAPIER.init();
  console.log("Rapier initialized.");

  console.log("Creating context...");
  const ctx = await createContext(canvas, RAPIER);
  console.log("Context created.");

  console.log("Creating ECS...");
  const { world, pipeline } = createECS(ctx);
  console.log("ECS created.");

  console.log("Populating scene...");
  populateScene(world, ctx);
  console.log("Scene populated.");

  console.log("Connecting to network...");
  await network.connect(world); // Connect the network client, passing the world
  console.log("Network connection initiated.");

  console.log("Starting game loop...");
  startGameLoop(world, pipeline);
  console.log("Game loop started.");
}

main().catch(error => {
    console.error("Initialization failed:", error);
    // Display a user-friendly error message on the page
    const errorDiv = document.createElement('div');
    errorDiv.style.position = 'fixed';
    errorDiv.style.top = '0';
    errorDiv.style.left = '0';
    errorDiv.style.width = '100%';
    errorDiv.style.padding = '20px';
    errorDiv.style.backgroundColor = 'red';
    errorDiv.style.color = 'white';
    errorDiv.style.textAlign = 'center';
    errorDiv.style.zIndex = '10000';
    errorDiv.textContent = `Fatal Error: Failed to initialize the game. Please check the console for details and try refreshing. Error: ${error.message}`;
    document.body.appendChild(errorDiv);
});

================================================
File: /tsconfig.json
================================================
{
    "compilerOptions": {
      "target": "ES2020",
      "module": "ESNext",
      "lib": ["ES2020", "DOM"],
      "moduleResolution": "Bundler",
      "strict": true,
      "noImplicitReturns": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "skipLibCheck": true,
      "allowImportingTsExtensions": true,
      "noEmit": true,
      "types": ["vite/client"]
    },
    "include": ["src"]
  }
  

================================================
File: /vite.config.ts
================================================
import { defineConfig } from 'vite';
import wasm from 'vite-plugin-wasm';
import topLevelAwait from 'vite-plugin-top-level-await';

export default defineConfig({
  plugins: [wasm(), topLevelAwait()],
  build: { target: 'esnext' },
  server: { host: true }
});
    </codebase>
</context>
