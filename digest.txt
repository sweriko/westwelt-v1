<goal>
 The following codebase is my current new starter project for a high performant three/rapier shooter game, I want you to integrate multiplayer functionality as a proper solid basis to continue working from.
 I have also attached the codebase from a different multiplayer three/cannon fps game I built, use that as some guidance/reference, It should show you how to make multiplayer work.
 Please provide me every file that I need to change in my new game project in full length, including ofcourse any new file I need to add.
 (follow an ecs/oop hybrid architecture, basic player health system and rapier sensor colliders for bullet hit detection, websocket server with proper player and world updates, animation/playermodel broadcasting etc.)
</goal>

<output_requirements>
- Don't be lazy, provide thorough, high-quality code.
- Provide complete file contents for any modified or new files.
- Write clean, well-documented code with appropriate error handling.
- Never use ellipsis (...) or placeholder comments, as an excuse to omit code for brewity.
</output_requirements>

<context>
    <codebase>
Directory structure:
└── /./
    ├── index.html
    ├── package.json
    ├── public/
    │   ├── models/
    │   │   └── playermodel.glb
    │   └── textures/
    ├── src/
    │   ├── ecs/
    │   │   ├── components/
    │   │   ├── components.ts
    │   │   ├── config.ts
    │   │   ├── scene.ts
    │   │   ├── systems/
    │   │   │   ├── collision.ts
    │   │   │   ├── debugVis.ts
    │   │   │   ├── grass.ts
    │   │   │   ├── input.ts
    │   │   │   ├── network/
    │   │   │   ├── physics.ts
    │   │   │   ├── player/
    │   │   │   │   ├── animationSystem.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── lookSystem.ts
    │   │   │   │   ├── movementSystem.ts
    │   │   │   │   └── shootSystem.ts
    │   │   │   ├── projectile.ts
    │   │   │   ├── renderSync.ts
    │   │   │   └── timeStep.ts
    │   │   ├── timeUtils.ts
    │   │   ├── utils/
    │   │   │   ├── eventUtils.ts
    │   │   │   └── mathUtils.ts
    │   │   └── world.ts
    │   ├── gameloop.ts
    │   └── main.ts
    ├── tsconfig.json
    └── vite.config.ts

================================================
File: /index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Rapier × Three × bitecs starter</title>
  <style>html,body{margin:0;height:100%;overflow:hidden}</style>
</head>
<body>
  <canvas id="c"></canvas>
  <script type="module" src="/src/main.ts"></script>
</body>
</html>


================================================
File: /package.json
================================================
{
  "name": "rapier-three-bitecs-starter",
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@dimforge/rapier3d-compat": "^0.16.1",
    "bitecs": "^0.3.40",
    "three": "^0.176.0"
  },
  "devDependencies": {
    "@types/three": "^0.158.0",
    "typescript": "^5.2.2",
    "vite": "^6.3.1",
    "vite-plugin-top-level-await": "^1.5.0",
    "vite-plugin-wasm": "^3.4.1"
  }
}


================================================
File: /src/ecs/components.ts
================================================
import { Types, defineComponent } from 'bitecs';

/** World-space transform (quat-pos) */
export const Transform = defineComponent({
  x: Types.f32, y: Types.f32, z: Types.f32,
  qx: Types.f32, qy: Types.f32, qz: Types.f32, qw: Types.f32
});

/** Linear velocity – used for projectiles */
export const Velocity = defineComponent({ x: Types.f32, y: Types.f32, z: Types.f32 });

/** TTL in milliseconds (bullets) */
export const Lifespan = defineComponent({ ttl: Types.f32, born: Types.f32 });

/** Debug visualization flag - used to store current debug state */
export const DebugVis = defineComponent({ active: Types.ui8 });

/** First-person controller state */
export const FPController = defineComponent({
  pitch: Types.f32,        // Camera pitch angle
  vertVel: Types.f32,      // Vertical velocity
  moveState: Types.ui8,    // 0=Grounded, 1=Jumping, 2=Falling
  lastGrounded: Types.f32, // Time when last grounded
  lastJump: Types.f32,     // Time when last jumped
  lastShot: Types.f32,     // Time when last shot
  jumpRequested: Types.ui8,// Jump buffer flag
  lastJumpRequest: Types.f32 // Time when jump was requested
});

/** Debug visualization mesh references */
export const DebugMeshRef = defineComponent({ id: Types.ui32 });

/** Trajectory for debug visualization */
export const Trajectory = defineComponent({
  // No data needed, just a tag to indicate an entity has a trajectory
});

/** Collision event data */
export const CollisionEvent = defineComponent({
  entity1: Types.ui32,     // First entity in collision
  entity2: Types.ui32,     // Second entity in collision
  impulse: Types.f32,      // Collision impulse magnitude
  time: Types.f32          // When collision occurred
});

/** Tags */
export const Player   = defineComponent();
export const Projectile = defineComponent();
export const CubeTag  = defineComponent();

/** Foreign-object indirection – store handles in JS Maps */
export const RigidBodyRef = defineComponent({ id: Types.ui32 });
export const MeshRef      = defineComponent({ id: Types.ui32 });


================================================
File: /src/ecs/config.ts
================================================
/**
 * Global configuration values
 */

export const PlayerConfig = {
  // Movement
  WALK_SPEED: 8,
  SPRINT_FACTOR: 1.8,
  AIR_CONTROL: 0.7,
  JUMP_VEL: 14,
  GRAVITY: 20,
  TERMINAL_FALL: -20,
  
  // Timing
  JUMP_CD_MS: 300,
  COYOTE_MS: 150,
  JUMP_BUFFER_MS: 200,
  
  // Look
  MOUSE_SENSITIVITY: 0.0035
};

export const WeaponConfig = {
  SHOOT_CD_MS: 200,
  BULLET_SPEED: 40,
  BULLET_TTL_MS: 5000,
  BULLET_SPAWN_DISTANCE: 1.5
};

export const PhysicsConfig = {
  IMPACT_FORCE: 20.0,
  SOLVER_ITERATIONS: 4,     // More iterations for better stability
  CCD_SUBSTEPS: 4,          // Increase CCD substeps for better bullet collisions
  VELOCITY_THRESHOLD: 30.0  // Velocity magnitude threshold for enabling CCD
};

export const TimeStepConfig = {
  FIXED_DT: 1/60,          // 60Hz physics update
  MAX_STEPS: 5,            // Max physics steps per frame to prevent spiral of death
  MAX_FRAME_TIME: 0.25,    // Maximum time to spend catching up
  MIN_DT: 1/240            // Minimum sensible delta (240Hz)
};

export const SceneConfig = {
  // Ground
  GROUND_COLOR: 0x1a5f2a,
  GROUND_SIZE: 200,
  
  // Sky
  SKY_COLOR: 0x87CEEB,
  
  // Cubes
  CUBE_STACK_SIZE: 6,
  EXTRA_CUBES: 20,
  CUBE_RESTITUTION: 0.4,
  CUBE_FRICTION: 0.5,
  
  // Lighting
  AMBIENT_LIGHT_INTENSITY: 0.8,
  DIRECTIONAL_LIGHT_INTENSITY: 1.0
};

// Movement state enum values
export const MovementState = {
  GROUNDED: 0,
  JUMPING: 1,
  FALLING: 2
}; 

================================================
File: /src/ecs/scene.ts
================================================
/**********************************************************************
 * scene.ts – Three + Rapier initialisation & scene population
 *********************************************************************/
import * as THREE  from 'three';
import { addComponent, addEntity } from 'bitecs';
import {
  CubeTag, MeshRef, RigidBodyRef, Transform
} from './components';
import { ECS, ECSContext } from './world';
import { SceneConfig } from './config';

/* ------------------------------------------------------------------ */
/* createContext – bootstrap renderer / physics / camera              */
export async function createContext(
  canvas: HTMLCanvasElement,
  RAPIER: typeof import('@dimforge/rapier3d-compat')
): Promise<ECSContext> {
  /* Rapier ---------------------------------------------------------- */
  const rapier = RAPIER;
  const physics = new rapier.World({ x: 0, y: -9.81, z: 0 });

  /* Three renderer -------------------------------------------------- */
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type    = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(SceneConfig.SKY_COLOR);
  scene.fog        = new THREE.FogExp2(0x88BBFF, 0.0025);

  const camera = new THREE.PerspectiveCamera(
    75, window.innerWidth / window.innerHeight, 0.1, 1000
  );

  // Set up window resize handler
  setupWindowResize(camera, renderer);

  // Create context object
  const ctx: ECSContext = {
    rapier, physics,
    three: { scene, camera, renderer },
    maps : { mesh: new Map(), rb: new Map() }
  };

  // Set up lighting, sky and ground
  setupLighting(ctx);
  setupSky(ctx);
  setupGround(ctx);

  return ctx;
}

/* ------------------------------------------------------------------ */
/* Helper function to set up window resize handling                   */
function setupWindowResize(camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer) {
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

/* ------------------------------------------------------------------ */
/* Helper function to set up scene lighting                           */
function setupLighting(ctx: ECSContext) {
  const scene = ctx.three.scene;
  
  // Add ambient light
  scene.add(new THREE.AmbientLight(
    0xffffff, SceneConfig.AMBIENT_LIGHT_INTENSITY
  ));

  // Add directional light with shadows
  const dirLight = new THREE.DirectionalLight(
    0xffffff, SceneConfig.DIRECTIONAL_LIGHT_INTENSITY
  );
  dirLight.position.set(5, 10, 7);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.set(2048, 2048);
  dirLight.shadow.camera.left = -20;
  dirLight.shadow.camera.right = 20;
  dirLight.shadow.camera.top = 20;
  dirLight.shadow.camera.bottom = -20;
  dirLight.shadow.camera.near = 0.5;
  dirLight.shadow.camera.far  = 50;
  scene.add(dirLight);
}

/* ------------------------------------------------------------------ */
/* Helper function to create sky dome                                 */
function setupSky(ctx: ECSContext) {
  const scene = ctx.three.scene;
  const sky = new THREE.SphereGeometry(400, 32, 15).scale(-1, 1, 1);
  scene.add(new THREE.Mesh(
    sky, 
    new THREE.MeshBasicMaterial({ 
      color: SceneConfig.SKY_COLOR, 
      side: THREE.BackSide 
    })
  ));
}

/* ------------------------------------------------------------------ */
/* Helper function to create ground plane                             */
function setupGround(ctx: ECSContext) {
  const scene = ctx.three.scene;
  const { rapier, physics } = ctx;
  
  const HALF_H = 0.05;                 // 0.1 m thick collider
  const GROUND_Y = -HALF_H;
  const SIZE = SceneConfig.GROUND_SIZE;

  // Create ground mesh
  const groundMesh = new THREE.Mesh(
    new THREE.PlaneGeometry(SIZE, SIZE).rotateX(-Math.PI / 2),
    new THREE.MeshStandardMaterial({ 
      color: SceneConfig.GROUND_COLOR, 
      roughness: 0.8, 
      metalness: 0.2 
    })
  );
  groundMesh.receiveShadow = true;
  groundMesh.position.y    = GROUND_Y;
  scene.add(groundMesh);

  // Create ground collider
  const groundBody = physics.createRigidBody(
    rapier.RigidBodyDesc.fixed().setTranslation(0, GROUND_Y, 0)
  );
  physics.createCollider(
    rapier.ColliderDesc.cuboid(SIZE/2, HALF_H, SIZE/2), groundBody
  );
}

/* ------------------------------------------------------------------ */
/* populateScene – central cube stack + scattered cubes               */
export function populateScene(world: ECS, ctx: ECSContext): void {
  const { rapier, physics, maps, three } = ctx;
  
  // Create shared geometry and materials for cube factory
  const geometries = new Map<number, THREE.BoxGeometry>();
  const materials = new Map<number, THREE.MeshStandardMaterial>();
  
  // Cube factory function with reused geometries/materials
  const makeCube = (
    x: number, y: number, z: number,
    size = 1, color = Math.random() * 0xffffff
  ) => {
    /* Three mesh ---------------------------------------------------- */
    // Reuse or create geometry
    if (!geometries.has(size)) {
      geometries.set(size, new THREE.BoxGeometry(size, size, size));
    }
    
    // Reuse material if same color (within tolerance) or create new
    let material: THREE.MeshStandardMaterial | undefined;
    for (const [existingColor, existingMaterial] of materials.entries()) {
      // Allow for small color differences (hex representation)
      if (Math.abs(existingColor - color) < 100) {
        material = existingMaterial;
        break;
      }
    }
    
    if (!material) {
      material = new THREE.MeshStandardMaterial({ 
        color, 
        roughness: 0.7, 
        metalness: 0.3 
      });
      materials.set(color, material);
    }
    
    const mesh = new THREE.Mesh(geometries.get(size)!, material);
    mesh.castShadow = mesh.receiveShadow = true;
    mesh.position.set(x, y, z);
    three.scene.add(mesh);

    /* Rapier body --------------------------------------------------- */
    const rb = physics.createRigidBody(
      rapier.RigidBodyDesc.dynamic()
            .setTranslation(x, y, z)
            .setCcdEnabled(true)
    );
    physics.createCollider(
      rapier.ColliderDesc.cuboid((size * 0.98) / 2, (size * 0.98) / 2, (size * 0.98) / 2)
            .setRestitution(SceneConfig.CUBE_RESTITUTION)
            .setFriction(SceneConfig.CUBE_FRICTION),
      rb
    );

    /* ECS entity ---------------------------------------------------- */
    const eid = addEntity(world);
    addComponent(world, CubeTag,     eid);
    addComponent(world, Transform,   eid);
    addComponent(world, MeshRef,     eid);
    addComponent(world, RigidBodyRef,eid);

    maps.mesh.set(eid, mesh);
    maps.rb.set(eid, rb);
    RigidBodyRef.id[eid] = rb.handle;
    
    // Update handle map
    if (world.ctx.entityHandleMap) {
      world.ctx.entityHandleMap.set(rb.handle, eid);
    }
  };

  /* Create cube stacks */
  const stackSize = SceneConfig.CUBE_STACK_SIZE;
  const halfStack = stackSize / 2;
  
  // Make a cube stack
  for (let y = 0; y < stackSize; ++y)
    for (let x = 0; x < stackSize; ++x)
      for (let z = 0; z < stackSize; ++z)
        makeCube(x - halfStack, y + 0.5, z - halfStack);

  /* extra cubes */
  for (let i = 0; i < SceneConfig.EXTRA_CUBES; i++)
    makeCube(
      (Math.random() - 0.5) * 20,
      10 + Math.random() * 10,
      (Math.random() - 0.5) * 20,
      0.5 + Math.random() * 1.5
    );
}


================================================
File: /src/ecs/systems/collision.ts
================================================
import { defineQuery, addComponent, addEntity, hasComponent } from 'bitecs';
import { Projectile, CubeTag, RigidBodyRef, CollisionEvent } from '../components';
import { ECS } from '../world';
import { vec3Pool, createEntityPairKey } from '../utils/mathUtils';
import { PhysicsConfig } from '../config';

export function initCollisionSystem(world: ECS) {
  const projectileQuery = defineQuery([Projectile, RigidBodyRef]);
  const cubeQuery = defineQuery([CubeTag, RigidBodyRef]);
  
  // Last processed collision time to avoid duplicates
  const processedCollisions = new Map<bigint, number>();
  
  // Cache of rigid body handles to entity IDs
  // Initialize entity handle mapping
  if (!world.ctx.entityHandleMap) {
    world.ctx.entityHandleMap = new Map<number, number>();
  }
  
  // Helper to mark entities for deletion outside the hot collision loop
  function markEntityForDeletion(eid: number) {
    const mesh = world.ctx.maps.mesh.get(eid);
    if (mesh) {
      if (!mesh.userData) mesh.userData = {};
      mesh.userData.markedForDeletion = true;
    }
  }
  
  return (w: ECS) => {
    const now = performance.now();
    
    // Clean up old processed collisions (older than 200ms)
    for (const [key, time] of processedCollisions.entries()) {
      if (now - time > 200) {
        processedCollisions.delete(key);
      }
    }
    
    // Skip if no event queue is available
    if (!w.ctx.eventQueue) {
      return w;
    }
    
    // Cache query results once per tick
    const projectiles = projectileQuery(w);
    const cubes = cubeQuery(w);
    
    // Update entity handle map for any new entities
    for (const eid of projectiles) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb && !w.ctx.entityHandleMap!.has(rb.handle)) {
        w.ctx.entityHandleMap!.set(rb.handle, eid);
      }
    }
    
    for (const eid of cubes) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb && !w.ctx.entityHandleMap!.has(rb.handle)) {
        w.ctx.entityHandleMap!.set(rb.handle, eid);
      }
    }
    
    // Process collision events from Rapier physics
    w.ctx.eventQueue.drainCollisionEvents((handle1: number, handle2: number, started: boolean) => {
      // We only care about collision starts
      if (!started) return;
      
      // Get entity IDs from rigid body handles
      const entity1 = w.ctx.entityHandleMap!.get(handle1);
      const entity2 = w.ctx.entityHandleMap!.get(handle2);
      
      if (!entity1 || !entity2) return;
      
      // Use hasComponent for O(1) lookups instead of array.includes()
      const isProjectile1 = hasComponent(w, Projectile, entity1);
      const isProjectile2 = hasComponent(w, Projectile, entity2);
      const isCube1 = hasComponent(w, CubeTag, entity1);
      const isCube2 = hasComponent(w, CubeTag, entity2);
      
      // Skip if not a projectile-cube collision
      if (!((isProjectile1 && isCube2) || (isProjectile2 && isCube1))) {
        return;
      }
      
      // Determine which is which
      const projectileEid = isProjectile1 ? entity1 : entity2;
      const cubeEid = isCube1 ? entity1 : entity2;
      
      // Create a unique ID for this collision using BigInt
      const collisionId = createEntityPairKey(projectileEid, cubeEid);
      
      // Skip if we've already processed this collision recently
      if (processedCollisions.has(collisionId)) return;
      
      // Mark collision as processed
      processedCollisions.set(collisionId, now);
      
      // Get the cube and projectile rigid bodies
      const cubeRB = w.ctx.maps.rb.get(cubeEid);
      const projectileRB = w.ctx.maps.rb.get(projectileEid);
      
      if (!cubeRB || !projectileRB) return;
      
      // Calculate impact direction - from bullet to cube center
      const bulletPos = projectileRB.translation();
      const cubePos = cubeRB.translation();
      
      // Direction vector from bullet to cube center (where to push the cube)
      // Use pooled vector
      const impactDir = vec3Pool.get().set(
        cubePos.x - bulletPos.x,
        cubePos.y - bulletPos.y,
        cubePos.z - bulletPos.z
      ).normalize();
      
      // If direction is zero (e.g., direct center hit), use reversed bullet velocity
      if (impactDir.lengthSq() < 0.001) {
        const vel = projectileRB.linvel();
        impactDir.set(-vel.x, -vel.y, -vel.z).normalize();
      }
      
      // Apply impulse force at contact point in direction from bullet to cube
      cubeRB.applyImpulseAtPoint(
        { 
          x: impactDir.x * PhysicsConfig.IMPACT_FORCE, 
          y: impactDir.y * PhysicsConfig.IMPACT_FORCE, 
          z: impactDir.z * PhysicsConfig.IMPACT_FORCE 
        },
        {
          x: bulletPos.x,
          y: bulletPos.y,
          z: bulletPos.z
        },
        true
      );
      
      // Add some random torque for realistic effect
      cubeRB.applyTorqueImpulse(
        {
          x: (Math.random() - 0.5) * PhysicsConfig.IMPACT_FORCE * 0.3,
          y: (Math.random() - 0.5) * PhysicsConfig.IMPACT_FORCE * 0.3,
          z: (Math.random() - 0.5) * PhysicsConfig.IMPACT_FORCE * 0.3
        },
        true
      );
      
      // Create a collision event entity
      const eventEid = addEntity(w);
      addComponent(w, CollisionEvent, eventEid);
      CollisionEvent.entity1[eventEid] = projectileEid;
      CollisionEvent.entity2[eventEid] = cubeEid;
      CollisionEvent.impulse[eventEid] = PhysicsConfig.IMPACT_FORCE;
      CollisionEvent.time[eventEid] = now;
      
      // Mark projectile for destruction
      markEntityForDeletion(projectileEid);
      
      // Release pooled vector
      vec3Pool.release(impactDir);
    });
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/debugVis.ts
================================================
import { defineQuery } from 'bitecs';
import { DebugVis, Projectile, Player, RigidBodyRef } from '../components';
import { ECS } from '../world';
import * as THREE from 'three';
import { vec3Pool } from '../utils/mathUtils';

// Maximum number of points in trajectory
const MAX_TRAJECTORY_POINTS = 100;

export function initDebugVisSystem(world: ECS) {
  const debugQuery = defineQuery([DebugVis]);
  const playerQuery = defineQuery([Player, RigidBodyRef]);
  const projectileQuery = defineQuery([Projectile, RigidBodyRef]);
  
  // Store trajectory data
  const trajectoryLines = new Map<number, THREE.Line>();
  const trajectories = new Map<number, {
    count: number,  // Current number of points
    maxCount: number  // Maximum capacity
  }>();
  
  // Store pre-allocated buffers to avoid creating new ones each frame
  const positionBuffers = new Map<number, {
    array: Float32Array,
    attribute: THREE.BufferAttribute
  }>();
  
  // Shared line material for all trajectories
  const lineMaterial = new THREE.LineBasicMaterial({ 
    color: 0xff9900, 
    transparent: true, 
    opacity: 0.7 
  });
  
  // Create player capsule mesh for debug
  let playerCapsule: THREE.Mesh | null = null;
  
  // Create a simple cylinder geometry
  const createCylinderGeometry = (radius: number, height: number, widthSegments = 16): THREE.BufferGeometry => {
    // Create cylinder body
    return new THREE.CylinderGeometry(
      radius, radius, height - radius * 2, widthSegments, 1, true
    );
  };
  
  // Initialize the debug capsule and materials
  const wireframeMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    wireframe: true,
    transparent: true,
    opacity: 0.7
  });
  
  // Create the capsule mesh once at initialization
  const capsuleGeometry = createCylinderGeometry(0.3, 1.8, 16);
  playerCapsule = new THREE.Mesh(capsuleGeometry, wireframeMaterial);
  world.ctx.three.scene.add(playerCapsule);
  playerCapsule.visible = false; // Hidden by default
  
  return (w: ECS) => {
    // First check if debug visualization is enabled
    const debugEnts = debugQuery(w);
    const debugId = debugEnts.length > 0 ? debugEnts[0] : -1;
    const debugActive = debugId !== -1 && DebugVis.active[debugId] === 1;
    
    // Update player capsule visibility and position
    if (playerCapsule) {
      playerCapsule.visible = debugActive;
      
      // Update position if visible
      if (debugActive) {
        const playerEnts = playerQuery(w);
        if (playerEnts.length > 0) {
          const playerEid = playerEnts[0];
          const playerObj = w.ctx.maps.mesh.get(playerEid);
          if (playerObj) {
            playerCapsule.position.copy(playerObj.position);
            playerCapsule.position.y -= 0.3; // Adjust to match center of capsule
            playerCapsule.rotation.y = playerObj.rotation.y;
          }
        }
      }
    }
    
    // Update projectile trajectories
    for (const projectileEid of projectileQuery(w)) {
      // Get current position for this projectile
      const rb = w.ctx.maps.rb.get(projectileEid);
      if (!rb) continue;
      
      // Get position and add to trajectory
      const pos = rb.translation();
      const currentPos = vec3Pool.get().set(pos.x, pos.y, pos.z);
      
      // Initialize trajectory and buffer if needed
      if (!trajectories.has(projectileEid)) {
        // Create trajectory tracking object
        trajectories.set(projectileEid, {
          count: 0,
          maxCount: MAX_TRAJECTORY_POINTS
        });
        
        // Pre-allocate the Float32Array with maximum size
        const posArray = new Float32Array(MAX_TRAJECTORY_POINTS * 3);
        const posAttribute = new THREE.BufferAttribute(posArray, 3);
        positionBuffers.set(projectileEid, {
          array: posArray,
          attribute: posAttribute
        });
      }
      
      // Get the trajectory data
      const trajectory = trajectories.get(projectileEid)!;
      // Get the buffer
      const buffer = positionBuffers.get(projectileEid)!;
      
      // Add current position directly to the buffer
      if (trajectory.count < MAX_TRAJECTORY_POINTS) {
        // We have room, add at the end
        const idx = trajectory.count * 3;
        buffer.array[idx] = currentPos.x;
        buffer.array[idx + 1] = currentPos.y;
        buffer.array[idx + 2] = currentPos.z;
        trajectory.count++;
      } else {
        // Shift all points one position back using copyWithin (much faster than loop)
        buffer.array.copyWithin(0, 3);
        
        // Add new point at the end
        const idx = (trajectory.count - 1) * 3;
        buffer.array[idx] = currentPos.x;
        buffer.array[idx + 1] = currentPos.y;
        buffer.array[idx + 2] = currentPos.z;
      }
      
      // Mark buffer for update
      buffer.attribute.needsUpdate = true;
      
      // Release the pooled vector
      vec3Pool.release(currentPos);
      
      // Only update/show trajectory lines if debug is active
      if (debugActive) {
        if (trajectoryLines.has(projectileEid)) {
          // Update existing line - reuse the geometry
          const line = trajectoryLines.get(projectileEid)!;
          line.visible = true;
          
          // Get the pre-allocated buffer and update it
          const buffer = positionBuffers.get(projectileEid)!;
          
          // Update geometry to draw only the current points
          line.geometry.setDrawRange(0, trajectory.count);
          buffer.attribute.needsUpdate = true;
        } else {
          // Create new line with dynamic buffer geometry
          const geometry = new THREE.BufferGeometry();
          const buffer = positionBuffers.get(projectileEid)!;
          
          // Add attribute to geometry
          geometry.setAttribute('position', buffer.attribute);
          
          // Set initial draw range
          geometry.setDrawRange(0, trajectory.count);
          
          // Use the shared material
          const line = new THREE.Line(geometry, lineMaterial);
          trajectoryLines.set(projectileEid, line);
          w.ctx.three.scene.add(line);
        }
      } else {
        // Hide lines if debug is disabled
        if (trajectoryLines.has(projectileEid)) {
          trajectoryLines.get(projectileEid)!.visible = false;
        }
      }
    }
    
    // Clean up trajectories for removed projectiles
    for (const [eid, line] of trajectoryLines.entries()) {
      const projectileExists = projectileQuery(w).includes(eid);
      
      // Check if projectile is marked for deletion
      const mesh = w.ctx.maps.mesh.get(eid);
      const markedForDeletion = mesh?.userData?.markedForDeletion === true;
      
      if (!projectileExists || markedForDeletion) {
        // Remove the trajectory line
        w.ctx.three.scene.remove(line);
        line.geometry.dispose();
        if (line.material instanceof THREE.Material) {
          line.material.dispose();
        } else if (Array.isArray(line.material)) {
          line.material.forEach(mat => mat.dispose());
        }
        trajectoryLines.delete(eid);
        trajectories.delete(eid);
        positionBuffers.delete(eid);
      }
    }
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/grass.ts
================================================
import * as THREE from 'three';
import { ECS } from '../world';
import { defineQuery, enterQuery, exitQuery } from 'bitecs';
import { CubeTag, Transform } from '../components';

// Custom shader material class for grass
class ShaderManager {
  private static instance: ShaderManager;
  private shaderCache: Record<string, { vertex: string, fragment: string }> = {};
  
  private constructor() {
    this.initShaders();
  }

  public static getInstance(): ShaderManager {
    if (!ShaderManager.instance) {
      ShaderManager.instance = new ShaderManager();
    }
    return ShaderManager.instance;
  }

  private initShaders(): void {
    // Define grass shader
    const grassVertexShader = `
      uniform vec2 grassSize;
      uniform vec4 grassParams;
      uniform vec4 grassDraw;
      uniform float time;
      uniform vec3 playerPos;
      uniform mat4 viewMatrixInverse;

      attribute float vertIndex;

      varying vec4 vGrassParams;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      varying vec2 vUv;

      // Math utility functions
      float saturate(float x) {
        return clamp(x, 0.0, 1.0);
      }

      float linearstep(float minValue, float maxValue, float v) {
        return clamp((v - minValue) / (maxValue - minValue), 0.0, 1.0);
      }

      float easeOut(float x, float t) {
        return 1.0 - pow(1.0 - x, t);
      }

      float easeIn(float x, float t) {
        return pow(x, t);
      }

      // Hash functions
      vec2 hash22(vec2 p) {
        p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
        return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
      }

      vec4 hash42(vec2 p) {
        vec4 p4 = fract(vec4(p.xyxy) * vec4(0.1031, 0.1030, 0.0973, 0.1099));
        p4 += dot(p4, p4.wzxy + 33.33);
        return fract((p4.xxyz + p4.yzzw) * p4.zywx) * 2.0 - 1.0;
      }

      // Noise function for wind
      float noise12(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        
        // Smooth interpolation
        vec2 u = f * f * (3.0 - 2.0 * f);
        
        // Hash corners
        float a = dot(hash22(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));
        float b = dot(hash22(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));
        float c = dot(hash22(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));
        float d = dot(hash22(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));
        
        // Mix
        return mix(mix(a, b, u.x), mix(c, d, u.x), u.y) * 0.5 + 0.5;
      }

      // Matrix utility functions
      mat3 rotateX(float theta) {
        float c = cos(theta);
        float s = sin(theta);
        return mat3(
          vec3(1.0, 0.0, 0.0),
          vec3(0.0, c, -s),
          vec3(0.0, s, c)
        );
      }

      mat3 rotateY(float theta) {
        float c = cos(theta);
        float s = sin(theta);
        return mat3(
          vec3(c, 0.0, s),
          vec3(0.0, 1.0, 0.0),
          vec3(-s, 0.0, c)
        );
      }

      mat3 rotateAxis(vec3 axis, float angle) {
        axis = normalize(axis);
        float s = sin(angle);
        float c = cos(angle);
        float oc = 1.0 - c;
        
        return mat3(
          oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
          oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
          oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c
        );
      }

      void main() {
        vec3 grassOffset = vec3(position.x, 0.0, position.y);

        // Blade world position
        vec3 grassBladeWorldPos = (modelMatrix * vec4(grassOffset, 1.0)).xyz;
        float heightmapSample = 0.0;
        float heightmapSampleHeight = 1.0;

        vec4 hashVal1 = hash42(vec2(grassBladeWorldPos.x, grassBladeWorldPos.z));

        float highLODOut = smoothstep(grassDraw.x * 0.5, grassDraw.x, distance(cameraPosition, grassBladeWorldPos));
        float lodFadeIn = smoothstep(grassDraw.x, grassDraw.y, distance(cameraPosition, grassBladeWorldPos));

        // Check terrain type
        float isSandy = 0.0;
        float grassAllowedHash = hashVal1.w - isSandy;
        float isGrassAllowed = step(0.0, grassAllowedHash);

        float randomAngle = hashVal1.x * 2.0 * 3.14159;
        float randomShade = clamp(hashVal1.y * 0.5 + 0.5, 0.5, 1.0);
        float randomHeight = mix(0.75, 1.5, hashVal1.z * 0.5 + 0.5) * mix(1.0, 0.0, lodFadeIn) * isGrassAllowed * heightmapSampleHeight;
        float randomWidth = (1.0 - isSandy) * heightmapSampleHeight;
        float randomLean = mix(0.1, 0.4, hashVal1.w * 0.5 + 0.5);

        vec2 hashGrassColour = hash22(vec2(grassBladeWorldPos.x, grassBladeWorldPos.z)) * 0.5 + 0.5;
        float leanAnimation = (noise12(vec2(time * 0.35) + grassBladeWorldPos.xz * 137.423) * 2.0 - 1.0) * 0.1;

        float GRASS_SEGMENTS = grassParams.x;
        float GRASS_VERTICES = grassParams.y;

        // Figure out vertex id
        float vertID = mod(float(vertIndex), GRASS_VERTICES);

        // 1 = front, -1 = back
        float zSide = -(floor(vertIndex / GRASS_VERTICES) * 2.0 - 1.0);

        // 0 = left, 1 = right
        float xSide = mod(vertID, 2.0);

        float heightPercent = (vertID - xSide) / (GRASS_SEGMENTS * 2.0);

        // Select grass blade variation (0-4 for 5 variations)
        float bladeVariation = floor(hashVal1.x * 5.0);

        float grassTotalHeight = grassSize.y * randomHeight;
        float grassTotalWidthHigh = easeOut(1.0 - heightPercent, 2.0);
        float grassTotalWidthLow = 1.0 - heightPercent;
        float grassTotalWidth = grassSize.x * mix(grassTotalWidthHigh, grassTotalWidthLow, highLODOut) * randomWidth;

        // Shift verts
        float x = (xSide - 0.5) * grassTotalWidth;
        float y = heightPercent * grassTotalHeight;

        float windDir = noise12(grassBladeWorldPos.xz * 0.05 + 0.05 * time) * 6.28318;
        float windNoiseSample = noise12(grassBladeWorldPos.xz * 0.25 + time * 1.0) * 2.0 - 1.0;
        float windLeanAngle = mix(0.25, 1.0, clamp(windNoiseSample * 0.5 + 0.5, 0.0, 1.0));
        windLeanAngle = easeIn(windLeanAngle, 2.0) * 1.25;
        vec3 windAxis = vec3(cos(windDir), 0.0, sin(windDir));

        windLeanAngle *= heightPercent;

        float distToPlayer = distance(grassBladeWorldPos.xz, playerPos.xz);
        float playerFalloff = smoothstep(2.5, 1.0, distToPlayer);
        float playerLeanAngle = mix(0.0, 0.2, playerFalloff * linearstep(0.5, 0.0, windLeanAngle));
        vec3 grassToPlayer = normalize(vec3(playerPos.x, 0.0, playerPos.z) - vec3(grassBladeWorldPos.x, 0.0, grassBladeWorldPos.z));
        vec3 playerLeanAxis = vec3(grassToPlayer.z, 0, -grassToPlayer.x);

        randomLean += leanAnimation;

        float easedHeight = mix(easeIn(heightPercent, 2.0), 1.0, highLODOut);
        float curveAmount = -randomLean * easedHeight;

        float ncurve1 = -randomLean * easedHeight;
        vec3 n1 = vec3(0.0, (heightPercent + 0.01), 0.0);
        n1 = rotateX(ncurve1) * n1;

        float ncurve2 = -randomLean * easedHeight * 0.9;
        vec3 n2 = vec3(0.0, (heightPercent + 0.01) * 0.9, 0.0);
        n2 = rotateX(ncurve2) * n2;

        vec3 ncurve = normalize(n1 - n2);

        mat3 grassMat = rotateAxis(playerLeanAxis, playerLeanAngle) * rotateAxis(windAxis, windLeanAngle) * rotateY(randomAngle);

        vec3 grassFaceNormal = vec3(0.0, 0.0, 1.0);
        grassFaceNormal = grassMat * grassFaceNormal;
        grassFaceNormal *= zSide;

        vec3 grassVertexNormal = vec3(0.0, -ncurve.z, ncurve.y);
        vec3 grassVertexNormal1 = rotateY(3.14159 * 0.3 * zSide) * grassVertexNormal;

        grassVertexNormal1 = grassMat * grassVertexNormal1;
        grassVertexNormal1 *= zSide;

        vec3 grassVertexPosition = vec3(x, y, 0.0);
        grassVertexPosition = rotateX(curveAmount) * grassVertexPosition;
        grassVertexPosition = grassMat * grassVertexPosition;

        grassVertexPosition += grassOffset;

        vGrassParams = vec4(heightPercent, grassBladeWorldPos.y, highLODOut, xSide);
        
        const float SKY_RATIO = 0.15;
        vec3 UP = vec3(0.0, 1.0, 0.0);
        float skyFadeIn = (1.0 - highLODOut) * SKY_RATIO;
        vNormal = normalize(mix(UP, grassVertexNormal1, skyFadeIn));

        vec3 pos = grassVertexPosition;

        vec3 viewDir = normalize(cameraPosition - grassBladeWorldPos);
        vec3 viewDirXZ = normalize(vec3(viewDir.x, 0.0, viewDir.z));
        vec3 grassFaceNormalXZ = normalize(vec3(grassFaceNormal.x, 0.0, grassFaceNormal.z));

        float viewDotNormal = saturate(dot(grassFaceNormal, viewDirXZ));
        float viewSpaceThickenFactor = easeOut(1.0 - viewDotNormal, 4.0) * smoothstep(0.0, 0.2, viewDotNormal);

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        
        // Thicken effect for better visibility
        mvPosition.x += viewSpaceThickenFactor * (xSide - 0.5) * grassTotalWidth * 0.5 * zSide;
        
        gl_Position = projectionMatrix * mvPosition;
        
        vPosition = pos;
        vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
        
        // Map UV to select one of the 5 blade variations
        // Each blade is 143px wide in a 715px texture (1/5 = 0.2 of the total width)
        // X coordinate: map the xSide (0-1) to a 0.2 width segment based on variation
        float uvX = (xSide * 0.2) + (bladeVariation * 0.2);
        vUv = vec2(uvX, heightPercent);
      }
    `;
    
    const grassFragmentShader = `
      uniform vec3 diffuse;
      uniform vec3 specular;
      uniform float shininess;
      uniform float opacity;
      uniform float time;
      uniform sampler2D grassTexture;
      
      varying vec4 vGrassParams;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      varying vec2 vUv;
      
      // Light data (mimic Three.js directional light)
      struct DirectionalLight {
        vec3 direction;
        vec3 color;
      };
      
      const DirectionalLight directionalLight = DirectionalLight(
        normalize(vec3(-0.5, 0.8, 0.5)),
        vec3(1.0, 1.0, 1.0)
      );
      
      // Utility functions
      float saturate(float x) {
        return clamp(x, 0.0, 1.0);
      }
      
      float easeIn(float x, float t) {
        return pow(x, t);
      }
      
      vec3 calculateLighting(vec3 normal, vec3 viewDir, vec3 baseColor) {
        // Ambient term
        vec3 ambient = vec3(0.3) * baseColor;
        
        // Diffuse term with wrapped lighting for softer look
        float wrap = 0.5;
        float NdotL = saturate((dot(normal, directionalLight.direction) + wrap) / (1.0 + wrap));
        vec3 diffuseLight = NdotL * directionalLight.color * baseColor;
        
        // Simple specular for highlights
        vec3 halfVector = normalize(directionalLight.direction + viewDir);
        float NdotH = max(0.0, dot(normal, halfVector));
        vec3 specularLight = pow(NdotH, shininess) * specular * directionalLight.color;
        
        // Back-lighting for translucency effect
        float backLight = saturate((dot(viewDir, -directionalLight.direction) + wrap) / (1.0 + wrap));
        float backFalloff = 0.5;
        vec3 backScatter = directionalLight.color * pow(backLight, 1.0) * backFalloff * baseColor * (1.0 - vGrassParams.z);
        
        return ambient + diffuseLight + specularLight + backScatter;
      }
      
      void main() {
        // Grass color processing
        float heightPercent = vGrassParams.x;
        float lodFadeIn = vGrassParams.z;
        
        // Sample the grass texture
        vec4 texSample = texture2D(grassTexture, vUv);
        
        // Use texture color directly
        vec3 baseColor = texSample.rgb;
        
        // Apply ambient occlusion at the base for natural grounding
        float ao = mix(0.25, 1.0, easeIn(heightPercent, 2.0));
        baseColor *= ao;
        
        // Lighting calculation
        vec3 viewDir = normalize(cameraPosition - vWorldPosition);
        vec3 litColor = calculateLighting(normalize(vNormal), viewDir, baseColor);
        
        // Use alpha from texture if available
        float alpha = texSample.a;
        if (alpha < 0.5) discard; // Discard pixels with low alpha
        
        gl_FragColor = vec4(litColor, 1.0);
      }
    `;
    
    this.shaderCache['GRASS'] = {
      vertex: grassVertexShader,
      fragment: grassFragmentShader
    };
  }

  public getShader(name: string): { vertex: string, fragment: string } {
    if (!this.shaderCache[name]) {
      console.error(`Shader ${name} not found`);
      return { vertex: '', fragment: '' };
    }
    return this.shaderCache[name];
  }
}

// Custom shader material class that works with our shader system
class CustomShaderMaterial extends THREE.ShaderMaterial {
  constructor(type: string, parameters: THREE.ShaderMaterialParameters = {}) {
    const shaderManager = ShaderManager.getInstance();
    const shader = shaderManager.getShader(type);
    
    if (!parameters.uniforms) {
      parameters.uniforms = {};
    }
    
    parameters.vertexShader = shader.vertex;
    parameters.fragmentShader = shader.fragment;
    
    super(parameters);
    
    // Set some default values
    this.transparent = parameters.transparent !== undefined ? parameters.transparent : false;
    this.side = parameters.side !== undefined ? parameters.side : THREE.FrontSide;
    this.depthWrite = parameters.depthWrite !== undefined ? parameters.depthWrite : true;
    this.depthTest = parameters.depthTest !== undefined ? parameters.depthTest : true;
  }
  
  setFloat(name: string, value: number): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value = value;
    }
  }
  
  setVector2(name: string, value: THREE.Vector2): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setVector3(name: string, value: THREE.Vector3): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setVector4(name: string, value: THREE.Vector4): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setMatrix(name: string, value: THREE.Matrix4): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value: value.clone() };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setTexture(name: string, value: THREE.Texture): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value = value;
    }
  }
}

// Simple math utility functions
const setSeed = (seed: number): void => {
  // Use a simple random number generator
  Math.random = () => {
    const x = Math.sin(seed++) * 10000;
    return x - Math.floor(x);
  };
};

const randRange = (min: number, max: number): number => {
  return Math.random() * (max - min) + min;
};

// Constants for grass rendering
const NUM_GRASS = (32 * 32) * 3;
const GRASS_SEGMENTS_LOW = 1;
const GRASS_SEGMENTS_HIGH = 6;
const GRASS_VERTICES_LOW = (GRASS_SEGMENTS_LOW + 1) * 2;
const GRASS_VERTICES_HIGH = (GRASS_SEGMENTS_HIGH + 1) * 2;
const GRASS_LOD_DIST = 25;
const GRASS_MAX_DIST = 180;
const GRASS_PATCH_SIZE = 5 * 2;
const GRASS_WIDTH = 0.1;
const GRASS_HEIGHT = 1.5;

// Grass component implementation
class GrassComponent {
  private meshesLow: THREE.Mesh[] = [];
  private meshesHigh: THREE.Mesh[] = [];
  private group: THREE.Group;
  private totalTime: number = 0;
  private grassMaterialLow: CustomShaderMaterial;
  private grassMaterialHigh: CustomShaderMaterial;
  private geometryLow: THREE.InstancedBufferGeometry;
  private geometryHigh: THREE.InstancedBufferGeometry;
  private readonly _scene: THREE.Scene;
  private grassTexture: THREE.Texture;

  constructor(scene: THREE.Scene, private camera: THREE.PerspectiveCamera) {
    this._scene = scene;
    this.group = new THREE.Group();
    this.group.name = "GRASS";
    
    // Load grass texture
    this.grassTexture = new THREE.TextureLoader().load('/textures/grassblade.png');
    this.grassTexture.wrapS = THREE.ClampToEdgeWrapping;
    this.grassTexture.wrapT = THREE.ClampToEdgeWrapping;
    this.grassTexture.minFilter = THREE.LinearFilter;
    this.grassTexture.magFilter = THREE.LinearFilter;
    this.grassTexture.generateMipmaps = true;
    // The texture contains 5 blades horizontally, prevent texture bleeding between variants
    this.grassTexture.anisotropy = 16; // Improves appearance at angles
    
    // Initialize grass materials
    this.grassMaterialLow = this.createGrassMaterial(true);
    this.grassMaterialHigh = this.createGrassMaterial(false);
    
    // Create grass geometries
    this.geometryLow = this.createGrassGeometry(GRASS_SEGMENTS_LOW);
    this.geometryHigh = this.createGrassGeometry(GRASS_SEGMENTS_HIGH);
    
    // Add group to scene
    scene.add(this.group);
  }

  private createGrassMaterial(isLowDetail: boolean): CustomShaderMaterial {
    const material = new CustomShaderMaterial('GRASS', {
      uniforms: {
        grassSize: { value: new THREE.Vector2(GRASS_WIDTH, GRASS_HEIGHT) },
        grassParams: { value: new THREE.Vector4(
          isLowDetail ? GRASS_SEGMENTS_LOW : GRASS_SEGMENTS_HIGH,
          isLowDetail ? GRASS_VERTICES_LOW : GRASS_VERTICES_HIGH,
          0, 0
        )},
        grassDraw: { value: new THREE.Vector4(GRASS_LOD_DIST, GRASS_MAX_DIST, 0, 0) },
        time: { value: 0.0 },
        playerPos: { value: new THREE.Vector3(0, 0, 0) },
        viewMatrixInverse: { value: new THREE.Matrix4() },
        diffuse: { value: new THREE.Color(0xffffff) },
        specular: { value: new THREE.Color(0x111111) },
        shininess: { value: 30 },
        grassTexture: { value: this.grassTexture }
      },
      transparent: true,
      alphaTest: 0.5,
      side: THREE.DoubleSide
    });
    
    return material;
  }

  private createGrassGeometry(segments: number): THREE.InstancedBufferGeometry {
    setSeed(0);

    const VERTICES = (segments + 1) * 2;

    // Create indices
    const indices: number[] = [];
    for (let i = 0; i < segments; ++i) {
      const vi = i * 2;
      indices[i*12+0] = vi + 0;
      indices[i*12+1] = vi + 1;
      indices[i*12+2] = vi + 2;

      indices[i*12+3] = vi + 2;
      indices[i*12+4] = vi + 1;
      indices[i*12+5] = vi + 3;

      const fi = VERTICES + vi;
      indices[i*12+6] = fi + 2;
      indices[i*12+7] = fi + 1;
      indices[i*12+8] = fi + 0;

      indices[i*12+9]  = fi + 3;
      indices[i*12+10] = fi + 1;
      indices[i*12+11] = fi + 2;
    }

    // Create offsets
    const offsets: number[] = [];
    for (let i = 0; i < NUM_GRASS; ++i) {
      offsets.push(randRange(-GRASS_PATCH_SIZE * 0.5, GRASS_PATCH_SIZE * 0.5));
      offsets.push(randRange(-GRASS_PATCH_SIZE * 0.5, GRASS_PATCH_SIZE * 0.5));
      offsets.push(0);
    }

    // Create vertex IDs
    const vertID = new Uint8Array(VERTICES*2);
    for (let i = 0; i < VERTICES*2; ++i) {
      vertID[i] = i;
    }

    // Create instanced geometry
    const geo = new THREE.InstancedBufferGeometry();
    geo.instanceCount = NUM_GRASS;
    geo.setAttribute('vertIndex', new THREE.Uint8BufferAttribute(vertID, 1));
    geo.setAttribute('position', new THREE.InstancedBufferAttribute(new Float32Array(offsets), 3));
    geo.setIndex(indices);
    geo.boundingSphere = new THREE.Sphere(new THREE.Vector3(0, 0, 0), 1 + GRASS_PATCH_SIZE * 2);

    return geo;
  }

  private createGrassMesh(distToCell: number): THREE.Mesh {
    const isLowDetail = distToCell > GRASS_LOD_DIST;
    const geometry = isLowDetail ? this.geometryLow : this.geometryHigh;
    const material = isLowDetail ? this.grassMaterialLow : this.grassMaterialHigh;
    
    const mesh = new THREE.Mesh(geometry, material);
    if (!mesh) {
      throw new Error("Failed to create grass mesh");
    }
    mesh.receiveShadow = true;
    mesh.castShadow = false;
    mesh.visible = false;
    
    if (isLowDetail) {
      this.meshesLow.push(mesh);
    } else {
      this.meshesHigh.push(mesh);
    }
    
    this.group.add(mesh);
    return mesh;
  }

  update(deltaTime: number, playerPosition: THREE.Vector3): void {
    this.totalTime += deltaTime;

    // Update material time uniforms
    this.grassMaterialLow.setFloat('time', this.totalTime);
    this.grassMaterialHigh.setFloat('time', this.totalTime);
    
    // Update player position
    this.grassMaterialLow.setVector3('playerPos', playerPosition);
    this.grassMaterialHigh.setVector3('playerPos', playerPosition);
    
    // Update view matrix
    this.grassMaterialLow.setMatrix('viewMatrixInverse', this.camera.matrixWorld);
    this.grassMaterialHigh.setMatrix('viewMatrixInverse', this.camera.matrixWorld);

    // Make all grass patches invisible initially
    for (const child of this.group.children) {
      child.visible = false;
    }

    // Create frustum for culling
    const frustum = new THREE.Frustum();
    const projScreenMatrix = new THREE.Matrix4();
    projScreenMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(projScreenMatrix);
    
    // Calculate base cell position
    const baseCellPos = new THREE.Vector3().copy(this.camera.position);
    baseCellPos.divideScalar(GRASS_PATCH_SIZE);
    baseCellPos.floor();
    baseCellPos.multiplyScalar(GRASS_PATCH_SIZE);
    
    // Copy meshes arrays for reuse
    const meshesLow = [...this.meshesLow];
    const meshesHigh = [...this.meshesHigh];
    
    // Camera position flattened to XZ plane for distance calculation
    const cameraPosXZ = new THREE.Vector3(this.camera.position.x, 0, this.camera.position.z);
    
    // Spawn grass patches
    let totalGrass = 0;
    let totalVerts = 0;
    
    for (let x = -22; x < 22; x++) {
      for (let z = -22; z < 22; z++) {
        // Current cell position
        const currentCell = new THREE.Vector3(
          baseCellPos.x + x * GRASS_PATCH_SIZE, 
          0,
          baseCellPos.z + z * GRASS_PATCH_SIZE
        );
        
        // Create AABB for culling
        const aabb = new THREE.Box3().setFromCenterAndSize(
          currentCell,
          new THREE.Vector3(GRASS_PATCH_SIZE, 1000, GRASS_PATCH_SIZE)
        );
        
        // Calculate distance to cell
        const distToCell = aabb.distanceToPoint(cameraPosXZ);
        
        // Skip if too far
        if (distToCell > GRASS_MAX_DIST) {
          continue;
        }
        
        // Skip if outside frustum
        if (!frustum.intersectsBox(aabb)) {
          continue;
        }
        
        // Create or reuse grass mesh based on distance
        if (distToCell > GRASS_LOD_DIST) {
          const mesh = meshesLow.length > 0 ? meshesLow.pop()! : this.createGrassMesh(distToCell);
          mesh.position.copy(currentCell);
          mesh.visible = true;
          totalVerts += GRASS_VERTICES_LOW;
        } else {
          const mesh = meshesHigh.length > 0 ? meshesHigh.pop()! : this.createGrassMesh(distToCell);
          mesh.position.copy(currentCell);
          mesh.visible = true;
          totalVerts += GRASS_VERTICES_HIGH;
        }
        
        totalGrass += 1;
      }
    }
  }
}

let grassComponent: GrassComponent | null = null;

// Initialize the grass system
export function initGrassSystem(world: ECS) {
  const { scene, camera } = world.ctx.three;
  
  // Create the grass component on system init
  grassComponent = new GrassComponent(scene, camera as THREE.PerspectiveCamera);
  
  // Return the system function
  return function grassSystem(world: ECS) {
    // Get player position from the camera
    const playerPosition = world.ctx.three.camera.position.clone();
    
    // Update grass with elapsed time and player position
    if (grassComponent) {
      grassComponent.update(world.time.dt, playerPosition);
    }
    
    return world;
  };
} 

================================================
File: /src/ecs/systems/input.ts
================================================
import { addComponent, addEntity } from 'bitecs';
import { DebugVis } from '../components';
import { ECS } from '../world';
import { safeAddEventListener, setupEventCleanup } from '../utils/eventUtils';

// Add property to Window interface
declare global {
  interface Window {
    listenersAttached?: boolean;
  }
}

export interface InputState {
  fw: boolean; bk: boolean; lf: boolean; rt: boolean;
  sprint: boolean;
  shoot: boolean; jump: boolean;
  pointerLocked: boolean;
  dx: number; dy: number;
  debugActive: boolean;
}

export function initInputSystem(world: ECS) {
  const state: InputState = {
    fw: false, bk: false, lf: false, rt: false,
    sprint: false,
    shoot: false, jump: false,
    pointerLocked: false,
    dx: 0, dy: 0,
    debugActive: false
  };
  
  // Keep track of whether V was pressed last frame
  let vWasPressed = false;
  
  // Create a singleton debug entity and add the component to it
  const debugId = addEntity(world); // Create a new entity, don't assume ID 0
  addComponent(world, DebugVis, debugId);
  DebugVis.active[debugId] = 0; // 0 = off, 1 = on

  /* keyboard ------------------------------------------------------- */
  const key = (code: string, v: boolean) => {
    if (code === 'KeyW' || code === 'ArrowUp')    state.fw     = v;
    if (code === 'KeyS' || code === 'ArrowDown')  state.bk     = v;
    if (code === 'KeyA' || code === 'ArrowLeft')  state.lf     = v;
    if (code === 'KeyD' || code === 'ArrowRight') state.rt     = v;
    if (code === 'Space')                         state.jump   = v;
    if (code === 'ShiftLeft' || code === 'ShiftRight') state.sprint = v;
    
    // Handle V key press for debug visualization toggle
    if (code === 'KeyV') {
      // Toggle on key down only
      if (v && !vWasPressed) {
        // Toggle debug state
        const newState = DebugVis.active[debugId] === 0 ? 1 : 0;
        DebugVis.active[debugId] = newState;
        state.debugActive = newState === 1;
        console.log(`Debug visualization: ${state.debugActive ? 'ON' : 'OFF'}`);
      }
      vWasPressed = v;
    }
  };
  
  // Only attach event listeners once
  if (!window.listenersAttached) {
    safeAddEventListener(window, 'keydown', e => key((e as KeyboardEvent).code, true));
    safeAddEventListener(window, 'keyup',   e => key((e as KeyboardEvent).code, false));

    /* mouse ---------------------------------------------------------- */
    const canvas = document.getElementById('c') as HTMLCanvasElement;
    safeAddEventListener(canvas, 'click', () => canvas.requestPointerLock());

    safeAddEventListener(document, 'pointerlockchange', () => {
      state.pointerLocked = !!document.pointerLockElement;
    });

    safeAddEventListener(window, 'mousemove', e => {
      if (!state.pointerLocked) return;
      state.dx += (e as MouseEvent).movementX;
      state.dy += (e as MouseEvent).movementY;
    });

    safeAddEventListener(window, 'mousedown', e => { if ((e as MouseEvent).button === 0) state.shoot = true; });
    safeAddEventListener(window, 'mouseup',   e => { if ((e as MouseEvent).button === 0) state.shoot = false; });
    
    // Set up event cleanup
    setupEventCleanup();
    
    // Mark listeners as attached
    window.listenersAttached = true;
  }

  return (w: ECS) => { 
    // Set the input state on the world
    w.input = state;
    return w;
  };
}


================================================
File: /src/ecs/systems/physics.ts
================================================
import { defineQuery, exitQuery } from 'bitecs';
import { RigidBodyRef } from '../components';
import { ECS } from '../world';
import { PhysicsConfig, TimeStepConfig } from '../config';

export function initPhysicsSystem(_world: ECS) {
  const rbq = defineQuery([RigidBodyRef]);
  const exit = exitQuery(rbq);

  /* cleanup on entity removal */
  return (w: ECS) => {
    // Skip physics if we're not on a physics frame
    if (!w.time.shouldRunPhysics) {
      return w;
    }
    
    // Get all active rigid bodies
    const rigidBodies = [];
    for (const eid of rbq(w)) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb) rigidBodies.push(rb);
    }
    
    // Dynamically enable CCD on fast-moving objects
    for (const rb of rigidBodies) {
      try {
        // Different versions of Rapier have different APIs
        // Check if the body is dynamic (only dynamic bodies can have CCD)
        const isDynamic = rb.bodyType && 
                         rb.bodyType() === w.ctx.rapier.RigidBodyType.Dynamic;
        
        if (isDynamic) {
          const vel = rb.linvel();
          const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y + vel.z * vel.z);
          
          // Enable CCD for fast moving objects 
          // Check if this version of Rapier supports CCD toggling
          if (speed > PhysicsConfig.VELOCITY_THRESHOLD && rb.enableCcd) {
            rb.enableCcd(true);
          } 
          // Disable CCD for slower objects to improve performance
          else if (speed < PhysicsConfig.VELOCITY_THRESHOLD * 0.8 && rb.enableCcd) {
            rb.enableCcd(false);
          }
        }
      } catch (e) {
        // Skip CCD handling if the API doesn't match
      }
    }
    
    // Configure physics parameters if the API supports it
    try {
      if (w.ctx.physics.integrationParameters) {
        // Set solver iterations for more accurate simulation
        w.ctx.physics.integrationParameters.numSolverIterations = PhysicsConfig.SOLVER_ITERATIONS;
        
        // Increase CCD substeps - critical for bullet physics!
        w.ctx.physics.integrationParameters.maxCcdSubsteps = PhysicsConfig.CCD_SUBSTEPS;
      }
    } catch (e) {
      // Skip if the API doesn't support this
    }
    
    // Always use the fixed timestep from the time system
    const dt = w.time.fixedDt || TimeStepConfig.FIXED_DT;
    
    // Process physics step with fixed timestep - handle type issues with assertions
    if (w.ctx.eventQueue) {
      // Call step with the correct argument order based on Rapier type definitions
      // Type assertion needed due to version differences in Rapier API
      (w.ctx.physics.step as any)(w.ctx.eventQueue, dt);
    } else {
      // Type assertion needed due to differences in Rapier API versions
      (w.ctx.physics.step as any)(dt);
    }

    /* purge removed RigidBodies */
    for (const eid of exit(w)) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb) {
        w.ctx.physics.removeRigidBody(rb);
        w.ctx.maps.rb.delete(eid);
      }
    }
    return w;
  };
}


================================================
File: /src/ecs/systems/player/animationSystem.ts
================================================
/**
 * Player animation system - handles player model loading, animation states and transitions
 */
import { defineQuery } from 'bitecs';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { Player, MeshRef, FPController } from '../../components';
import { ECS } from '../../world';
import { MovementState } from '../../config';

// Animation state constants
const AnimationState = {
  IDLE: 'idle',
  WALKING: 'walking'
};

export function initPlayerAnimationSystem(world: ECS) {
  const playerQuery = defineQuery([Player, MeshRef, FPController]);
  
  // Animation variables
  let playerModel: THREE.Group | null = null;
  let mixer: THREE.AnimationMixer | null = null;
  let animations: Map<string, THREE.AnimationAction> = new Map();
  let currentAnimation: string | null = null;
  let activeAction: THREE.AnimationAction | null = null;
  
  // Movement tracking
  let movementState = "idle"; // Current movement state: "idle" or "walking"
  let movementTimer = 0; // Timer to prevent rapid state changes
  let movementBuffer = [false, false, false, false, false]; // Buffer last 5 movement samples
  let bufferIndex = 0;
  
  // Regular check to ensure animation is playing
  let animationCheckTimer = 0;
  
  // Load player model
  const loader = new GLTFLoader();
  loader.load('/models/playermodel.glb', (gltf) => {
    console.log('Player model loaded:', gltf);
    
    // Store the model for later use
    playerModel = gltf.scene;
    
    // Set up animation mixer
    mixer = new THREE.AnimationMixer(playerModel);
    
    // Process animations
    gltf.animations.forEach((clip) => {
      // Create actions for each animation clip
      if (mixer) {
        const action = mixer.clipAction(clip);
        
        // Store by name for easier access
        if (clip.name.toLowerCase().includes('idle')) {
          animations.set(AnimationState.IDLE, action);
          console.log(`Animation loaded: ${clip.name} (IDLE)`);
        } else if (clip.name.toLowerCase().includes('walk')) {
          animations.set(AnimationState.WALKING, action);
          console.log(`Animation loaded: ${clip.name} (WALKING)`);
        } else {
          console.log(`Other animation loaded: ${clip.name}`);
        }
      }
    });
    
    // Configure all animations
    animations.forEach(action => {
      // Ensure animations loop infinitely and never stop
      action.setLoop(THREE.LoopRepeat, Infinity);
      action.clampWhenFinished = false;
      action.timeScale = 1;
      action.setEffectiveWeight(1);
      action.enabled = true;
      
      // Disable automatic deactivation
      action.zeroSlopeAtEnd = false;
      action.zeroSlopeAtStart = false;
    });
    
    // Add model to scene and player
    if (playerModel) {
      // Scale and position adjustments
      playerModel.scale.set(1, 1, 1);
      
      // Get player entity and attach model to player
      const playerEntities = playerQuery(world);
      if (playerEntities.length > 0) {
        const pid = playerEntities[0];
        const holder = world.ctx.maps.mesh.get(pid);
        
        if (holder) {
          // Position the model relative to the player's position
          // Fix: Adjust Y position to prevent sinking into ground
          playerModel.position.set(0, -0.9, 0);
          playerModel.rotation.y = Math.PI; // Face the camera by default
          
          // Add model to player holder
          holder.add(playerModel);
          
          // Log bone names for debugging/reference
          console.log("--------- BONE NAMES ---------");
          playerModel.traverse((object) => {
            if (object instanceof THREE.Bone) {
              console.log("Bone:", object.name);
            }
          });
          
          // Start with idle animation
          setAnimation("idle");
        }
      }
    }
  });
  
  // Simple animation switch without complex crossfading
  function setAnimation(state: string) {
    // Ignore if we're already in this state or animations not loaded
    if (state === movementState || !animations.has(state === "walking" ? AnimationState.WALKING : AnimationState.IDLE)) {
      return;
    }
    
    // Update state
    movementState = state;
    console.log(`Changing animation to ${state}`);
    
    // Get the new animation
    let newAction: THREE.AnimationAction | null = null;
    
    if (state === "walking") {
      const walkAction = animations.get(AnimationState.WALKING);
      if (walkAction) {
        newAction = walkAction;
      }
    } else {
      const idleAction = animations.get(AnimationState.IDLE);
      if (idleAction) {
        newAction = idleAction;
      }
    }
    
    // Only proceed if we have a valid action
    if (!newAction) return;
    
    // Fade between animations - smoother transition
    if (activeAction && activeAction !== newAction) {
      // Prepare new action
      newAction.reset();
      newAction.setEffectiveWeight(1);
      newAction.enabled = true;
      newAction.play();
      
      // Fade from current to new
      newAction.crossFadeFrom(activeAction, 0.2, true);
    } else {
      // First animation or direct switch
      newAction.enabled = true;
      newAction.reset();
      newAction.play();
    }
    
    // Update current animation state
    activeAction = newAction;
    currentAnimation = state === "walking" ? AnimationState.WALKING : AnimationState.IDLE;
    
    // Set timeout before next state change is allowed
    movementTimer = 0.3; // 300ms debounce
  }
  
  // Ensure an animation is playing (fallback to idle)
  function ensureAnimationPlaying() {
    if (!mixer || !animations.size) return;
    
    // Check if any action is currently running
    let isAnimationActive = false;
    
    // Check if the active action is properly running
    if (activeAction && activeAction.isRunning()) {
      isAnimationActive = true;
    }
    
    if (!isAnimationActive) {
      console.log("No active animation detected, resetting to idle");
      
      // Force idle animation to play
      const idleAction = animations.get(AnimationState.IDLE);
      if (idleAction) {
        // Stop all potentially paused actions
        mixer.stopAllAction();
        
        // Reset action state
        idleAction.reset();
        idleAction.setEffectiveWeight(1);
        idleAction.enabled = true;
        idleAction.play();
        
        // Update current state
        activeAction = idleAction;
        currentAnimation = AnimationState.IDLE;
        movementState = "idle";
      }
    }
  }
  
  // Check if player is moving based on position buffer
  function isPlayerMoving() {
    // Count true values in buffer
    const movingFrames = movementBuffer.filter(moving => moving).length;
    // Consider moving if at least 3 of the last 5 frames showed movement
    return movingFrames >= 3;
  }
  
  return (w: ECS) => {
    // Update timers
    if (movementTimer > 0) {
      movementTimer -= w.time.dt;
    }
    
    // Increment animation check timer
    animationCheckTimer += w.time.dt;
    
    // Only continue if animations are loaded
    if (!mixer || !playerModel) {
      return w;
    }
    
    // Check animation state regularly to prevent T-pose
    if (animationCheckTimer > 1.0) { // Check every second
      ensureAnimationPlaying();
      animationCheckTimer = 0;
    }
    
    // Update animation mixer
    mixer.update(w.time.dt);
    
    // Process all player entities (usually just one)
    for (const eid of playerQuery(w)) {
      const holder = w.ctx.maps.mesh.get(eid);
      
      if (holder) {
        // Initialize previous position if needed
        if (!w.time.prevPlayerPos) {
          w.time.prevPlayerPos = new THREE.Vector3(holder.position.x, holder.position.y, holder.position.z);
          continue; // Skip this frame as we need two positions to compare
        }
        
        // Calculate horizontal movement (ignore Y)
        const deltaX = holder.position.x - w.time.prevPlayerPos.x;
        const deltaZ = holder.position.z - w.time.prevPlayerPos.z;
        const movementSq = deltaX * deltaX + deltaZ * deltaZ;
        
        // Store in moving buffer (true if moving, false if not)
        movementBuffer[bufferIndex] = movementSq > 0.0005;
        bufferIndex = (bufferIndex + 1) % movementBuffer.length;
        
        // Determine movement state
        const isMoving = isPlayerMoving();
        
        // Only change animation if debounce timer is up
        if (movementTimer <= 0) {
          if (isMoving && movementState !== "walking") {
            setAnimation("walking");
          } else if (!isMoving && movementState !== "idle") {
            setAnimation("idle");
          }
        }
        
        // Store current position for next frame
        w.time.prevPlayerPos.set(holder.position.x, holder.position.y, holder.position.z);
      }
    }
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/player/index.ts
================================================
/**
 * Main player system that initializes and combines movement, look and shoot sub-systems
 */
import { addComponent, addEntity } from 'bitecs';
import * as THREE from 'three';
import {
  MeshRef, Player, RigidBodyRef, Transform, FPController
} from '../../components';
import { ECS } from '../../world';
import { MovementState } from '../../config';
import { initPlayerMovementSystem } from './movementSystem';
import { initPlayerLookSystem } from './lookSystem';
import { initPlayerShootSystem } from './shootSystem';
import { initPlayerAnimationSystem } from './animationSystem';

export function initPlayerSystem(world: ECS) {
  const { rapier, physics, three, maps } = world.ctx;

  /* entity + mesh holder ------------------------------------------- */
  const pid = addEntity(world);
  addComponent(world, Player,       pid);
  addComponent(world, Transform,    pid);
  addComponent(world, MeshRef,      pid);
  addComponent(world, RigidBodyRef, pid);
  addComponent(world, FPController, pid);
  
  // Initialize controller state
  FPController.pitch[pid] = 0;
  FPController.vertVel[pid] = 0;
  FPController.moveState[pid] = MovementState.GROUNDED;
  FPController.lastGrounded[pid] = performance.now();
  FPController.lastJump[pid] = 0;
  FPController.lastShot[pid] = 0;
  FPController.jumpRequested[pid] = 0;
  FPController.lastJumpRequest[pid] = 0;

  const holder = new THREE.Object3D();
  holder.position.set(0, 3, 6);
  three.scene.add(holder);
  maps.mesh.set(pid, holder);

  // Position the camera in the holder
  const cameraOffset = new THREE.Object3D();
  cameraOffset.position.set(0, 1.6, 0); // Eye height of ~1.6m
  holder.add(cameraOffset);
  cameraOffset.add(three.camera);

  /* Rapier kinematic capsule --------------------------------------- */
  const rb = physics.createRigidBody(
    rapier.RigidBodyDesc.kinematicPositionBased()
          .setTranslation(holder.position.x, holder.position.y, holder.position.z)
          .setCcdEnabled(true)
  );
  const collider = physics.createCollider(
    rapier.ColliderDesc.capsule(0.9, 0.3).setFriction(0.2), rb
  );

  const kcc = physics.createCharacterController(0.01);
  kcc.setApplyImpulsesToDynamicBodies(true);
  kcc.setUp({ x: 0, y: 1, z: 0 });
  kcc.enableAutostep(0.5, 0.3, true);
  kcc.enableSnapToGround(0.3);

  maps.rb.set(pid, rb);
  RigidBodyRef.id[pid] = rb.handle;
  
  // Store KCC and collider for use in movement system
  world.ctx.kcc = kcc;
  world.ctx.playerCollider = collider;

  // Initialize sub-systems
  const movementSystem = initPlayerMovementSystem(world);
  const lookSystem = initPlayerLookSystem(world);
  const shootSystem = initPlayerShootSystem(world);
  const animationSystem = initPlayerAnimationSystem(world);

  /* Combined system ------------------------------------------------- */
  return (w: ECS) => {
    // Run all sub-systems in sequence
    lookSystem(w);
    movementSystem(w);
    shootSystem(w);
    animationSystem(w);
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/player/lookSystem.ts
================================================
/**
 * Player look system - handles camera movement via mouse input
 */
import { defineQuery } from 'bitecs';
import * as THREE from 'three';
import { Player, FPController } from '../../components';
import { ECS } from '../../world';
import { InputState } from '../input';
import { PlayerConfig } from '../../config';

export function initPlayerLookSystem(_world: ECS) {
  const playerQuery = defineQuery([Player, FPController]);

  return (w: ECS) => {
    const input = w.input as InputState;
    // Input check removed - initInputSystem is guaranteed to run first

    // Skip if pointer isn't locked
    if (!input.pointerLocked) {
      input.dx = input.dy = 0;
      return w;
    }

    for (const eid of playerQuery(w)) {
      // Get the player object that holds the camera
      const holder = w.ctx.maps.mesh.get(eid);
      if (!holder) continue;
      
      // Update yaw (horizontal rotation)
      holder.rotation.y = (holder.rotation.y - input.dx * PlayerConfig.MOUSE_SENSITIVITY) % (Math.PI * 2);
      if (holder.rotation.y < 0) holder.rotation.y += Math.PI * 2;

      // Update pitch (vertical look) with clamping
      FPController.pitch[eid] = THREE.MathUtils.clamp(
        FPController.pitch[eid] - input.dy * PlayerConfig.MOUSE_SENSITIVITY, 
        -Math.PI / 2,  // Look up limit
        Math.PI / 2    // Look down limit
      );
      
      // Apply pitch to camera
      const camera = w.ctx.three.camera;
      if (camera) {
        camera.rotation.x = FPController.pitch[eid];
      }
    }
    
    // Reset mouse deltas after processing
    input.dx = input.dy = 0;
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/player/movementSystem.ts
================================================
/**
 * Player movement system - handles movement, jumping, and physics integration
 */
import { defineQuery } from 'bitecs';
import { Player, RigidBodyRef, FPController } from '../../components';
import { ECS } from '../../world';
import { InputState } from '../input';
import { vec2Pool, vec3Pool } from '../../utils/mathUtils';
import { PlayerConfig, MovementState } from '../../config';

export function initPlayerMovementSystem(_world: ECS) {
  const playerQuery = defineQuery([Player, RigidBodyRef, FPController]);
  
  // Reused vector objects to avoid allocations
  const dir = vec3Pool.get();
  const horiz = vec2Pool.get();
  
  // Track the previous jump state to require releasing space before jumping again
  let prevJump = false;

  return (w: ECS) => {
    const input = w.input as InputState;
    // Input check removed - initInputSystem is guaranteed to run first
    
    const now = performance.now();
    
    for (const eid of playerQuery(w)) {
      const rb = w.ctx.maps.rb.get(eid);
      const kcc = w.ctx.kcc; // Character controller from player init
      const playerCollider = w.ctx.playerCollider;
      
      // Skip if we don't have all required components
      if (!rb || !kcc || !playerCollider) continue;
      
      // Get the player mesh holder
      const holder = w.ctx.maps.mesh.get(eid);
      if (!holder) continue;
      
      /* movement state + gravity ------------------------------------- */
      const grounded = kcc.computedGrounded();
      if (grounded) FPController.lastGrounded[eid] = now;

      if (grounded) {
        FPController.moveState[eid] = MovementState.GROUNDED;
      } else {
        FPController.moveState[eid] = FPController.vertVel[eid] > 0 ? 
          MovementState.JUMPING : MovementState.FALLING;
      }
      
      // Handle jump buffering - store jump request timing
      // Only allow a new jump request if space was released since last jump
      const jumpPressed = input.jump && !prevJump;
      if (jumpPressed && FPController.jumpRequested[eid] === 0) {
        FPController.jumpRequested[eid] = 1;
        FPController.lastJumpRequest[eid] = now;
      } else if (!input.jump) {
        FPController.jumpRequested[eid] = 0;
      }

      // Check if we can jump with either direct input or buffered input
      const canJump = (grounded || now - FPController.lastGrounded[eid] < PlayerConfig.COYOTE_MS) && 
                      now - FPController.lastJump[eid] > PlayerConfig.JUMP_CD_MS;
      
      // Execute jump if conditions met, including buffered jumps
      if (canJump && (jumpPressed || (now - FPController.lastJumpRequest[eid] < PlayerConfig.JUMP_BUFFER_MS))) {
        FPController.vertVel[eid] = PlayerConfig.JUMP_VEL;
        FPController.lastJump[eid] = now;
        FPController.jumpRequested[eid] = 0;
      }

      // Store previous jump state for next frame
      prevJump = input.jump;

      if (FPController.moveState[eid] !== MovementState.GROUNDED) {
        // Apply gravity with framerate-independent scaling
        FPController.vertVel[eid] = Math.max(
          FPController.vertVel[eid] - PlayerConfig.GRAVITY * w.time.dt, 
          PlayerConfig.TERMINAL_FALL
        );
      } else {
        FPController.vertVel[eid] *= 0.8;
        if (Math.abs(FPController.vertVel[eid]) < 0.1) FPController.vertVel[eid] = 0;
      }

      /* directional input -------------------------------------------- */
      dir.set(
        (input.rt ? 1 : 0) - (input.lf ? 1 : 0),
        0,
        (input.bk ? 1 : 0) - (input.fw ? 1 : 0)
      );
      
      if (dir.lengthSq() > 0) dir.normalize();
      
      // Get a temporary up vector, use it, then release it
      const upVector = vec3Pool.get().set(0, 1, 0);
      dir.applyAxisAngle(upVector, holder.rotation.y);
      vec3Pool.release(upVector);

      // Base speed calculation
      const speed = PlayerConfig.WALK_SPEED *
                    (FPController.moveState[eid] === MovementState.GROUNDED ? 
                      1 : PlayerConfig.AIR_CONTROL) *
                    (input.sprint ? PlayerConfig.SPRINT_FACTOR : 1);

      horiz.set(dir.x * speed, dir.z * speed);

      /* KCC integration ---------------------------------------------- */
      // Always scale movement by delta time for frame independence
      const dt = w.time.shouldRunPhysics ? w.time.fixedDt! : w.time.dt;
      
      const requested = {
        x: horiz.x * dt,
        y: FPController.vertVel[eid] * dt,
        z: horiz.y * dt
      };
      
      // Now safe to use playerCollider since we checked it above
      kcc.computeColliderMovement(playerCollider, requested);
      const actual = kcc.computedMovement();

      if (FPController.vertVel[eid] > 0 && actual.y < requested.y * 0.9) {
        FPController.vertVel[eid] = 0; // head hit
      }

      const p = rb.translation();
      rb.setNextKinematicTranslation({
        x: p.x + actual.x,
        y: p.y + actual.y,
        z: p.z + actual.z
      });
      
      holder.position.set(p.x + actual.x, p.y + actual.y, p.z + actual.z);
    }
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/player/shootSystem.ts
================================================
/**
 * Player shooting system - handles weapon firing
 */
import { addComponent, addEntity, defineQuery } from 'bitecs';
import * as THREE from 'three';
import { Player, FPController, Projectile, Lifespan, Velocity, MeshRef, RigidBodyRef, Transform } from '../../components';
import { ECS } from '../../world';
import { InputState } from '../input';
import { vec3Pool } from '../../utils/mathUtils';
import { WeaponConfig } from '../../config';

export function initPlayerShootSystem(_world: ECS) {
  const playerQuery = defineQuery([Player, FPController]);
  
  // Track the previous shoot state to detect start of shooting
  let prevShoot = false;

  return (w: ECS) => {
    const input = w.input as InputState;
    // Input check removed - initInputSystem is guaranteed to run first
    
    const now = performance.now();
    
    for (const eid of playerQuery(w)) {
      // Detect shoot button pressed (not held)
      const shootStart = input.shoot && !prevShoot;
      
      if (shootStart && now - FPController.lastShot[eid] > WeaponConfig.SHOOT_CD_MS) {
        spawnBullet(w, w.ctx.three.camera, w.ctx.rapier);
        FPController.lastShot[eid] = now;
      }
    }
    
    // Store shoot state for next frame
    prevShoot = input.shoot;
    
    return w;
  };
}

/* bullet helper ---------------------------------------------------- */
function spawnBullet(
  w: ECS, camera: THREE.Camera,
  R: typeof import('@dimforge/rapier3d-compat')
) {
  const { physics, maps } = w.ctx;

  const eid = addEntity(w);
  addComponent(w, Projectile,   eid);
  addComponent(w, Lifespan,     eid);
  addComponent(w, RigidBodyRef, eid);
  addComponent(w, MeshRef,      eid);
  addComponent(w, Transform,    eid);
  // Velocity component is for future client-side prediction
  addComponent(w, Velocity,     eid);

  Lifespan.ttl[eid]  = WeaponConfig.BULLET_TTL_MS;
  Lifespan.born[eid] = performance.now();

  /* mesh */
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(0.1, 8, 8),
    new THREE.MeshStandardMaterial({
      color: 0xff9900, roughness: 0.3, metalness: 0.7,
      emissive: 0xff9900, emissiveIntensity: 0.5
    })
  );
  mesh.castShadow = true;

  // Get direction from camera (reuse vectors)
  const dir = vec3Pool.get();
  camera.getWorldDirection(dir).normalize();
  
  // Get spawn position (reuse vectors)
  const spawn = vec3Pool.get();
  camera.getWorldPosition(spawn).addScaledVector(dir, WeaponConfig.BULLET_SPAWN_DISTANCE);
  
  // Apply to mesh
  mesh.position.copy(spawn);

  // Add to scene
  w.ctx.three.scene.add(mesh);
  maps.mesh.set(eid, mesh);

  /* rigid body */
  // Store velocity for client-side prediction
  Velocity.x[eid] = dir.x * WeaponConfig.BULLET_SPEED;
  Velocity.y[eid] = dir.y * WeaponConfig.BULLET_SPEED;
  Velocity.z[eid] = dir.z * WeaponConfig.BULLET_SPEED;

  // Create a rigid body with CCD enabled to prevent tunneling at high speeds
  const rb = physics.createRigidBody(
    R.RigidBodyDesc.dynamic()
      .setTranslation(spawn.x, spawn.y, spawn.z)
      .setCcdEnabled(true)
      .setLinvel(dir.x * WeaponConfig.BULLET_SPEED, 
                dir.y * WeaponConfig.BULLET_SPEED, 
                dir.z * WeaponConfig.BULLET_SPEED)
  );

  // Create a small spherical collider
  physics.createCollider(
    R.ColliderDesc.ball(0.1)
      .setDensity(2.0)
      .setFriction(0.0)
      .setRestitution(0.2),
    rb
  );

  maps.rb.set(eid, rb);
  RigidBodyRef.id[eid] = rb.handle;
  
  // Release pooled vectors
  vec3Pool.release(dir);
  vec3Pool.release(spawn);
} 

================================================
File: /src/ecs/systems/projectile.ts
================================================
import { defineQuery, removeEntity } from 'bitecs';
import { Lifespan, Projectile } from '../components';
import { ECS } from '../world';
import * as THREE from 'three';

export function initProjectileSystem(_world: ECS) {
  const projectileQuery = defineQuery([Projectile, Lifespan]);
  
  return (w: ECS) => {
    const now = performance.now();
    
    // Create a list of entities to remove to avoid modifying during iteration
    const entitiesToRemove: number[] = [];
    
    // Process bullet lifetimes and handle destruction
    for (const eid of projectileQuery(w)) {
      // Skip processing if already marked for removal
      if (entitiesToRemove.includes(eid)) continue;
      
      // Get rigid body reference
      const rb = w.ctx.maps.rb.get(eid);
      if (!rb) {
        // Body reference invalid, mark for removal
        entitiesToRemove.push(eid);
        continue;
      }
      
      // Skip if body is no longer valid (prevents "unreachable" errors)
      try {
        // Just check if we can access a property - will throw if body is invalid
        rb.handle;
      } catch (error) {
        // Something's wrong with this rigid body, mark for removal
        console.warn("Invalid rigid body detected, removing entity", eid);
        entitiesToRemove.push(eid);
        continue;
      }
      
      // Check if bullet should be removed due to lifetime
      const expired = now - Lifespan.born[eid] > Lifespan.ttl[eid];
      
      // Check if bullet was marked for deletion by collision system
      const mesh = w.ctx.maps.mesh.get(eid);
      const markedForDeletion = mesh?.userData?.markedForDeletion === true;
      
      // Mark for removal if expired or deletion requested
      if (expired || markedForDeletion) {
        entitiesToRemove.push(eid);
      }
    }
    
    // Remove all entities marked for deletion
    for (const eid of entitiesToRemove) {
      // Get and remove the mesh
      const mesh = w.ctx.maps.mesh.get(eid);
      if (mesh) {
        w.ctx.three.scene.remove(mesh);
        
        // Properly cast to THREE.Mesh to access geometry and material
        if (mesh instanceof THREE.Mesh) {
          if (mesh.geometry) {
            mesh.geometry.dispose();
          }
          
          if (mesh.material) {
            // Handle both single and array materials
            if (Array.isArray(mesh.material)) {
              mesh.material.forEach(material => {
                if (material) material.dispose();
              });
            } else {
              mesh.material.dispose();
            }
          }
        }
        
        w.ctx.maps.mesh.delete(eid);
      }
      
      // Get and remove the rigid body
      const rb = w.ctx.maps.rb.get(eid);
      if (rb) {
        w.ctx.physics.removeRigidBody(rb);
        w.ctx.maps.rb.delete(eid);
      }
      
      // Remove the entity
      removeEntity(w, eid);
    }
    
    return w;
  };
}


================================================
File: /src/ecs/systems/renderSync.ts
================================================
/**********************************************************************
 * renderSync.ts – sync Three meshes with Rapier bodies each frame
 *********************************************************************/
import { defineQuery, hasComponent, exitQuery } from 'bitecs';
import { ECS } from '../world';
import {
  MeshRef, RigidBodyRef, Transform, Player, Projectile
} from '../components';
import { vec3Pool, quatPool, interpolatePositions, interpolateRotations } from '../utils/mathUtils';

export function initRenderSyncSystem(_world: ECS) {
  const q = defineQuery([MeshRef]);
  const rbQuery = defineQuery([MeshRef, RigidBodyRef]);
  
  // Listen for entity deletions with MeshRef component
  const exitMeshQuery = exitQuery(q);
  
  // Storage for previous physics state for interpolation
  const prevPositions = new Map<number, THREE.Vector3>();
  const prevRotations = new Map<number, THREE.Quaternion>();

  return (w: ECS) => {
    // First, handle entity removal through bitECS exitQuery
    for (const eid of exitMeshQuery(w)) {
      // Clean up interpolation data for removed entities
      prevPositions.delete(eid);
      prevRotations.delete(eid);
      
      // Remove from entity handle map if present
      if (w.ctx.entityHandleMap) {
        // Find and remove any entry for this entity ID
        for (const [handle, entityId] of w.ctx.entityHandleMap.entries()) {
          if (entityId === eid) {
            w.ctx.entityHandleMap.delete(handle);
            break;
          }
        }
      }
    }
    
    // Then handle entities marked for deletion
    for (const eid of q(w)) {
      const mesh = w.ctx.maps.mesh.get(eid);
      if (mesh?.userData?.markedForDeletion) {
        // Clean up interpolation data only
        prevPositions.delete(eid);
        prevRotations.delete(eid);
      }
    }
    
    // Alpha for interpolation (0.0 to 1.0)
    const isHighRefreshRate = w.time.dt < 0.01; // Detecting high refresh (>100Hz)
    const alpha = isHighRefreshRate ? 
                  // Less interpolation on high refresh for sharper image
                  Math.min(0.5, w.time.alpha || 0) :
                  // Standard interpolation on normal refresh
                  (w.time.alpha !== undefined ? w.time.alpha : 0);
    
    // Get reusable vectors/quaternions
    const currentPos = vec3Pool.get();
    const currentRot = quatPool.get();
    
    for (const eid of rbQuery(w)) {
      const mesh = w.ctx.maps.mesh.get(eid)!;
      const rb   = w.ctx.maps.rb.get(eid); 
      
      if (!rb) continue;

      // Handle physics-driven objects that aren't the player
      if (!hasComponent(w, Player, eid)) {
        const p = rb.translation();
        const r = rb.rotation();
        
        // Set current position/rotation
        currentPos.set(p.x, p.y, p.z);
        currentRot.set(r.x, r.y, r.z, r.w);
        
        // Initialize previous state on first frame
        if (!prevPositions.has(eid)) {
          prevPositions.set(eid, currentPos.clone());
        }
        if (!prevRotations.has(eid)) {
          prevRotations.set(eid, currentRot.clone());
        }
        
        // Get previous state
        const prevPos = prevPositions.get(eid)!;
        const prevRot = prevRotations.get(eid)!;
        
        // Update previous state only when physics runs
        if (w.time.shouldRunPhysics) {
          prevPos.copy(currentPos);
          prevRot.copy(currentRot);
        }
        
        // On fast-moving objects, reduce interpolation to prevent blur
        const vel = rb.linvel ? rb.linvel() : null;
        const isMovingFast = vel && (vel.x*vel.x + vel.y*vel.y + vel.z*vel.z > 100);
        
        // Skip interpolation entirely for fast-moving objects (like bullets)
        // to avoid the quaternion slerp overhead - just use current position directly
        if (isMovingFast || hasComponent(w, Projectile, eid)) {
          mesh.position.set(currentPos.x, currentPos.y, currentPos.z);
          mesh.quaternion.set(currentRot.x, currentRot.y, currentRot.z, currentRot.w);
        } else {
          // Standard interpolation for normal objects
          const objectAlpha = isHighRefreshRate ? 0.3 : alpha;
          interpolatePositions(mesh.position, prevPos, currentPos, objectAlpha);
          interpolateRotations(mesh.quaternion, prevRot, currentRot, objectAlpha);
        }
        
        continue;
      }

      // Handle the player capsule (position only)
      if (hasComponent(w, Player, eid)) {
        const p = rb.translation();
        
        // Player movement uses same interpolation technique
        currentPos.set(p.x, p.y, p.z);
        
        // Initialize previous state on first frame
        if (!prevPositions.has(eid)) {
          prevPositions.set(eid, currentPos.clone());
        }
        
        // Get previous state
        const prevPos = prevPositions.get(eid)!;
        
        // Update previous state only when physics runs
        if (w.time.shouldRunPhysics) {
          prevPos.copy(currentPos);
        }
        
        // For player, use minimal interpolation on high refresh rate
        const playerAlpha = isHighRefreshRate ? Math.min(0.3, alpha) : alpha;
        
        // Interpolate player position
        interpolatePositions(mesh.position, prevPos, currentPos, playerAlpha);
        continue;
      }
    }

    // Handle remaining kinematic meshes - write transform back into ECS 
    for (const eid of q(w)) {
      // Skip if it has a rigid body (already processed above)
      if (hasComponent(w, RigidBodyRef, eid)) continue;
      
      const mesh = w.ctx.maps.mesh.get(eid)!;
      
      // Use pooled vectors
      const pos = vec3Pool.get();
      const quat = quatPool.get();
      
      mesh.getWorldPosition(pos);
      mesh.getWorldQuaternion(quat);

      Transform.x[eid]  = pos.x;
      Transform.y[eid]  = pos.y;
      Transform.z[eid]  = pos.z;
      Transform.qx[eid] = quat.x;
      Transform.qy[eid] = quat.y;
      Transform.qz[eid] = quat.z;
      Transform.qw[eid] = quat.w;
      
      // Release pooled vectors
      vec3Pool.release(pos);
      quatPool.release(quat);
    }
    
    // Release pooled vectors used for the loop
    vec3Pool.release(currentPos);
    quatPool.release(currentRot);
    
    return w;
  };
}


================================================
File: /src/ecs/systems/timeStep.ts
================================================
/**
 * Time step system that manages fixed time steps for physics
 */
import { ECS } from '../world';
import { updateFixedTimestep } from '../timeUtils';
import { TimeStepConfig } from '../config';

// Fixed timestep configuration constants are now directly imported from TimeStepConfig

export function initTimeStepSystem(_world: ECS) {
  return (w: ECS) => {
    // Calculate delta time in seconds
    const now = performance.now();
    // Use a minimum delta time to prevent tiny stutters during fast displays
    const dt = Math.max(TimeStepConfig.MIN_DT, (now - w.time.then) * 0.001); // Convert ms to seconds
    w.time.then = now;
    w.time.dt = dt;
    
    // Update fixed timestep values
    updateFixedTimestep(w, dt);
    
    return w;
  };
} 

================================================
File: /src/ecs/timeUtils.ts
================================================
/**
 * Time utilities for managing fixed timestep and frame timing
 */
import { ECS } from './world';
import { TimeStepConfig } from './config';

/**
 * Update time accumulator and calculate physics steps
 */
export function updateFixedTimestep(world: ECS, deltaTime: number): void {
  // Cap deltaTime to prevent jumps after pauses/tab switches
  const dt = Math.min(deltaTime, TimeStepConfig.MAX_FRAME_TIME);
  
  // Add to accumulator
  world.time.accumulator += dt;
  
  // Calculate how many physics steps to take
  const steps = Math.floor(world.time.accumulator / TimeStepConfig.FIXED_DT);
  const clampedSteps = Math.min(steps, TimeStepConfig.MAX_STEPS);
  
  // Store in world time
  world.time.shouldRunPhysics = clampedSteps > 0;
  world.time.physicsSteps = clampedSteps;
  world.time.fixedDt = TimeStepConfig.FIXED_DT;
  
  // Calculate interpolation alpha
  if (steps > 0) {
    world.time.accumulator -= clampedSteps * TimeStepConfig.FIXED_DT;
    world.time.alpha = world.time.accumulator / TimeStepConfig.FIXED_DT;
  } else {
    world.time.alpha = 0;
  }
} 

================================================
File: /src/ecs/utils/eventUtils.ts
================================================
/**
 * Event utility functions for proper listener management
 */

// Track attached listeners for cleanup
const attachedListeners: Array<{
  target: EventTarget;
  type: string;
  listener: EventListenerOrEventListenerObject;
  options?: boolean | AddEventListenerOptions;
}> = [];

/**
 * Safely attach an event listener with tracking for easy cleanup
 * @param target The EventTarget to attach to (window, document, etc.)
 * @param type Event type (click, keydown, etc.)
 * @param listener The event listener function
 * @param options Optional addEventListener options
 */
export function safeAddEventListener(
  target: EventTarget,
  type: string,
  listener: EventListenerOrEventListenerObject,
  options?: boolean | AddEventListenerOptions
): void {
  target.addEventListener(type, listener, options);
  attachedListeners.push({ target, type, listener, options });
}

/**
 * Remove all previously attached event listeners
 */
export function removeAllEventListeners(): void {
  for (const { target, type, listener, options } of attachedListeners) {
    target.removeEventListener(type, listener, options);
  }
  attachedListeners.length = 0;
}

/**
 * Setup handlers to clean up event listeners on page unload
 */
export function setupEventCleanup(): void {
  // Only set up once
  if ((window as any).__eventCleanupInitialized) return;
  
  window.addEventListener('beforeunload', removeAllEventListeners);
  (window as any).__eventCleanupInitialized = true;
} 

================================================
File: /src/ecs/utils/mathUtils.ts
================================================
/**
 * Math utilities including vector/quaternion pooling
 */
import * as THREE from 'three';

// Default pool size configuration
export const ObjectPoolConfig = {
  INITIAL_SIZE: 20  // Reduced from 50 to conserve memory
};

// A simple vector/quaternion pool to avoid allocations
class ObjectPool<T> {
  private pool: T[] = [];
  private createFn: () => T;
  private resetFn: (obj: T) => void;
  
  constructor(createFn: () => T, resetFn: (obj: T) => void, initialSize = ObjectPoolConfig.INITIAL_SIZE) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    
    // Pre-allocate initial pool
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn());
    }
  }
  
  get(): T {
    if (this.pool.length === 0) {
      return this.createFn();
    }
    return this.pool.pop()!;
  }
  
  release(obj: T): void {
    this.resetFn(obj);
    this.pool.push(obj);
  }
}

// Vector3 pool
export const vec3Pool = new ObjectPool<THREE.Vector3>(
  () => new THREE.Vector3(),
  (v) => v.set(0, 0, 0)
);

// Quaternion pool
export const quatPool = new ObjectPool<THREE.Quaternion>(
  () => new THREE.Quaternion(),
  (q) => q.set(0, 0, 0, 1)
);

// Euler pool
export const eulerPool = new ObjectPool<THREE.Euler>(
  () => new THREE.Euler(),
  (e) => e.set(0, 0, 0)
);

// Vector2 pool
export const vec2Pool = new ObjectPool<THREE.Vector2>(
  () => new THREE.Vector2(),
  (v) => v.set(0, 0)
);

// Interpolation helpers
export function interpolatePositions(
  dest: THREE.Vector3,
  prev: THREE.Vector3, 
  current: THREE.Vector3, 
  alpha: number
): THREE.Vector3 {
  return dest.lerpVectors(prev, current, alpha);
}

export function interpolateRotations(
  dest: THREE.Quaternion,
  prev: THREE.Quaternion, 
  current: THREE.Quaternion, 
  alpha: number
): THREE.Quaternion {
  return dest.slerpQuaternions(prev, current, alpha);
}

// Convert numeric tuple to BigInt64 for use as map key
export function createEntityPairKey(a: number, b: number): bigint {
  // Ensure a < b to make the key consistent regardless of order
  if (a > b) [a, b] = [b, a];
  
  // Convert to BigInt and combine into single 64-bit value
  // This allows for efficient storage without string conversions
  return (BigInt(a) << 32n) | BigInt(b & 0xFFFFFFFF);
}

/**
 * Get direction vector from one point to another
 * @param fromPos Starting position
 * @param toPos Target position
 * @param outVec Optional output vector (if not provided, one will be pooled)
 * @returns Normalized direction vector (caller must vec3Pool.release(outVec) when done)
 */
export function directionFromTo(
  fromPos: { x: number, y: number, z: number },
  toPos: { x: number, y: number, z: number },
  outVec = vec3Pool.get()
): THREE.Vector3 {
  return outVec.set(
    toPos.x - fromPos.x,
    toPos.y - fromPos.y,
    toPos.z - fromPos.z
  ).normalize();
} 

================================================
File: /src/ecs/world.ts
================================================
import { createWorld, pipe } from 'bitecs';
import { initInputSystem, InputState } from './systems/input.ts';
import { initPlayerSystem }    from './systems/player';
import { initProjectileSystem }from './systems/projectile.ts';
import { initPhysicsSystem }   from './systems/physics.ts';
import { initRenderSyncSystem }from './systems/renderSync.ts';
import { initDebugVisSystem }  from './systems/debugVis.ts';
import { initCollisionSystem } from './systems/collision.ts';
import { initTimeStepSystem }  from './systems/timeStep.ts';
import { initGrassSystem }     from './systems/grass.ts';
import * as THREE from 'three';

// Import Rapier types - use a type-only import to avoid runtime loading
import type * as RAPIER from '@dimforge/rapier3d-compat';

/** Create ECS world + pipeline */
export function createECS(ctx: ECSContext) {
  const world = createWorld() as ECS;
  world.ctx  = ctx;
  world.time = { 
    dt: 0, 
    then: performance.now(),
    accumulator: 0
  };
  
  // Create a collision event queue for Rapier
  const eventQueue = new ctx.rapier.EventQueue(true);
  world.ctx.eventQueue = eventQueue;

  const pipeline = pipe(
    initTimeStepSystem(world),  // Run first to manage fixed timestep
    initInputSystem(world),
    initPlayerSystem(world),
    initPhysicsSystem(world),   // Physics runs before collision system to process contacts
    initCollisionSystem(world), // Now handles Rapier collision events instead of raycasting
    initProjectileSystem(world),
    initGrassSystem(world),     // Add grass system
    initDebugVisSystem(world),
    initRenderSyncSystem(world)
  );

  return { world, pipeline };
}

/* -------------------------------------------------- */
/* Types shared with scene & systems                  */
export interface ECSContext {
  rapier: typeof RAPIER;
  physics: RAPIER.World;
  three: {
    scene: THREE.Scene;
    camera: THREE.Camera;
    renderer: THREE.WebGLRenderer;
  };
  maps: {
    rb: Map<number, RAPIER.RigidBody>;
    mesh: Map<number, THREE.Object3D>;
  };
  eventQueue?: RAPIER.EventQueue; 
  kcc?: RAPIER.KinematicCharacterController; 
  playerCollider?: RAPIER.Collider;
  entityHandleMap?: Map<number, number>; // Map from RB handle to entity ID
}

export interface ECS {
  ctx: ECSContext;
  time: {
    dt: number;
    then: number;
    accumulator: number;
    fixedDt?: number;
    alpha?: number;
    physicsSteps?: number;
    shouldRunPhysics?: boolean;
    prevPlayerPos?: THREE.Vector3; // Store previous player position for animation
  };
  input?: InputState;
}


================================================
File: /src/gameloop.ts
================================================
/**
 * Game loop module for managing main animation loop
 */
import Stats from 'three/examples/jsm/libs/stats.module.js';
import { ECS } from './ecs/world';

/**
 * Set up stats.js performance monitor
 */
export function setupStats(): Stats {
  const stats = new Stats();
  stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
  stats.dom.style.position = 'absolute';
  stats.dom.style.left = '0px';
  stats.dom.style.top = '0px';
  document.body.appendChild(stats.dom);
  return stats;
}

/**
 * Start the game loop
 */
export function startGameLoop(world: ECS, pipeline: (w: ECS) => ECS): void {
  const stats = setupStats();
  
  // Start animation loop
  const raf = (_t: number) => {
    // Begin stats measurement
    stats.begin();
    
    // Run all systems
    pipeline(world);
    
    // Render the scene
    world.ctx.three.renderer.render(world.ctx.three.scene, world.ctx.three.camera);
    
    // End stats measurement
    stats.end();
    
    // Request next frame
    requestAnimationFrame(raf);
  };
  
  // Start the loop
  requestAnimationFrame(raf);
} 

================================================
File: /src/main.ts
================================================
import * as RAPIER from '@dimforge/rapier3d-compat';
import { createContext, populateScene } from './ecs/scene';
import { createECS } from './ecs/world';
import { startGameLoop } from './gameloop';

/* canvas declared in /index.html */
const canvas = document.getElementById('c') as HTMLCanvasElement;

/**
 * Main application entry point
 */
async function main() {
  /* Initialize Rapier WASM module first */
  await RAPIER.init();
  
  /* bootstrap Three + Rapier context (physics world still empty) */
  const ctx = await createContext(canvas, RAPIER);

  /* create ECS world & system pipeline */
  const { world, pipeline } = createECS(ctx);

  /* now that ECS exists, spawn cubes & any other scene content */
  populateScene(world, ctx);
  
  /* Start the game loop */
  startGameLoop(world, pipeline);
}

// Initialize the application
main().catch(console.error);


================================================
File: /tsconfig.json
================================================
{
    "compilerOptions": {
      "target": "ES2020",
      "module": "ESNext",
      "lib": ["ES2020", "DOM"],
      "moduleResolution": "Bundler",
      "strict": true,
      "noImplicitReturns": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "skipLibCheck": true,
      "allowImportingTsExtensions": true,
      "noEmit": true,
      "types": ["vite/client"]
    },
    "include": ["src"]
  }
  

================================================
File: /vite.config.ts
================================================
import { defineConfig } from 'vite';
import wasm from 'vite-plugin-wasm';
import topLevelAwait from 'vite-plugin-top-level-await';

export default defineConfig({
  plugins: [wasm(), topLevelAwait()],
  build: { target: 'esnext' },
  server: { host: true }
});
    </codebase>
</context>


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


This is the codebase of the other game as reference.

<context>
    <codebase>
Directory structure:
└── /./
    ├── package.json
    ├── public/
    │   ├── css/
    │   │   └── style.css
    │   ├── dev.html
    │   ├── index.html
    │   ├── js/
    │   │   ├── bullet.js
    │   │   ├── chat.js
    │   │   ├── desertTerrain.js
    │   │   ├── effects.js
    │   │   ├── input.js
    │   │   ├── logger.js
    │   │   ├── main.js
    │   │   ├── multiplayerManager.js
    │   │   ├── network.js
    │   │   ├── networkManager.js
    │   │   ├── phantom-wallet.js
    │   │   ├── physics.js
    │   │   ├── player.js
    │   │   ├── playerIdentity.js
    │   │   ├── playerModel.js
    │   │   ├── scene.js
    │   │   ├── smokeRingEffect.js
    │   │   ├── soundManager.js
    │   │   ├── train-animation.js
    │   │   ├── tumbleweed.js
    │   │   ├── ui.js
    │   │   ├── viewmodel-config.js
    │   │   └── viewmodel.js
    │   ├── models/
    │   │   ├── bartender.glb
    │   │   ├── eagle.glb
    │   │   ├── playermodel.glb
    │   │   ├── sheriff.glb
    │   │   ├── textures/
    │   │   ├── town.glb
    │   │   ├── townold2.glb
    │   │   ├── train.glb
    │   │   ├── traincabin.glb
    │   │   ├── tumbleweed.glb
    │   │   ├── viewmodel.glb
    │   │   └── viewmodelold.glb
    │   ├── sounds/
    │   └── wallet-demo.html
    └── server.js

================================================
File: /package.json
================================================
{
  "name": "wild-western-shooter",
  "version": "1.0.0",
  "description": "A Three.js Wild Western Shooter game with a Node.js server.",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "@solana/wallet-adapter-base": "^0.9.24",
    "@solana/wallet-adapter-phantom": "^0.9.25",
    "@solana/web3.js": "^1.98.0",
    "cannon": "^0.6.2",
    "dotenv": "^16.4.7",
    "express": "^4.18.2",
    "ngrok": "^4.3.3",
    "node-telegram-bot-api": "^0.66.0",
    "ws": "^8.13.0"
  }
}


================================================
File: /public/css/style.css
================================================
/* Add this at the top to ensure proper fullscreen */
*, *::before, *::after {
  box-sizing: border-box;
}

body, html {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background-color: #000;
  font-family: 'Courier New', Courier, monospace;
  /* Ensure the canvas extends to the edge of the screen */
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

#game-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
  background-color: #000;
}

canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100% !important;
  height: 100% !important;
  margin: 0;
  padding: 0;
  display: block;
  background-color: #000;
}

#ammo-counter {
  position: absolute;
  bottom: 20px;
  right: 20px;
  color: white;
  font-size: 24px;
  background-color: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 5px;
}
#reload-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 24px;
  background-color: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 5px;
  display: none;
}
#reload-progress-container {
  position: absolute;
  bottom: 60px;
  right: 20px;
  width: 200px;
  height: 20px;
  background-color: rgba(0,0,0,0.5);
  border-radius: 10px;
  overflow: hidden;
  display: none;
}
#reload-progress-bar {
  height: 100%;
  width: 0%;
  background-color: #FF6B00;
  border-radius: 10px;
  transition: width 0.05s linear;
}
#crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  /* transform is now handled by inline style with !important */
  width: 80px;
  height: 80px;
  display: none; /* Will be controlled by JavaScript */
  pointer-events: none;
  z-index: 100;
  will-change: transform, opacity;
}

#crosshair svg {
  width: 100%;
  height: 100%;
}

/* Corner group style and transforms */
.corner-group {
  transform-origin: 50px 50px;
  opacity: 0;
  will-change: transform, opacity;
}

/* Center dot animation */
#crosshair circle {
  opacity: 0;
  will-change: opacity;
  transition: opacity 250ms cubic-bezier(0.2, 0.8, 0.2, 1);
}

#crosshair.expand circle {
  opacity: 1;
  transition-delay: 0ms; /* Fade in first */
}

#crosshair.expanded circle {
  opacity: 1;
}

#crosshair.contract circle {
  opacity: 0;
  transition-delay: 0ms; /* Immediate fade out instead of delayed */
}

/* Top corner animations */
@keyframes expand-top {
  0% {
    transform: translate(0, 35px) scale(0);
    opacity: 0;
  }
  100% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
}

@keyframes contract-top {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(0, 35px) scale(0);
    opacity: 0;
  }
}

/* Bottom left corner animations */
@keyframes expand-bottom-left {
  0% {
    transform: translate(30px, -25px) scale(0);
    opacity: 0;
  }
  100% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
}

@keyframes contract-bottom-left {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(30px, -25px) scale(0);
    opacity: 0;
  }
}

/* Bottom right corner animations */
@keyframes expand-bottom-right {
  0% {
    transform: translate(-30px, -25px) scale(0);
    opacity: 0;
  }
  100% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
}

@keyframes contract-bottom-right {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(-30px, -25px) scale(0);
    opacity: 0;
  }
}

/* Apply specific animations to each corner */
#crosshair.expand #top-corner {
  animation: expand-top 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.expand #bottom-left-corner {
  animation: expand-bottom-left 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.expand #bottom-right-corner {
  animation: expand-bottom-right 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.contract #top-corner {
  animation: contract-top 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.contract #bottom-left-corner {
  animation: contract-bottom-left 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.contract #bottom-right-corner {
  animation: contract-bottom-right 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

/* Set expanded state */
#crosshair.expanded #top-corner,
#crosshair.expanded #bottom-left-corner,
#crosshair.expanded #bottom-right-corner {
  opacity: 1;
  transform: translate(0, 0) scale(1);
}

/* Make all elements animate with the same timing function */
#crosshair path,
#crosshair g,
#crosshair circle {
  transition-property: opacity, transform;
  transition-duration: 250ms;
  transition-timing-function: cubic-bezier(0.2, 0.8, 0.2, 1);
}

/* Ensure elements fade out when contract class is present */
#crosshair.contract circle {
  opacity: 0;
  transition-delay: 0ms; /* Immediate fade out instead of delayed */
}

/* Make corner groups start contracting before center dot fades */
#crosshair.contract #top-corner {
  animation-delay: 50ms !important; /* Delay to start after dot begins fading */
}

#crosshair.contract #bottom-left-corner {
  animation-delay: 70ms !important; /* Slightly more delay */
}

#crosshair.contract #bottom-right-corner {
  animation-delay: 70ms !important; /* Slightly more delay */
}

/* Individual delays for staggered animation */
#top-corner {
  animation-delay: 50ms !important; /* Delayed after center dot appears */
}

#bottom-left-corner {
  animation-delay: 80ms !important; /* Delayed after center dot appears */
}

#bottom-right-corner {
  animation-delay: 80ms !important; /* Delayed after center dot appears */
}

/* SVG Line styles */
#crosshair line {
  stroke-linecap: round;
  transform-box: fill-box;
  transform-origin: center;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
}

/* Remove the above styles and add these instead */
#crosshair path {
  stroke-linecap: round;
  stroke-linejoin: round;
}

/* Force hardware acceleration for smoother animations */
#crosshair, #crosshair svg, #crosshair g, #crosshair path, #crosshair circle {
  -webkit-backface-visibility: hidden;
  backface-visibility: hidden;
  -webkit-perspective: 1000;
  perspective: 1000;
  -webkit-transform: translateZ(0);
  transform: translateZ(0);
}

#fps-counter {
  position: absolute;
  top: 20px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#player-count {
  position: absolute;
  top: 50px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#connection-status {
  position: absolute;
  top: 80px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#network-status {
  position: absolute;
  top: 80px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
  transition: opacity 1s;
}

/* Mobile-specific smoke ring */
@media (max-width: 1024px), (pointer: coarse) {
  #draw-circle {
    width: 150px;
    height: 150px;
    border-width: 4px;
    box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
  }
}


/* Fix font loading */
@font-face {
  font-family: 'Western';
  src: local('Georgia'), local('Times New Roman');
  font-weight: bold;
  font-style: normal;
}

/* Health counter styling */
#health-counter {
  display: none; /* Hide the problematic right UI panel */
}

/* Damage indicator (added dynamically) */
#damage-indicator {
  position: absolute;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: red;
  font-size: 48px;
  font-weight: bold;
  opacity: 0;
  text-shadow: 2px 2px 4px #000000;
  transition: opacity 0.3s ease-in, opacity 0.5s ease-out;
  z-index: 1000;
  pointer-events: none;
}

/* Different damage types */
.damage-headshot {
  color: #FF0000 !important;
  font-size: 64px !important;
}

.damage-body {
  color: #FF4500 !important;
}

.damage-limb {
  color: #FFA500 !important;
}

/* Health bar (alternative to text) */
#health-bar-container {
  display: none; /* Hide the health bar container as well */
}

/* Hit marker */
.hit-marker {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) rotate(45deg);
  pointer-events: none;
}

.hit-marker::before,
.hit-marker::after {
  content: '';
  position: absolute;
  background-color: white;
}

.hit-marker::before {
  width: 2px;
  height: 16px;
  left: 7px;
  top: 0;
}

.hit-marker::after {
  width: 8px;
  height: 2px;
  top: 7px;
  left: 4px;
}

/* Headshot marker */
.hit-marker-headshot::before,
.hit-marker-headshot::after {
  background-color: red;
}

/* Mobile support styles */
#touch-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 999;
  touch-action: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}

/* Add a CSS comment that shows the configurable constants for reference */
/* 
MOBILE CONTROLS CONFIGURATION CONSTANTS:
-------------------------------------
JUMP_BUTTON = {
  BOTTOM: 120,  // Distance from bottom edge
  RIGHT: 30,   // Distance from right edge
  SIZE: 60     // Button size
}

LEFT_JOYSTICK = {
  BOTTOM: 50,  // Distance from bottom edge
  LEFT: 50,    // Distance from left edge
  SIZE: 120    // Joystick size
}

RIGHT_JOYSTICK = {
  BOTTOM: 70,  // Distance from bottom edge
  RIGHT: 130,   // Distance from right edge
  SIZE: 100    // Joystick size
}

CAMERA_AREA = {
  Y_OFFSET: 130,  // Distance above the aim joystick
  HEIGHT: 150,    // Height of the camera area
  WIDTH: 120      // Width of the camera area
}

MOVE_THRESHOLD: 10
MOVE_SENSITIVITY: 0.15
LOOK_SENSITIVITY: 0.4
CAMERA_ROTATION_SENSITIVITY: 0.5
*/

/* Mobile buttons */
.mobile-button {
  position: fixed;
  width: 80px;  /* Adjustable through JUMP_BUTTON.SIZE */
  height: 80px;  /* Adjustable through JUMP_BUTTON.SIZE */
  background-color: rgba(0, 0, 0, 0.6);
  border: 3px solid rgba(255, 255, 255, 0.7);
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  color: white;
  font-size: 36px;
  z-index: 1000;
  touch-action: none;
  display: none;
  pointer-events: auto !important;
}

#jump-button {
  bottom: 50px;  /* Adjustable through JUMP_BUTTON.BOTTOM */
  right: 50px;   /* Adjustable through JUMP_BUTTON.RIGHT */
}

/* Simulate visible joystick areas */
.control-hint {
  position: fixed;
  width: 150px; /* Adjustable through joystick SIZE */
  height: 150px; /* Adjustable through joystick SIZE */
  border-radius: 50%;
  border: 2px dashed rgba(255, 255, 255, 0.3);
  z-index: 999;
  pointer-events: none;
  display: none;
  background-color: rgba(255, 255, 255, 0.1);
}

#left-control-hint {
  bottom: 50px;  /* Adjustable through LEFT_JOYSTICK.BOTTOM */
  left: 50px;    /* Adjustable through LEFT_JOYSTICK.LEFT */
}

#right-control-hint {
  bottom: 90px; /* Adjustable through RIGHT_JOYSTICK.BOTTOM */
  right: 80px;   /* Adjustable through RIGHT_JOYSTICK.RIGHT */
}

/* Camera control hint - covers the whole screen but invisible */
#camera-control-hint {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: transparent;
  border: none;
  z-index: 900; /* Below other controls but above canvas */
  pointer-events: none;
  display: flex;
}

/* Only show mobile controls on mobile devices */
@media (max-width: 1024px), (pointer: coarse) {
  .mobile-button {
    display: block;
  }
  
  .control-hint {
    display: block;
  }
  
  #ammo-counter, #health-counter {
    font-size: 16px;
    padding: 8px;
    z-index: 1001; /* Ensure they appear above the touch overlay */
    max-width: 80px;
    text-align: center;
  }
  
  #health-counter {
    top: 10px;
    right: 10px;
    width: auto;
    left: auto;
    background-color: rgba(0, 0, 0, 0.7);
    font-size: 14px;
    padding: 4px 8px;
    border-radius: 3px;
  }
  
  /* Hide all info banners and instructions on mobile */
  #fps-counter, #player-count, #connection-status, #network-status, 
  #lobby-indicator, #portal-instructions,
  #reload-message, #proper-shootout-instructions {
    display: none !important;
  }
  
  /* Make ammo and health more visible but compact */
  #ammo-counter {
    bottom: 10px;
    right: 10px;
    background-color: rgba(0, 0, 0, 0.7);
    font-weight: bold;
    font-size: 14px;
    padding: 4px 8px;
    border-radius: 3px;
  }
  
  @media (orientation: landscape) {
    .mobile-button {
      height: 70px;  /* Smaller for landscape */
      width: 70px;   /* Smaller for landscape */
      font-size: 28px;
    }
    
    #jump-button {
      bottom: 40px; /* Adjusted for landscape */
      right: 40px;  /* Adjusted for landscape */
    }
    
    /* Control hints (joystick indicators) */
    .control-hint {
      width: 120px;
      height: 120px;
    }
    
    #left-control-hint {
      bottom: 40px;  /* Moved up */
      left: 40px;    /* Moved right */
    }
    
    #right-control-hint {
      bottom: 80px; /* Adjusted for landscape */
      right: 80px;   /* Moved more to the left */
    }
    
    /* Remove camera control hint specific styling for landscape */
    #camera-control-hint {
      /* Keep it simple - just maintain the full-screen invisible area */
      border: none;
      background-color: transparent;
    }
    
    /* Ensure crosshair is visible */
    #crosshair {
      z-index: 1500;
    }
    
    /* Simplify health display to prevent overflow */
    #health-counter {
      padding: 3px 5px;
      font-size: 12px;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      border-radius: 3px;
    }
  }
}

/* Force landscape for mobile - fix vertical bar issue */
@media (max-width: 1024px) and (orientation: portrait) {
  #game-container {
    transform: rotate(90deg);
    transform-origin: left top;
    width: 100vh;
    height: 100vw;
    position: absolute;
    top: 0;
    left: 0;
    overflow: hidden;
  }
  
  /* Fix for systems with notches/home indicators */
  body {
    background-color: #000;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 0;
  }
  
  /* Full screen canvas with proper alignment */
  canvas {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover;
    position: absolute;
    top: 0;
    left: 0;
  }
  
  /* Additional fix for the orientation wrapper */
  #orientation-message {
    transform: rotate(-90deg);
    width: 100vw;
    height: 100vh;
  }
}

/* Meta viewport tag doesn't allow scaling on mobiles, so add touch control */
@media (max-width: 1024px) {
  body {
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    overflow: hidden;
    background-color: #000;
    /* Ensure no whitespace around edges */
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 0;
  }
  
  /* Ensure full screen coverage */
  #game-container {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background-color: #000;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: 0;
    padding: 0;
  }
  
  canvas {
    width: 100vw !important;
    height: 100vh !important;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: 0;
    padding: 0;
    object-fit: cover;
  }
  
  /* Make sure controls are responsive to touch */
  .mobile-button {
    touch-action: none;
    -webkit-touch-callout: none;
  }
  
  /* Prevent all portal instructions from showing */
  #portal-instructions,
  #proper-shootout-instructions,
  div[class*="portal-instructions"] {
    display: none !important;
    pointer-events: none !important;
    visibility: hidden !important;
  }
}

/* For landscape orientation */
@media (orientation: landscape) {
  .control-hint {
    width: 120px;
    height: 120px;
  }
}

/* Chat styles */
#chat-container {
  position: absolute;
  bottom: 80px;
  left: 20px;
  max-width: 400px;
  height: auto;
  max-height: 250px;
  overflow-y: auto;
  background-color: transparent;
  border-radius: 5px;
  padding: 10px;
  font-family: Arial, sans-serif;
  color: #fff;
  z-index: 1000;
  display: flex;
  flex-direction: column;
  font-size: 14px;
  scrollbar-width: none; /* Hide scrollbar for Firefox */
  -ms-overflow-style: none; /* Hide scrollbar for IE and Edge */
  transition: background-color 0.2s ease;
}

#chat-container.active {
  background-color: transparent;
  scrollbar-width: thin; /* Show scrollbar for Firefox when active */
  scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0.2);
}

#chat-messages {
  margin-bottom: 5px;
  overflow-y: auto;
  max-height: 230px;
  display: flex;
  flex-direction: column;
  scrollbar-width: none; /* Hide scrollbar for Firefox */
  -ms-overflow-style: none; /* Hide scrollbar for IE and Edge */
}

#chat-container.active #chat-messages {
  scrollbar-width: thin; /* Show scrollbar for Firefox when active */
  scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0.2);
}

/* Hide scrollbar for Chrome, Safari and Opera */
#chat-container::-webkit-scrollbar,
#chat-messages::-webkit-scrollbar {
  width: 0; 
  display: none;
}

/* Show scrollbar for Chrome, Safari and Opera when active */
#chat-container.active::-webkit-scrollbar,
#chat-container.active #chat-messages::-webkit-scrollbar {
  width: 6px;
  display: block;
  opacity: 1;
}

/* Scrollbar track and thumb styles for active chat */
#chat-container.active::-webkit-scrollbar-track,
#chat-container.active #chat-messages::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}

#chat-container.active::-webkit-scrollbar-thumb,
#chat-container.active #chat-messages::-webkit-scrollbar-thumb {
  background-color: rgba(255, 255, 255, 0.3);
  border-radius: 3px;
}

.chat-message {
  margin-bottom: 5px;
  word-wrap: break-word;
  padding: 2px 0;
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 1), 0 0 6px rgba(0, 0, 0, 0.9);
  line-height: 1.4;
}

.username {
  font-weight: bold;
  margin-right: 5px;
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 1), 0 0 5px rgba(0, 0, 0, 0.9);
}

#chat-input-container {
  position: absolute;
  bottom: 20px;
  left: 20px;
  width: 400px;
  z-index: 1000;
  display: none;
}

#chat-input {
  width: 100%;
  padding: 8px;
  border-radius: 5px;
  border: none;
  background-color: rgba(0, 0, 0, 0.7);
  color: #fff;
  font-family: Arial, sans-serif;
  outline: none;
}

.system-message {
  color: #ddd;
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 1), 0 0 6px rgba(0, 0, 0, 0.9);
}

.hidden {
  display: none;
}

/* Letterbox effect for cinematic eagle camera view */
.letterbox-top, 
.letterbox-bottom {
  position: fixed;
  left: 0;
  width: 100%;
  height: 0;
  background-color: #000;
  z-index: 1000;
  transition: height 0.7s ease-in-out;
}

.letterbox-top {
  top: 0;
}

.letterbox-bottom {
  bottom: 0;
}

.letterbox-active .letterbox-top,
.letterbox-active .letterbox-bottom {
  height: 15vh;  /* 15% of viewport height for each bar */
}

/* Mobile-specific chat styles */
@media (max-width: 1024px) {
  #chat-container {
    background-color: transparent !important; /* Remove background */
    touch-action: auto !important; /* Override any touch restrictions */
    -webkit-touch-callout: default !important; /* Allow touch interactions */
    -webkit-user-select: text !important; /* Allow text selection in chat */
    user-select: text !important;
    pointer-events: auto !important; /* Ensure pointer events work */
    padding: 10px !important; /* Smaller padding */
    min-height: 30px; /* Ensure there's always something to tap */
    /* Position from the left edge - no more notch adjustment */
    left: 0px !important; 
    top: 10px !important;
    width: 70% !important;
    max-width: 70% !important;
  }
  
  /* For iPhone X and later with notch */
  @supports (padding-top: env(safe-area-inset-top)) {
    #chat-container {
      padding-left: calc(env(safe-area-inset-left) + 5px) !important;
      padding-top: env(safe-area-inset-top) !important;
    }
  }
  
  /* iOS-compatible chat link styles - invisible but clickable */
  #chat-mobile-link {
    /* Reset all visible styles */
    background-color: transparent !important;
    border: none !important;
    color: transparent !important;
    box-shadow: none !important;
    opacity: 0 !important;
    
    /* Keep functional properties */
    -webkit-tap-highlight-color: transparent !important;
    -webkit-touch-callout: none !important;
    -webkit-user-select: none !important;
    user-select: none !important;
    touch-action: manipulation !important;
    display: block !important;
    
    /* Positioning - match chat container exactly */
    position: fixed !important;
    top: 10px !important;
    left: 0px !important;
    width: 70% !important;
    height: 30% !important;
    z-index: 9999 !important;
    
    /* Critical for functionality */
    pointer-events: auto !important;
  }
}

/* Mobile-specific enhancements for chat without background */
@media (max-width: 1024px) {
  .chat-message {
    text-shadow: 2px 2px 3px rgba(0, 0, 0, 1), 0 0 8px rgba(0, 0, 0, 1) !important;
    font-weight: bold !important;
    color: rgba(255, 255, 255, 0.95) !important;
  }
  
  .system-message {
    color: rgba(255, 255, 255, 0.9) !important;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 1), 0 0 8px rgba(0, 0, 0, 1) !important;
  }
  
  .username {
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 1), 0 0 8px rgba(0, 0, 0, 1) !important;
  }
}

@supports (padding-top: env(safe-area-inset-top)) {
  #chat-container {
    padding-left: calc(env(safe-area-inset-left) + 5px) !important;
    padding-top: env(safe-area-inset-top) !important;
  }
}

/* Chat messages specific styles */
#chat-messages {
  padding-right: 5px !important;
}

#chat-input-container {
  touch-action: auto !important;
  -webkit-touch-callout: default !important;
  -webkit-user-select: text !important;
  user-select: text !important;
  pointer-events: auto !important;
}

#chat-input {
  font-size: 16px; /* iOS Safari requires 16px+ to prevent zoom */
}

#chat-send-button {
  min-height: 44px; /* Apple recommends 44px minimum touch target size */
  min-width: 44px;
  touch-action: manipulation;
  -webkit-appearance: none; /* Prevent iOS default styling */
}

/* iOS-compatible chat link styles - invisible but clickable */
#chat-mobile-link {
  /* Reset all visible styles */
  background-color: transparent !important;
  border: none !important;
  color: transparent !important;
  box-shadow: none !important;
  opacity: 0 !important;
  
  /* Keep functional properties */
  -webkit-tap-highlight-color: transparent !important;
  -webkit-touch-callout: none !important;
  -webkit-user-select: none !important;
  user-select: none !important;
  touch-action: manipulation !important;
  display: block !important;
  
  /* Positioning - match chat container exactly */
  position: fixed !important;
  top: 10px !important;
  left: 0px !important;
  width: 70% !important;
  height: 30% !important;
  z-index: 9999 !important;
  
  /* Critical for functionality */
  pointer-events: auto !important;
}

/* Remove active state visual effects */
#chat-mobile-link:active {
  opacity: 0 !important;
  background-color: transparent !important;
  transform: none !important;
}

/* Remove the fire button CSS */
#fire-button {
  display: none; /* Hide it completely */
}

@media (max-width: 1024px), (pointer: coarse) {
  @media (orientation: landscape) {
    #fire-button {
      display: none; /* Hide in landscape mode as well */
    }
  }
}

/* Joystick knob styles */
.joystick-knob {
  position: absolute;
  border-radius: 50%;
  pointer-events: none;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  transition: transform 0.05s ease-out;
  will-change: transform;
}

#left-joystick-knob {
  width: 40%;
  height: 40%;
  background-color: rgba(255, 255, 255, 0.4);
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
}

#right-joystick-knob {
  width: 40%;
  height: 40%;
  background-color: rgba(0, 0, 0, 0.3);
  display: flex;
  justify-content: center;
  align-items: center;
}

#right-joystick-knob img {
  width: 70%;
  height: 70%;
  object-fit: contain;
}

/* Updated control hints */
.control-hint {
  position: fixed;
  border-radius: 50%;
  border: 2px dashed rgba(255, 255, 255, 0.3);
  z-index: 997;
  pointer-events: none;
  display: block;
  background-color: rgba(0, 0, 0, 0.3);
}

@media (max-width: 1024px), (pointer: coarse) {
  @media (orientation: landscape) {
    .joystick-knob {
      transition: transform 0.03s ease-out;
    }
    
    #left-joystick-knob, #right-joystick-knob {
      width: 35%;
      height: 35%;
    }
  }
}

================================================
File: /public/dev.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wild West Shooter - Dev Tools</title>
    <style>
        body {
            background-color: #333;
            color: #f8bb00;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        h1 {
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .card {
            background-color: #2c2c2c;
            border-radius: 8px;
            padding: 20px;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }
        h2 {
            color: #f8bb00;
            margin-top: 0;
        }
        p {
            color: #fff;
        }
        button {
            background-color: #8b0000;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #a00000;
        }
        .buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        .separator {
            height: 1px;
            background-color: #444;
            width: 100%;
            margin: 20px 0;
        }
        .player-frames {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            width: 100%;
        }
        .player-frame {
            width: 100%;
            height: 400px;
            border: 2px solid #8b0000;
            border-radius: 8px;
            overflow: hidden;
            background-color: #000;
        }
        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        @media (min-width: 1024px) {
            .player-frame {
                width: calc(50% - 10px);
            }
        }
    </style>
</head>
<body>
    <h1>Wild West Shooter - Development Tools</h1>
    
    <div class="card">
        <h2>Testing Options</h2>
        <p>Use these buttons to launch test instances with unique player identities:</p>
        
        <div class="buttons">
            <button onclick="openGameTab()">Launch Game Tab</button>
            <button onclick="openGameTab(true)">Launch Dev Player</button>
            <button onclick="openSideBySide()">Open Side-by-Side</button>
        </div>
        
        <div class="separator"></div>
        
        <h2>Side-by-Side Testing</h2>
        <p>Test two separate player instances right here:</p>
        
        <div class="player-frames">
            <div class="player-frame">
                <iframe id="player1" src=""></iframe>
            </div>
            <div class="player-frame">
                <iframe id="player2" src=""></iframe>
            </div>
        </div>
    </div>
    
    <script>
        // Base game URL
        const baseUrl = window.location.href.replace('/dev.html', '/');
        
        // Function to open game in new tab
        function openGameTab(isDev = false) {
            const url = isDev ? `${baseUrl}?newplayer=true&t=${Date.now()}` : baseUrl;
            window.open(url, '_blank');
        }
        
        // Function to open side-by-side player frames
        function openSideBySide() {
            const timestamp = Date.now();
            document.getElementById('player1').src = `${baseUrl}?newplayer=true&t=${timestamp}`;
            document.getElementById('player2').src = `${baseUrl}?newplayer=true&t=${timestamp + 1}`;
        }
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Development tools ready');
        });
    </script>
</body>
</html> 

================================================
File: /public/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Wild Western FPS" />
  <meta name="mobile-web-app-capable" content="yes" />
  <!-- Additional iOS specific meta tags for better fullscreen handling -->
  <meta name="format-detection" content="telephone=no" />
  <meta name="HandheldFriendly" content="true" />
  <title>Wild Western FPS – Multiplayer</title>
  <link rel="stylesheet" href="css/style.css">
  <style>
    /* Ensure fullscreen with no white bars */
    *, *::before, *::after {
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
    }
    
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
    
    /* Improved iOS safe area handling for status bar and notches */
    #game-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      /* Apply safe area insets for notched devices */
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background-color: #000;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      margin: 0;
      padding: 0;
    }
    
    #admin-controls {
      position: absolute;
      bottom: 200px;
      right: 20px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 999;
      user-select: none;
    }
    
    .admin-buttons {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .admin-buttons button {
      background-color: #4a2519;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
    }
    
    .admin-buttons button:hover {
      background-color: #6c392b;
    }
    
    .hidden {
      display: none;
    }
    
    .error-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px;
      border-radius: 5px;
      z-index: 9999;
      text-align: center;
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="ammo-counter">Bullets: 6/6</div>
    <div id="health-counter">Health: 100</div>
    <div id="reload-message">Hold R to reload</div>
    <div id="reload-progress-container">
      <div id="reload-progress-bar"></div>
    </div>
    <div id="crosshair" style="transform: translate(calc(-50% + 2px), calc(-50% - 1px)) !important;">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
        <!-- Top corner group -->
        <g id="top-corner" class="corner-group">
          <path d="M45,20 L50,15 L55,20" fill="none" stroke="rgba(0, 0, 0, 0.8)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </g>
        
        <!-- Bottom left corner group -->
        <g id="bottom-left-corner" class="corner-group">
          <path d="M20,75 L25,75 M20,75 L20,70" fill="none" stroke="rgba(0, 0, 0, 0.8)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </g>
        
        <!-- Bottom right corner group -->
        <g id="bottom-right-corner" class="corner-group">
          <path d="M75,75 L80,75 M80,75 L80,70" fill="none" stroke="rgba(0, 0, 0, 0.8)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </g>
        
        <!-- Center dot -->
        <circle cx="50" cy="50" r="3" fill="rgba(255, 255, 255, 0.8)" />
      </svg>
    </div>
    <div id="fps-counter">FPS: 0</div>
    <div id="player-count">Players: 1</div>
    <div id="connection-status"></div>
  </div>

  <!-- Three.js core -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- GLTFLoader for loading the GLB gun model -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <!-- Cannon.js for physics (non-ES module version) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  <!-- Solana Web3.js -->
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  
  <!-- Phantom Wallet integration -->
  <script type="module">
    import phantomWalletAdapter from './js/phantom-wallet.js';
    
    // Make the wallet adapter globally available
    window.phantomWalletAdapter = phantomWalletAdapter;
    
    // Initialize the Phantom wallet adapter when the page loads
    // (Network Manager will be connected later in main.js)
    document.addEventListener('DOMContentLoaded', () => {
      console.log('Phantom wallet adapter made globally available');
    });
  </script>
  
  <!-- Main JS as ES6 module -->
  <script type="module" src="js/main.js"></script>
  
  <!-- Letterbox effect for cinematic eagle camera view -->
  <div class="letterbox-top"></div>
  <div class="letterbox-bottom"></div>
  
  <!-- Vibe Jam 2025 entrant badge -->
  <a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">🕹️ Vibe Jam 2025</a>

  <!-- Admin controls for developers -->
  <div id="admin-controls" class="hidden">
    <div class="admin-panel">
      <h3>Admin Controls</h3>
      <p>NPCs are now server-controlled. Bot controls have been removed.</p>
    </div>
  </div>

  <!-- Add script for admin controls -->
  <script>
    // Show admin controls with key combo Ctrl+Shift+B
    document.addEventListener('keydown', function(e) {
      if (e.ctrlKey && e.shiftKey && e.key === 'B') {
        const adminControls = document.getElementById('admin-controls');
        adminControls.classList.toggle('hidden');
      }
    });
  </script>
</body>
</html>

================================================
File: /public/js/bullet.js
================================================
import { createImpactEffect } from './effects.js';

// Reusable objects for collision detection to avoid creating new ones every frame
const raycaster = new THREE.Raycaster();
const tmpVec3 = new THREE.Vector3();
const reusableBox = new THREE.Box3();

/**
 * A bullet class with client-side prediction and server validation.
 * It lets the server have final authority on collisions and hits.
 */
export class Bullet {
  /**
   * @param {THREE.Vector3} position - Starting position
   * @param {THREE.Vector3} direction - Normalized direction vector
   * @param {string|number} bulletId - Optional server-assigned bullet ID (for remote bullets)
   * @param {boolean} isShotgunPellet - Whether this bullet is a pellet from a shotgun
   */
  constructor(position, direction, bulletId = null, isShotgunPellet = false) {
    // Dynamic bullet trajectory adjustment based on viewport
    this.adjustTrajectoryForViewport(direction);
    
    this.mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.02, 8, 8),
      new THREE.MeshStandardMaterial({ color: 0xB8860B })
    );
    this.mesh.position.copy(position);

    this.direction = direction.clone();
    this.speed = 80; // speed units/second
    this.distanceTraveled = 0;
    this.maxDistance = 100;
    this.timeCreated = performance.now();

    // Remember previous position for continuous detection
    this.lastPosition = position.clone();

    // Track which player fired this bullet
    this.sourcePlayerId = null;
    
    // Anti-cheat: Server-assigned bulletId
    this.bulletId = bulletId;
    
    // Anti-cheat: Track whether this bullet is local (created by local player)
    this.isLocalBullet = true;
    
    // Set up the bullet's ray for continuous collision detection
    this.rayOrigin = position.clone();
    this.rayDirection = direction.clone();
    
    // Flag to identify if this bullet is a shotgun pellet
    this.isShotgunPellet = isShotgunPellet;
    
    // Create a visual path for trajectory debugging
    if (window.debugMode) {
      this.createTrajectoryVisualization(position, direction);
    }
  }

  /**
   * Adjusts bullet trajectory based on actual viewport dimensions.
   * Especially useful for iOS where fullscreen mode isn't available by default.
   * @param {THREE.Vector3} direction - The original direction vector to modify
   */
  adjustTrajectoryForViewport(direction) {
    // Skip if not iOS or not needed
    if (!this.isIOS() || !this.needsAdjustment()) {
      return;
    }

    // Get viewport info
    const viewportInfo = this.getViewportInfo();
    
    // Only adjust if there's unused space
    if (viewportInfo.hasUnusedSpace) {
      // Calculate adjustment based on the ratio of unused space
      // This is the percentage of the screen that's not being used
      const visualToDeviceRatio = viewportInfo.visualHeight / viewportInfo.deviceHeight;
      
      // Apply a much smaller adjustment - just enough to align with crosshair
      // Start with a very subtle adjustment factor
      const offsetY = (1 - visualToDeviceRatio) * 0.2; // Reduced from 0.7 to 0.2
      
      // Apply vertical adjustment to direction
      direction.y += offsetY;
      
      // No horizontal adjustment needed - this was causing misalignment
      
      // Renormalize the direction vector
      direction.normalize();
      
      // Debug logs
      if (window.debugMode) {
        console.log(`Bullet trajectory adjusted: Y+${offsetY.toFixed(4)}, ratio: ${visualToDeviceRatio.toFixed(2)}`);
      }
    }
  }

  /**
   * Detects if the device is running iOS
   * @returns {boolean} True if device is iOS
   */
  isIOS() {
    return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  }

  /**
   * Checks if trajectory adjustment is needed
   * @returns {boolean} True if adjustment is needed
   */
  needsAdjustment() {
    // Only adjust for horizontal orientation on iOS
    return this.isIOS() && window.innerWidth > window.innerHeight;
  }

  /**
   * Gets information about the viewport dimensions
   * @returns {Object} Viewport information
   */
  getViewportInfo() {
    // Get the actual visible viewport sizes
    const visualWidth = window.innerWidth;
    const visualHeight = window.innerHeight;
    
    // Get full device screen dimensions
    const deviceWidth = window.screen.width;
    const deviceHeight = window.screen.height;
    
    // Check if we're in landscape mode
    const isLandscape = visualWidth > visualHeight;
    
    // Determine if there's unused space (especially for iOS)
    // In landscape, unused space would be at the top/bottom
    const hasUnusedSpace = isLandscape && (visualHeight < deviceHeight);
    
    return {
      visualWidth,
      visualHeight,
      deviceWidth,
      deviceHeight,
      isLandscape,
      hasUnusedSpace
    };
  }

  /**
   * Sets the player ID that fired this bullet.
   * @param {string|number} playerId - The ID of the player who fired the bullet.
   */
  setSourcePlayer(playerId) {
    this.sourcePlayerId = playerId;
    
    // Anti-cheat: Determine if this is a local bullet
    if (window.localPlayer) {
      this.isLocalBullet = Number(playerId) === Number(window.localPlayer.id);
    }
  }

  /**
   * Updates the bullet's movement & handles collisions with players.
   * Uses client-side prediction with server authority.
   * @param {number} deltaTime
   * @param {THREE.Object3D|null} npc - NPC object (null after cleanup)
   * @param {THREE.Scene} scene
   * @param {Map<number, object>} allPlayers - Map of local + remote players.
   * @returns {Object} - Result of the update containing active state and hit info.
   */
  update(deltaTime, npc, scene, allPlayers) {
    // Previous position for boundary crossing detection
    this.lastPosition = this.mesh.position.clone();
    
    // If we're still active, update bullet position and check for player hits
    this.lastPosition.copy(this.mesh.position);
    
    // Move the bullet
    const displacement = this.direction.clone().multiplyScalar(this.speed * deltaTime);
    this.mesh.position.add(displacement);
    this.distanceTraveled += displacement.length();

    // Current bullet position
    const endPos = this.mesh.position.clone();
    
    // Check for tumbleweed hits if tumbleweedManager exists
    if (window.tumbleweedManager) {
      // Update the raycaster with the bullet's movement path
      raycaster.set(this.lastPosition, this.direction);
      
      // Check for intersection with tumbleweeds
      const tumbleweedHit = window.tumbleweedManager.checkRayIntersection(raycaster);
      
      if (tumbleweedHit) {
        // Create a small impact effect
        createImpactEffect(tumbleweedHit.point, this.direction, scene, 'ground');
        
        // Return hit info
        return { 
          active: false, 
          hit: { 
            type: 'tumbleweed', 
            position: tumbleweedHit.point,
            distance: tumbleweedHit.distance
          } 
        };
      }
    }

    // Check for eagle hits if flyingEagle exists
    if (window.flyingEagle) {
      // Update the raycaster with the bullet's movement path
      raycaster.set(this.lastPosition, this.direction);
      
      // Check for intersection with eagle's hitbox
      const eagleIntersection = raycaster.ray.intersectSphere(window.flyingEagle.hitbox, new THREE.Vector3());
      
      if (eagleIntersection) {
        // Create a small impact effect
        createImpactEffect(eagleIntersection, this.direction, scene, 'eagle');
        
        // Hit the eagle
        window.flyingEagle.hit();
        
        // Return hit info
        return { 
          active: false, 
          hit: { 
            type: 'eagle', 
            position: eagleIntersection,
            distance: eagleIntersection.distanceTo(raycaster.ray.origin)
          } 
        };
      }
    }

    // Anti-cheat: For local bullets, collision detection is only client-side prediction
    // For remote bullets, we rely on client-side collision for visual effects
    
    // Check collision with players
    if (allPlayers) {
      // First create an array of [playerId, playerObj] pairs to iterate through
      const playerEntries = [];
      
      // Check if allPlayers is a Map
      if (allPlayers instanceof Map) {
        // Use Map entries directly
        playerEntries.push(...allPlayers.entries());
      } 
      // Check if it has a working entries function
      else if (typeof allPlayers.entries === 'function') {
        try {
          playerEntries.push(...allPlayers.entries());
        } catch (e) {
          // If entries() fails, fall back to Object.entries
          playerEntries.push(...Object.entries(allPlayers));
        }
      } 
      // Fallback to treating as a regular object
      else {
        playerEntries.push(...Object.entries(allPlayers));
      }
      
      // Now process all players
      for (const [playerId, playerObj] of playerEntries) {
        // Skip bullet's owner by converting both IDs to numbers
        if (this.sourcePlayerId !== null && Number(playerId) === Number(this.sourcePlayerId)) {
          continue;
        }
        
        // Check if player has a valid model
        if (!playerObj || !playerObj.group) {
          continue;
        }
        
        // Check bullet-player collision using precise hit zones
        const hitZoneResult = this.checkPlayerHitZones(playerObj, endPos);
        
        if (hitZoneResult.hit) {
          // First, create impact effect to give visual feedback
          createImpactEffect(endPos, this.direction, scene, 'player');
          
          // Store the hit zone (head, body, limbs) for damage feedback
          if (this.setLastHitZone) {
            this.setLastHitZone(hitZoneResult.zone);
          }
          
          // Show hit marker (for local bullets only)
          if (this.isLocalBullet) {
            this.showHitMarker(endPos);
          }
          
          // Show hit marker for client-side feedback (even for remote bullets)
          return { 
            active: false, 
            hit: { 
              type: 'player', 
              playerId: playerId,
              position: endPos,
              zone: hitZoneResult.zone 
            } 
          };
        }
      }
    }

    // Check for collision with terrain
    const terrain = window.terrain;
    if (terrain && terrain.checkRayCollision) {
      const collision = terrain.checkRayCollision(this.lastPosition, this.direction, displacement.length());
      if (collision.hit) {
        // Create impact effect
        createImpactEffect(collision.position, this.direction, scene, 'ground');
        
        // Return hit info
        return { 
          active: false, 
          hit: { 
            type: 'terrain', 
            position: collision.position 
          } 
        };
      }
    }

    // Check for ground collision (if no terrain system exists)
    if (!terrain && endPos.y <= 0.05) {
      // Create impact effect on ground
      const impactPosition = new THREE.Vector3(endPos.x, 0, endPos.z);
      createImpactEffect(impactPosition, this.direction, scene, 'ground');
      
      // Return hit info
      return { 
        active: false, 
        hit: { 
          type: 'ground', 
          position: impactPosition 
        } 
      };
    }

    // Check for train collision
    if (window.trainManager && window.trainManager.checkBulletCollision) {
      const trainCollision = window.trainManager.checkBulletCollision(this.lastPosition, endPos);
      if (trainCollision.hit) {
        // Create impact effect
        createImpactEffect(trainCollision.position, this.direction, scene, 'train');
        
        // Return hit info
        return { 
          active: false, 
          hit: { 
            type: 'train', 
            position: trainCollision.position 
          } 
        };
      }
    }

    // Check for scene object collisions (buildings, props)
    if (window.objectColliders) {
      for (const collider of window.objectColliders) {
        // Skip if collider is invalid
        if (!collider || !collider.type) continue;
        
        let intersection = null;
        
        // Different intersection tests based on collider type
        if (collider.type === 'sphere') {
          // Sphere collision
          intersection = raycaster.ray.intersectSphere(collider.sphere, new THREE.Vector3());
        } else if (collider.type === 'box') {
          // Box collision
          raycaster.set(this.lastPosition, this.direction);
          const intersections = raycaster.intersectBox(collider.box, new THREE.Vector3());
          intersection = intersections.length > 0 ? intersections[0] : null;
        }
        
        if (intersection) {
          // Create impact effect
          createImpactEffect(intersection, this.direction, scene, 'object');
          
          // Return hit info
          return { 
            active: false, 
            hit: { 
              type: 'object', 
              position: intersection,
              collider: collider
            } 
          };
        }
      }
    }

    // Check for max distance
    if (this.distanceTraveled > this.maxDistance) {
      return { active: false, hit: null };
    }

    return { active: true, hit: null };
  }
  
  /**
   * Checks which part of the player model was hit and returns damage amount.
   * Uses ray casting against actual player meshes for more precise hit detection.
   * @param {object} playerObj - The player object to check
   * @param {THREE.Vector3} bulletPos - The bullet position
   * @returns {object} - Contains hit (boolean), zone (string), and damage (number)
   */
  checkPlayerHitZones(playerObj, bulletPos) {
    // If the player has a ThirdPersonModel, use its dedicated mesh-based hit detection
    if (playerObj.playerModel && playerObj.playerModel.checkBulletHit) {
      const hitResult = playerObj.playerModel.checkBulletHit(bulletPos, this.isShotgunPellet);
      
      // If this is a shotgun pellet, adjust the damage (should be handled by the model now)
      return hitResult;
    }
    
    // Fallback to box-based hit detection for local player or models without mesh hit detection
    
    // Get player's base position for collision box
    // For local players (first-person), group.position is at eye-level so subtract 1.6
    // Remote players (third-person) have group.position at the base
    const playerPos = playerObj.group.position.clone();
    let baseY = playerPos.y;
    if (playerObj.camera) { // local player
      baseY = playerPos.y - 1.6;
    }
    
    // Define hit zone dimensions
    const headSize = 0.4; // Head is a smaller target
    const bodyWidth = 0.5;
    const bodyHeight = 0.9;
    const limbWidth = 0.2;
    const limbHeight = 0.6;
    
    // Calculate vertical positions of each zone
    // Using the adjusted values for better alignment
    const headBottom = baseY + 1.8 - headSize;
    const headTop = baseY + 1.8;
    const bodyBottom = baseY + 0.9;
    const bodyTop = baseY + 1.8 - headSize;
    const legBottom = baseY + 0.2;
    const legTop = baseY + 0.8;
    const armBottom = baseY + 0.8;
    const armTop = baseY + 1.4;
    
    // Create debug visualization if physics debug mode is enabled or global debug flag is set
    if ((window.physics && window.physics.debugMode) || window.showHitZoneDebug) {
      if (!playerObj._hitZoneDebug) {
        this.createHitZoneDebugBoxes(playerObj, {
          playerPos, baseY, 
          headSize, bodyWidth, bodyHeight, limbWidth, limbHeight,
          headBottom, headTop, bodyBottom, bodyTop, 
          legBottom, legTop, armBottom, armTop
        });
      }
    }
    
    // Reuse the global THREE.Box3 object for better performance
    
    // First do a quick test with the overall player bounding box
    reusableBox.min.set(
      playerPos.x - bodyWidth,
      baseY + 0.2, // Adjusted to match new bottom height
      playerPos.z - bodyWidth
    );
    reusableBox.max.set(
      playerPos.x + bodyWidth,
      baseY + 1.8, // Adjusted to match new top height
      playerPos.z + bodyWidth
    );
    
    const overallBox = reusableBox;
    
    if (!overallBox.containsPoint(bulletPos)) {
      return { hit: false, zone: null, damage: 0 };
    }
    
    // Setup ray casting from the bullet's previous position to current position
    // This gives us more accurate hit detection along the bullet's path
    raycaster.set(this.lastPosition, this.direction);
    
    // Define ray length (distance the bullet traveled this frame)
    const rayLength = this.lastPosition.distanceTo(bulletPos);
    raycaster.far = rayLength * 1.1; // Add a small margin
    
    // Check head zone (highest damage)
    reusableBox.min.set(
      playerPos.x - headSize/2,
      headBottom,
      playerPos.z - headSize/2
    );
    reusableBox.max.set(
      playerPos.x + headSize/2,
      headTop,
      playerPos.z + headSize/2
    );
    
    if (reusableBox.containsPoint(bulletPos)) {
      // Apply different damage based on whether this is a shotgun pellet
      const damage = this.isShotgunPellet ? 10 : 100;
      return { hit: true, zone: 'head', damage: damage };
    }
    
    // Check body zone (medium damage)
    reusableBox.min.set(
      playerPos.x - bodyWidth/2,
      bodyBottom,
      playerPos.z - bodyWidth/2
    );
    reusableBox.max.set(
      playerPos.x + bodyWidth/2,
      bodyTop,
      playerPos.z + bodyWidth/2
    );
    
    if (reusableBox.containsPoint(bulletPos)) {
      // Apply different damage based on whether this is a shotgun pellet
      const damage = this.isShotgunPellet ? 5 : 40;
      return { hit: true, zone: 'body', damage: damage };
    }
    
    // Check arms (low damage, simplified to two boxes on sides)
    // Left arm
    reusableBox.min.set(
      playerPos.x - bodyWidth/2 - limbWidth,
      armBottom,
      playerPos.z - limbWidth/2
    );
    reusableBox.max.set(
      playerPos.x - bodyWidth/2,
      armTop,
      playerPos.z + limbWidth/2
    );
    
    if (reusableBox.containsPoint(bulletPos)) {
      // Apply different damage based on whether this is a shotgun pellet
      const damage = this.isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    // Right arm
    reusableBox.min.set(
      playerPos.x + bodyWidth/2,
      armBottom,
      playerPos.z - limbWidth/2
    );
    reusableBox.max.set(
      playerPos.x + bodyWidth/2 + limbWidth,
      armTop,
      playerPos.z + limbWidth/2
    );
    
    if (reusableBox.containsPoint(bulletPos)) {
      // Apply different damage based on whether this is a shotgun pellet
      const damage = this.isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    // Check legs (low damage)
    // Left leg
    reusableBox.min.set(
      playerPos.x - bodyWidth/4 - limbWidth/2,
      legBottom,
      playerPos.z - limbWidth/2
    );
    reusableBox.max.set(
      playerPos.x - bodyWidth/4 + limbWidth/2,
      legTop,
      playerPos.z + limbWidth/2
    );
    
    if (reusableBox.containsPoint(bulletPos)) {
      // Apply different damage based on whether this is a shotgun pellet
      const damage = this.isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    // Right leg
    reusableBox.min.set(
      playerPos.x + bodyWidth/4 - limbWidth/2,
      legBottom,
      playerPos.z - limbWidth/2
    );
    reusableBox.max.set(
      playerPos.x + bodyWidth/4 + limbWidth/2,
      legTop,
      playerPos.z + limbWidth/2
    );
    
    if (reusableBox.containsPoint(bulletPos)) {
      // Apply different damage based on whether this is a shotgun pellet
      const damage = this.isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    // If we reach here but hit the overall box, it's a grazing hit to the body
    // Instead of no damage, register it as a body hit with reduced damage
    const damage = this.isShotgunPellet ? 5 : 30;
    return { hit: true, zone: 'body', damage: damage };
  }
  
  /**
   * Creates visible debug boxes for hit zones when physics debug mode is enabled
   * @param {object} playerObj - The player object
   * @param {object} dims - Dimensions and positions for the hit zones
   */
  createHitZoneDebugBoxes(playerObj, dims) {
    // Only used in debug mode
    if (!window.scene) return;
    
    // Remove any existing debug boxes for this player
    if (playerObj._hitZoneDebug) {
      window.scene.remove(playerObj._hitZoneDebug);
      playerObj._hitZoneDebug.traverse(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    }
    
    // Create a new group for hitbox visualization
    const hitZoneGroup = new THREE.Group();
    hitZoneGroup.name = "hitZoneDebug_" + playerObj.id;
    
    // Create helper function to make box helpers
    const createBoxHelper = (min, max, color) => {
      // Use BoxGeometry instead of Box3Helper for more reliable visual feedback
      const sizeX = max.x - min.x;
      const sizeY = max.y - min.y;
      const sizeZ = max.z - min.z;
      
      const geometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        wireframe: true,
        transparent: true,
        opacity: 0.7
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      // Position at the center of the box
      mesh.position.set(
        min.x + sizeX/2,
        min.y + sizeY/2,
        min.z + sizeZ/2
      );
      
      hitZoneGroup.add(mesh);
      return mesh;
    };
    
    // Calculate all zones relative to player position
    // Note: these are local to the player, not world positions
    
    // Head zone - red
    const headMin = new THREE.Vector3(
      -dims.headSize/2,
      dims.headBottom - dims.baseY,
      -dims.headSize/2
    );
    const headMax = new THREE.Vector3(
      dims.headSize/2,
      dims.headTop - dims.baseY,
      dims.headSize/2
    );
    const headHelper = createBoxHelper(headMin, headMax, 0xff0000);
    
    // Body zone - orange
    const bodyMin = new THREE.Vector3(
      -dims.bodyWidth/2,
      dims.bodyBottom - dims.baseY,
      -dims.bodyWidth/2
    );
    const bodyMax = new THREE.Vector3(
      dims.bodyWidth/2,
      dims.bodyTop - dims.baseY,
      dims.bodyWidth/2
    );
    const bodyHelper = createBoxHelper(bodyMin, bodyMax, 0xff7700);
    
    // Left arm - yellow
    const leftArmMin = new THREE.Vector3(
      -dims.bodyWidth/2 - dims.limbWidth,
      dims.armBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const leftArmMax = new THREE.Vector3(
      -dims.bodyWidth/2,
      dims.armTop - dims.baseY,
      dims.limbWidth/2
    );
    const leftArmHelper = createBoxHelper(leftArmMin, leftArmMax, 0xffff00);
    
    // Right arm - green
    const rightArmMin = new THREE.Vector3(
      dims.bodyWidth/2,
      dims.armBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const rightArmMax = new THREE.Vector3(
      dims.bodyWidth/2 + dims.limbWidth,
      dims.armTop - dims.baseY,
      dims.limbWidth/2
    );
    const rightArmHelper = createBoxHelper(rightArmMin, rightArmMax, 0x00ff00);
    
    // Left leg - blue
    const leftLegMin = new THREE.Vector3(
      -dims.bodyWidth/4 - dims.limbWidth/2,
      dims.legBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const leftLegMax = new THREE.Vector3(
      -dims.bodyWidth/4 + dims.limbWidth/2,
      dims.legTop - dims.baseY,
      dims.limbWidth/2
    );
    const leftLegHelper = createBoxHelper(leftLegMin, leftLegMax, 0x0000ff);
    
    // Right leg - purple
    const rightLegMin = new THREE.Vector3(
      dims.bodyWidth/4 - dims.limbWidth/2,
      dims.legBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const rightLegMax = new THREE.Vector3(
      dims.bodyWidth/4 + dims.limbWidth/2,
      dims.legTop - dims.baseY,
      dims.limbWidth/2
    );
    const rightLegHelper = createBoxHelper(rightLegMin, rightLegMax, 0x800080);
    
    // Add the hitzone group to the scene
    window.scene.add(hitZoneGroup);
    
    // Store reference to debug visualization group
    playerObj._hitZoneDebug = hitZoneGroup;
    
    // Update hitbox position immediately
    this.updateHitZoneDebugPosition(playerObj);

    // Add an update function to the player object
    if (!playerObj._updateHitZoneDebug) {
      const self = this;
      playerObj._updateHitZoneDebug = function() {
        if (this._hitZoneDebug) {
          self.updateHitZoneDebugPosition(this);
        }
      };
      
      // Modify the player's update function to include hitbox updates
      if (playerObj.update && typeof playerObj.update === 'function') {
        const originalUpdate = playerObj.update;
        playerObj.update = function(deltaTime) {
          // Call original update
          originalUpdate.call(this, deltaTime);
          // Update hit zone debug
          if (this._updateHitZoneDebug) {
            this._updateHitZoneDebug();
          }
        };
      }
    }
  }
  
  /**
   * Updates the position of a player's hit zone debug visualization
   * @param {object} playerObj - The player object
   */
  updateHitZoneDebugPosition(playerObj) {
    if (!playerObj || !playerObj._hitZoneDebug || !playerObj.group) return;
    
    const hitZoneDebug = playerObj._hitZoneDebug;
    const playerPos = playerObj.group.position.clone();
    
    // Adjust height based on whether this is a local (first-person) or remote player
    let baseY = playerPos.y;
    if (playerObj.camera) {
      // Local player's group position is at eye level, so subtract 1.6
      baseY = playerPos.y - 1.6;
    }
    
    // Position the debug group at the player's position
    hitZoneDebug.position.set(playerPos.x, baseY, playerPos.z);
    
    // Apply the player's rotation
    if (playerObj.group.rotation) {
      hitZoneDebug.rotation.y = playerObj.group.rotation.y;
    }
  }
  
  /**
   * Directly handles a server-reported impact for this bullet.
   * @param {string} hitType - Type of impact: 'player', 'npc', 'ground', 'boundary', 'arena'
   * @param {string|number|null} targetId - ID of hit target (for player hits)
   * @param {THREE.Vector3} position - Impact position
   * @param {THREE.Scene} scene - Scene to add effects to
   * @returns {Object} - Result object with active=false
   */
  handleServerImpact(hitType, targetId, position, scene) {
    // Skip creating ground impact effect
    if (hitType === 'ground' || hitType === 'boundary') {
      return { active: false, hit: { type: hitType, targetId, position } };
    }
    
    // Create visual effect based on hit type
    if (position) {
      createImpactEffect(position, this.direction, scene, hitType);
      
      // Play impact sound based on hit type at the impact position
      if (window.localPlayer && window.localPlayer.soundManager) {
        // Select appropriate impact sound based on hit type
        let impactSound = null; // No default sound for ground/other impacts
        
        if (hitType === 'player') {
          impactSound = "fleshimpact";
          
          // If this is a local player's bullet, we don't need to show hitmarker again
          // because we already showed it in the update method when client detected the hit
          if (this.isLocalBullet) {
            // Don't show hitmarker or play hitmarker sound again (already done client-side)
            // This prevents double hit markers on production servers
          }
          
          // Play headshot sound if the server reports it was a headshot
          else if (this.lastHitZone === 'head') {
            // For mobile devices, simplify audio to prevent layering
            if (window.isMobile) {
              // Just play one non-spatialized sound to avoid sync/double sound issues on mobile
              window.localPlayer.soundManager.playSound("headshotmarker", 0, 0.9);
            } else {
              // Headshots should be clearly audible regardless of distance
              if (this.isLocalBullet) {
                // For local player's headshots, play non-spatialized sound for feedback
                window.localPlayer.soundManager.playSound("headshotmarker", 100, 1.0);
                // And a quieter spatial sound for everyone else
                window.localPlayer.soundManager.playSoundAt("headshotmarker", position, 100, 0.5);
              } else {
                // For other players' headshots, use spatial audio
                window.localPlayer.soundManager.playSoundAt("headshotmarker", position, 100, 0.8);
              }
            }
          }
        }
        
        // Determine if this is a local player's bullet impact
        const isLocalPlayerBullet = this.isLocalBullet;
        
        // On mobile, simplify impact sounds to reduce audio overlapping
        if (window.isMobile && impactSound) {
          // Simpler sound approach for mobile to avoid sync issues
          window.localPlayer.soundManager.playSound(impactSound, 0, 0.6);
        } else if (impactSound && isLocalPlayerBullet) {
          // Desktop: Local player impacts should have more immediate feedback
          window.localPlayer.soundManager.playSound(impactSound, 50, 0.5);
          // With a spatial component as well
          window.localPlayer.soundManager.playSoundAt(impactSound, position, 50, 0.3);
        } else if (impactSound) {
          // Remote player impacts use spatial audio only
          window.localPlayer.soundManager.playSoundAt(impactSound, position, 50, 0.7);
        }
      }
    } else {
      // If no position provided, use current bullet position
      createImpactEffect(this.mesh.position, this.direction, scene, hitType);
    }
    
    // Always deactivate the bullet
    return { active: false, hit: { type: hitType, targetId, position } };
  }
  
  /**
   * Sets the last hit zone information for this bullet (for server validation)
   * @param {string} zone - The hit zone ('head', 'body', 'limbs')
   */
  setLastHitZone(zone) {
    this.lastHitZone = zone;
  }
  
  /**
   * Shows a hitmarker on the screen when a bullet hits a target
   * @param {THREE.Vector3} position - The 3D world position of the hit
   */
  showHitMarker(position) {
    // Create a new hit marker element for each hit rather than reusing one
    const hitMarker = document.createElement('div');
    hitMarker.style.position = 'absolute';
    hitMarker.style.transform = 'translate(-50%, -50%)';
    hitMarker.style.width = '40px';
    hitMarker.style.height = '40px';
    hitMarker.style.backgroundImage = 'url("models/hitmarker.png")';
    hitMarker.style.backgroundSize = 'contain';
    hitMarker.style.backgroundRepeat = 'no-repeat';
    hitMarker.style.pointerEvents = 'none';
    hitMarker.style.zIndex = '1000';
    hitMarker.style.opacity = '1';
    hitMarker.style.transition = 'opacity 0.1s ease-in-out';
    
    document.body.appendChild(hitMarker);
    
    // Convert 3D world position to 2D screen position
    if (position && window.localPlayer && window.localPlayer.camera) {
      // Clone the position to avoid modifying the original
      const screenPos = this.worldToScreen(position);
      
      // Only show if the hit is in front of the camera
      if (screenPos) {
        // Position the hit marker at the calculated screen position
        hitMarker.style.left = screenPos.x + 'px';
        hitMarker.style.top = screenPos.y + 'px';
      } else {
        // Fallback to center of screen if behind camera
        hitMarker.style.left = '50%';
        hitMarker.style.top = '50%';
      }
    } else {
      // Fallback to center of screen if no position provided or cannot convert
      hitMarker.style.left = '50%';
      hitMarker.style.top = '50%';
    }
    
    // Hide and remove after 100ms
    setTimeout(() => {
      hitMarker.style.opacity = '0';
      // Remove from DOM after fade out completes
      setTimeout(() => {
        if (hitMarker.parentNode) {
          hitMarker.parentNode.removeChild(hitMarker);
        }
      }, 100);
    }, 100);
  }
  
  /**
   * Converts a 3D world position to 2D screen coordinates
   * @param {THREE.Vector3} worldPos - The 3D world position to convert
   * @returns {Object|null} - The 2D screen position {x, y} or null if behind camera
   */
  worldToScreen(worldPos) {
    if (!window.localPlayer || !window.localPlayer.camera) return null;
    
    // Get the camera
    const camera = window.localPlayer.camera;
    
    // Clone position to avoid modifying the original
    const pos = worldPos.clone();
    
    // Project the 3D position to 2D clip space
    pos.project(camera);
    
    // If the point is behind the camera, don't show the hitmarker
    if (pos.z > 1) return null;
    
    // Convert from normalized device coordinates (-1 to +1) to window coordinates
    const widthHalf = window.innerWidth / 2;
    const heightHalf = window.innerHeight / 2;
    
    const x = (pos.x * widthHalf) + widthHalf;
    const y = -(pos.y * heightHalf) + heightHalf;
    
    return { x, y };
  }

  /**
   * Creates a visual path showing the bullet's trajectory for debugging
   * @param {THREE.Vector3} startPos - Start position
   * @param {THREE.Vector3} direction - Direction vector 
   */
  createTrajectoryVisualization(startPos, direction) {
    // Only create visualization if we're in debug mode and in the scene
    if (!window.debugMode || !window.scene) return;
    
    // Create line showing the projected path
    const lineMaterial = new THREE.LineBasicMaterial({ 
      color: 0xff0000,
      transparent: true,
      opacity: 0.7
    });
    
    // Create points along trajectory
    const points = [];
    points.push(startPos.clone());
    
    // Add a point 10 units away to show direction
    const endPoint = startPos.clone().add(direction.clone().multiplyScalar(10));
    points.push(endPoint);
    
    // Create the line geometry
    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(lineGeometry, lineMaterial);
    
    // Add to scene
    window.scene.add(line);
    
    // Store reference to remove later
    this.trajectoryLine = line;
    
    // Remove line after 2 seconds
    setTimeout(() => {
      if (this.trajectoryLine && window.scene) {
        window.scene.remove(this.trajectoryLine);
        this.trajectoryLine = null;
      }
    }, 2000);
  }
}

================================================
File: /public/js/chat.js
================================================
/**
 * Chat system for player communication
 */

// Store original key handlers
let originalKeydownHandler;
let originalKeyupHandler;

// Chat state
let isChatActive = false;
let chatInputContainer;
let chatInput;
let chatMessages;
let chatContainer;
let messageCount = 0;
let lastSentMessage = null;
let lastMessageTime = 0; // Track when the last message was sent

/**
 * Initialize the chat system
 * @param {NetworkManager} networkManager - The network manager for sending messages
 */
export function initChat(networkManager) {
  createChatUI();
  setupChatEventListeners(networkManager);
}

/**
 * Create the chat UI elements
 */
function createChatUI() {
  const gameContainer = document.getElementById('game-container') || document.body;
  
  // Create chat container
  chatContainer = document.createElement('div');
  chatContainer.id = 'chat-container';
  
  // Initially size to content until we have multiple messages
  chatContainer.style.height = 'auto';
  gameContainer.appendChild(chatContainer);
  
  // Create messages container
  chatMessages = document.createElement('div');
  chatMessages.id = 'chat-messages';
  chatContainer.appendChild(chatMessages);
  
  // Create input container
  chatInputContainer = document.createElement('div');
  chatInputContainer.id = 'chat-input-container';
  gameContainer.appendChild(chatInputContainer);
  
  // Create input field
  chatInput = document.createElement('input');
  chatInput.id = 'chat-input';
  chatInput.type = 'text';
  chatInput.maxLength = 60; // Limit message length
  chatInput.placeholder = 'Type your message...';
  chatInputContainer.appendChild(chatInput);
  
  // Create send button for mobile
  const sendButton = document.createElement('button');
  sendButton.id = 'chat-send-button';
  sendButton.textContent = 'Send';
  sendButton.style.display = 'none'; // Initially hidden, shown only on mobile
  chatInputContainer.appendChild(sendButton);
  
  // Check if mobile and apply special styling
  if (isMobileDevice()) {
    // Position chat in top left for mobile - without dark background
    chatContainer.style.position = 'fixed';
    chatContainer.style.top = '10px';
    chatContainer.style.left = '0px'; // Changed from 10px to 0px - more to the left
    chatContainer.style.width = '70%';
    chatContainer.style.maxHeight = '30%';
    chatContainer.style.backgroundColor = 'transparent'; // Remove background
    chatContainer.style.zIndex = '1000';
    
    // COMPLETELY NEW APPROACH: Create a simple HTML link that opens a prompt
    // This is the most compatible approach for iOS Safari
    const chatButtonLink = document.createElement('a');
    chatButtonLink.id = 'chat-mobile-link';
    chatButtonLink.href = '#chat';  // Non-empty href required for iOS
    chatButtonLink.textContent = ''; // No text
    chatButtonLink.style.position = 'fixed';
    chatButtonLink.style.top = '10px';
    chatButtonLink.style.left = '0px'; // Also changed to 0px to match chat container
    chatButtonLink.style.width = '70%'; // Match chat container width
    chatButtonLink.style.height = '30%'; // Match chat container height
    chatButtonLink.style.padding = '0';
    chatButtonLink.style.zIndex = '2000';
    chatButtonLink.style.backgroundColor = 'transparent'; // Invisible
    chatButtonLink.style.border = 'none'; // No border
    chatButtonLink.style.color = 'transparent'; // Invisible text
    chatButtonLink.style.textDecoration = 'none';
    chatButtonLink.style.textAlign = 'left';
    chatButtonLink.style.opacity = '0'; // Make completely invisible
    // Still need pointer events to work
    chatButtonLink.style.pointerEvents = 'auto';
    
    // Add link to DOM
    document.body.appendChild(chatButtonLink);
    
    // Use simple prompt-based chat for maximum iOS compatibility
    chatButtonLink.addEventListener('click', function(e) {
      e.preventDefault();
      
      // Use native prompt() dialog which works reliably on all browsers
      const message = prompt('Enter your message:');
      
      if (message && message.trim()) {
        // Get network manager from global scope
        const networkManager = window.networkManager;
        
        if (networkManager) {
          // Process the chat message
          lastSentMessage = message.trim();
          sendChatMessage(message.trim(), networkManager);
        }
      }
    });
    
    // Hide the standard chat input on mobile since we're using prompt
    chatInputContainer.style.display = 'none';
    
    // Add system message about chat being available - shorter version
    addSystemMessage("Tap here to chat");
  } else {
    // Add desktop-specific message
    addSystemMessage("Press \"Enter\" to chat with other players!");
  }
  
  // Adjust chat container size on window resize
  window.addEventListener('resize', updateChatPosition);
}

/**
 * Set up event listeners for the chat
 * @param {NetworkManager} networkManager - The network manager for sending messages
 */
function setupChatEventListeners(networkManager) {
  // Store original document key handlers
  originalKeydownHandler = document.onkeydown;
  originalKeyupHandler = document.onkeyup;
  
  // Add keydown event listener for chat activation
  document.addEventListener('keydown', (event) => {
    // Press Enter to toggle chat input
    if (event.code === 'Enter') {
      event.preventDefault();
      
      if (isChatActive) {
        const message = chatInput.value.trim();
        if (message) {
          lastSentMessage = message; // Store last sent message to prevent duplication
          sendChatMessage(message, networkManager);
        }
        closeChat();
      } else {
        openChat();
      }
      return;
    }
    
    // If chat is active, handle chat-specific keys
    if (isChatActive) {
      // Close chat on Escape
      if (event.code === 'Escape') {
        closeChat();
        event.preventDefault();
      }
      
      // Prevent game actions while typing
      event.stopPropagation();
    }
  }, true);
  
  // Handle clicks to close chat when clicking outside chat elements
  document.addEventListener('click', (event) => {
    if (isChatActive) {
      // Check if click is outside chat elements
      if (!chatContainer.contains(event.target) && !chatInputContainer.contains(event.target)) {
        closeChat();
      }
    }
  });
  
  // Add event listener for send button
  const sendButton = document.getElementById('chat-send-button');
  if (sendButton) {
    // Use both click and touchend for better mobile experience
    ['click', 'touchend'].forEach(eventType => {
      sendButton.addEventListener(eventType, function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const message = chatInput.value.trim();
        if (message) {
          lastSentMessage = message;
          sendChatMessage(message, networkManager);
        }
        closeChat();
      });
    });
  }
}

/**
 * Open the chat input
 */
function openChat() {
  isChatActive = true;
  chatInputContainer.style.display = 'block';
  chatInput.value = '';
  
  // Add active class to chat container for styling
  chatContainer.classList.add('active');
  
  // Unlock pointer for chat interaction
  if (document.pointerLockElement) {
    document.exitPointerLock();
  }
  
  // Disable game controls while chat is active
  disableGameControls();
  
  // Special handling for mobile keyboards
  if (isMobileDevice()) {
    // Create and append a temporary button that we'll click/focus to help trigger the keyboard
    const tempButton = document.createElement('button');
    tempButton.style.position = 'fixed';
    tempButton.style.bottom = '0';
    tempButton.style.right = '0';
    tempButton.style.width = '1px';
    tempButton.style.height = '1px';
    tempButton.style.opacity = '0.01';
    tempButton.style.pointerEvents = 'none';
    document.body.appendChild(tempButton);
    
    // Force iOS Safari to show keyboard
    setTimeout(() => {
      // Remove readonly attribute completely
      chatInput.removeAttribute('readonly');
      
      // Use these attributes to help iOS Safari
      chatInput.setAttribute('autocomplete', 'off');
      chatInput.setAttribute('autocorrect', 'off');
      chatInput.setAttribute('autocapitalize', 'none');
      chatInput.style.fontSize = '16px'; // iOS Safari requires at least 16px
      
      // Click the temporary button to ensure iOS transitions focus properly
      tempButton.focus();
      tempButton.click();
      
      // Now focus and click the actual input
      chatInput.focus();
      chatInput.click();
      
      // Some iOS versions need a double focus attempt with delay
      setTimeout(() => {
        chatInput.focus();
        chatInput.click();
        
        // Remove the temporary button
        document.body.removeChild(tempButton);
      }, 50);
    }, 300);
  } else {
    chatInput.focus();
  }
}

/**
 * Close the chat input
 */
function closeChat() {
  isChatActive = false;
  chatInputContainer.style.display = 'none';
  chatInput.blur();
  
  // Remove active class from chat container
  chatContainer.classList.remove('active');
  
  // Re-lock pointer if game-container exists
  const gameContainer = document.getElementById('game-container');
  if (gameContainer) {
    const canvas = document.querySelector('canvas');
    if (canvas) {
      canvas.requestPointerLock();
    }
  }
  
  // Re-enable game controls
  enableGameControls();
}

/**
 * Disable game controls while chatting
 */
function disableGameControls() {
  // If there's a local player, disable its movement
  if (window.localPlayer) {
    window.localPlayer.chatActive = true;
  }
}

/**
 * Re-enable game controls after chat is closed
 */
function enableGameControls() {
  // Re-enable local player movement
  if (window.localPlayer) {
    window.localPlayer.chatActive = false;
  }
}

/**
 * Send a chat message to the server
 * @param {string} message - The message to send
 * @param {NetworkManager} networkManager - The network manager for sending messages
 */
function sendChatMessage(message, networkManager) {
  // Client-side rate limiting to give immediate feedback
  const now = Date.now();
  if (now - lastMessageTime < 2000) {
    addSystemMessage("Please wait 2 seconds between messages");
    return;
  }
  
  // Update last message timestamp
  lastMessageTime = now;
  
  // Get username from player identity or use default
  const username = window.playerIdentity?.username || 'Player';
  
  // Add message to local chat first (local player message)
  addChatMessage(username, message, true);
  
  // Send message to server if network is available
  if (networkManager && networkManager.socket && 
      networkManager.socket.readyState === WebSocket.OPEN) {
    networkManager.socket.send(JSON.stringify({
      type: 'chat',
      message: message
    }));
  }
}

/**
 * Add a chat message to the UI
 * @param {string} username - The username of the sender
 * @param {string} message - The message content
 * @param {boolean} isLocal - Whether this is the local player's message
 */
export function addChatMessage(username, message, isLocal = false) {
  // Avoid duplicate messages when receiving back your own message from server
  const localUsername = window.playerIdentity?.username || 'Player';
  if (!isLocal && username === localUsername && message === lastSentMessage) {
    lastSentMessage = null; // Reset after checking
    return;
  }
  
  const messageElement = document.createElement('div');
  messageElement.className = 'chat-message';
  
  const usernameSpan = document.createElement('span');
  usernameSpan.className = 'username';
  
  // Generate a color for the username based on the username string
  const color = getUsernameColor(username);
  
  usernameSpan.style.color = color;
  usernameSpan.textContent = username + ':';
  
  messageElement.appendChild(usernameSpan);
  messageElement.appendChild(document.createTextNode(' ' + message));
  
  chatMessages.appendChild(messageElement);
  messageCount++;
  
  // Update chat container size if needed
  updateChatPosition();
  
  // Auto scroll to bottom
  chatMessages.scrollTop = chatMessages.scrollHeight;
  
  // No fadeout or removal - messages persist indefinitely
}

/**
 * Add a system message to the chat
 * @param {string} message - The system message
 */
export function addSystemMessage(message) {
  const messageElement = document.createElement('div');
  messageElement.className = 'chat-message system-message';
  messageElement.textContent = 'SYSTEM: ' + message;
  
  chatMessages.appendChild(messageElement);
  messageCount++;
  
  // Update chat container size if needed
  updateChatPosition();
  
  // Auto scroll to bottom
  chatMessages.scrollTop = chatMessages.scrollHeight;
  
  // System messages persist indefinitely like regular messages
}

/**
 * Generate a consistent color for a username
 * @param {string} username - The username
 * @returns {string} - CSS color string
 */
function getUsernameColor(username) {
  // Generate a hash from username string
  let hash = 0;
  for (let i = 0; i < username.length; i++) {
    hash = username.charCodeAt(i) + ((hash << 5) - hash);
  }
  
  // Generate bright colors by using high saturation and lightness
  const h = Math.abs(hash) % 360;  // Hue (0-360)
  const s = 70 + (Math.abs(hash) % 30);  // Saturation (70-100%)
  const l = 60 + (Math.abs(hash) % 15);  // Lightness (60-75%)
  
  return `hsl(${h}, ${s}%, ${l}%)`;
}

/**
 * Handle incoming chat messages from other players
 * @param {Object} data - The chat message data from the server
 */
export function handleChatMessage(data) {
  addChatMessage(data.username, data.message);
}

/**
 * Check if chat is currently active
 * @returns {boolean} - True if chat input is active
 */
export function isChatInputActive() {
  return isChatActive;
}

/**
 * Update chat container position based on screen size
 */
export function updateChatPosition() {
  if (!chatContainer) return;
  
  const isMobile = isMobileDevice();
  
  if (isMobile) {
    // Mobile positioning - top left corner, transparent background
    chatContainer.style.position = 'fixed';
    chatContainer.style.top = '10px';
    chatContainer.style.left = '0px'; // Changed from 10px to 0px - more to the left
    chatContainer.style.width = '70%';
    chatContainer.style.maxHeight = '30%';
    chatContainer.style.backgroundColor = 'transparent';
    chatContainer.style.overflow = 'auto';
    
    // Update chat button link position if it exists
    const chatButton = document.getElementById('chat-mobile-link');
    if (chatButton) {
      chatButton.style.top = '10px';
      chatButton.style.left = '0px';
      chatButton.style.width = '70%';
      chatButton.style.height = '30%';
    }
    
    // Style input for mobile (hidden but keeping styles in case we need them)
    if (chatInputContainer) {
      chatInputContainer.style.position = 'fixed';
      chatInputContainer.style.top = '50%';
      chatInputContainer.style.left = '50%';
      chatInputContainer.style.transform = 'translate(-50%, -50%)';
      chatInputContainer.style.width = '80%';
      chatInputContainer.style.maxWidth = '400px';
      chatInputContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      chatInputContainer.style.padding = '10px';
      chatInputContainer.style.borderRadius = '5px';
    }
  } else {
    // Desktop positioning - bottom left corner
    const gameHeight = window.innerHeight;
    const chatHeight = Math.min(gameHeight * 0.25, 200); // Max 25% of game height or 200px
    
    chatContainer.style.position = 'absolute';
    chatContainer.style.bottom = '80px';
    chatContainer.style.left = '20px';
    chatContainer.style.width = '400px';
    chatContainer.style.maxHeight = `${chatHeight}px`;
    
    // Style input for desktop
    if (chatInputContainer) {
      chatInputContainer.style.position = 'absolute';
      chatInputContainer.style.bottom = '20px';
      chatInputContainer.style.left = '20px';
      chatInputContainer.style.width = '400px';
      chatInputContainer.style.backgroundColor = 'transparent';
      chatInputContainer.style.transform = 'none';
    }
    
    // Hide send button on desktop
    const sendButton = document.getElementById('chat-send-button');
    if (sendButton) {
      sendButton.style.display = 'none';
    }
    
    // Style chat input for desktop
    if (chatInput) {
      chatInput.style.width = '100%';
      chatInput.style.padding = '5px';
      chatInput.style.fontSize = '14px';
    }
  }
}

/**
 * Check if the user is on a mobile device
 * @returns {boolean} True if on mobile device
 */
function isMobileDevice() {
  return (window.innerWidth <= 1024 || 'ontouchstart' in window || 
          navigator.maxTouchPoints > 0 || 
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
} 

================================================
File: /public/js/desertTerrain.js
================================================
/**
 * Creates an endless procedural desert terrain around the town.
 * Based on Perlin noise for natural-looking dunes and terrain features.
 */

// A simple Perlin noise implementation for terrain generation
class PerlinNoise {
    constructor(seed = Math.random()) {
        this.seed = seed;
        this.perm = new Array(512);
        this.gradP = new Array(512);
        
        // Initialize permutation table
        const p = new Array(256);
        for (let i = 0; i < 256; i++) {
            p[i] = Math.floor(seed * 10000 + i) % 256;
        }
        
        // Populate permutation tables
        for (let i = 0; i < 512; i++) {
            this.perm[i] = p[i & 255];
            this.gradP[i] = this.gradients[this.perm[i] % 12];
        }
    }
    
    gradients = [
        [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
        [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
        [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
    ];
    
    fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }
    
    lerp(a, b, t) {
        return (1 - t) * a + t * b;
    }
    
    grad(hash, x, y, z) {
        const g = this.gradP[hash];
        return g[0] * x + g[1] * y + g[2] * z;
    }
    
    noise(x, y, z = 0) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        const Z = Math.floor(z) & 255;
        
        x -= Math.floor(x);
        y -= Math.floor(y);
        z -= Math.floor(z);
        
        const u = this.fade(x);
        const v = this.fade(y);
        const w = this.fade(z);
        
        const A = this.perm[X] + Y;
        const AA = this.perm[A] + Z;
        const AB = this.perm[A + 1] + Z;
        const B = this.perm[X + 1] + Y;
        const BA = this.perm[B] + Z;
        const BB = this.perm[B + 1] + Z;
        
        return this.lerp(
            this.lerp(
                this.lerp(this.grad(this.perm[AA], x, y, z), this.grad(this.perm[BA], x - 1, y, z), u),
                this.lerp(this.grad(this.perm[AB], x, y - 1, z), this.grad(this.perm[BB], x - 1, y - 1, z), u),
                v
            ),
            this.lerp(
                this.lerp(this.grad(this.perm[AA + 1], x, y, z - 1), this.grad(this.perm[BA + 1], x - 1, y, z - 1), u),
                this.lerp(this.grad(this.perm[AB + 1], x, y - 1, z - 1), this.grad(this.perm[BB + 1], x - 1, y - 1, z - 1), u),
                v
            ),
            w
        );
    }
}

export class DesertTerrain {
    constructor(scene, townDimensions) {
        this.scene = scene;
        this.townDimensions = townDimensions;
        
        // Calculate optimal terrain size based on town dimensions
        const townSize = Math.max(townDimensions.width, townDimensions.length);
        const desertSize = Math.max(5000, townSize * 25); // At least 25x larger than town
        
        // Setup with appropriate settings
        this.config = {
            size: desertSize, // Size based on town dimensions
            resolution: 196, // Resolution of the terrain (vertices per side)
            cactiCount: 120, // Number of cacti to place (increased from 60)
            noiseScale: {
                base: 0.0003,
                dunes: 0.0008,
                secondaryDunes: 0.0015,
                ridges: 0.003,
                detail: 0.01,
                flat: 0.0003,
                // Enhanced micro-detail scales for more prominent sand ripples
                microRipples: 0.04, // Adjusted for better groove definition
                sandGrains: 0.3
            },
            heightScale: {
                base: 15,
                dunes: 40, // Reduced from 70 for lower dune heights
                secondaryDunes: 20, // Reduced from 30
                ridges: 10, // Reduced from 15
                detail: 8,
                // Increased height adjustments for more pronounced micro-detail
                microRipples: 2.0, // Increased for more visible grooves
                sandGrains: 0.3  // Slightly increased from 0.2
            },
            duneDirection: Math.PI * 0.25, // Wind direction
            sandColors: [
                new THREE.Color(0xec9e5c), // Base sand color
                new THREE.Color(0xd4884a), // Slightly darker
                new THREE.Color(0xf7b777), // Slightly lighter
                new THREE.Color(0xb7703e), // Darker/shadow areas
                new THREE.Color(0xffc890)  // Highlight areas
            ],
            distanceBlur: {
                enabled: true,
                startDistance: desertSize * 0.35, // Start blurring at 35% distance from center
                endDistance: desertSize * 0.5,    // Maximum blur at edge
                skyboxColor: new THREE.Color(0xaad6f5), // Light blue to match skybox horizon
                atmosphericHaze: true,            // Enable atmospheric haze on dunes
                hazeStartDistance: desertSize * 0.15, // Start atmospheric effect closer
                hazeFactor: 0.6                  // Strength of the atmospheric effect
            },
            dunes: {
                smoothing: true,          // Enable dune edge smoothing
                smoothingFactor: 0.7,     // How much to smooth dune edges (0-1)
                ridgeSharpness: 0.4       // Reduced ridge sharpness (0-1)
            },
            townBuffer: townSize * 1.2 // Buffer distance around town where terrain is flat
        };
        
        console.log(`Creating desert terrain with size ${desertSize} around town of size ${townSize}`);
        
        // Create noise generators
        this.baseNoise = new PerlinNoise(Math.random());
        this.duneNoise = new PerlinNoise(Math.random() + 100);
        this.secondaryDuneNoise = new PerlinNoise(Math.random() + 150);
        this.ridgeNoise = new PerlinNoise(Math.random() + 175);
        this.detailNoise = new PerlinNoise(Math.random() + 200);
        this.colorNoise = new PerlinNoise(Math.random() + 300);
        // Add micro-detail noise generators
        this.microRipplesNoise = new PerlinNoise(Math.random() + 400);
        this.sandGrainsNoise = new PerlinNoise(Math.random() + 500);
    }
    
    // Create directional dunes effect
    getDirectionalDuneHeight(x, z) {
        // Extract directional component based on wind angle
        const direction = this.config.duneDirection;
        
        // Rotate coordinates based on wind direction
        const rotX = x * Math.cos(direction) + z * Math.sin(direction);
        const rotZ = -x * Math.sin(direction) + z * Math.cos(direction);
        
        // Sample noise for directional dune patterns
        const duneHeight = this.duneNoise.noise(
            rotX * this.config.noiseScale.dunes,
            rotZ * this.config.noiseScale.dunes * 0.5
        ) * this.config.heightScale.dunes;
        
        // Add secondary dune system
        const secondaryHeight = this.secondaryDuneNoise.noise(
            rotX * this.config.noiseScale.secondaryDunes,
            rotZ * this.config.noiseScale.secondaryDunes
        ) * this.config.heightScale.secondaryDunes;
        
        // Add ridge details with reduced sharpness
        const ridges = this.ridgeNoise.noise(
            rotX * this.config.noiseScale.ridges,
            rotZ * this.config.noiseScale.ridges
        );
        
        // Create smoother ridges if smoothing is enabled
        let ridgeHeight;
        if (this.config.dunes.smoothing) {
            // Use a smoother curve for ridge calculation
            const smoothedRidge = (Math.abs(ridges * 2 - 1));
            // Apply smoothing factor
            const smoothingPower = 1.0 + this.config.dunes.smoothingFactor * 2.0;
            ridgeHeight = Math.pow(smoothedRidge, smoothingPower) * this.config.heightScale.ridges;
            
            // Further reduce sharp edges by applying a gentler curve
            ridgeHeight *= this.config.dunes.ridgeSharpness;
        } else {
            // Original ridge calculation
            ridgeHeight = (Math.abs(ridges * 2 - 1)) * this.config.heightScale.ridges;
        }
        
        return duneHeight + secondaryHeight + ridgeHeight;
    }
    
    // Check if a point is near the train track
    isNearTrainTrack(x, z) {
        // Access global train track constants
        const trackStart = window.TRAIN_TRACK_START || new THREE.Vector3(0, 0, -1000);
        const trackEnd = window.TRAIN_TRACK_END || new THREE.Vector3(0, 0, 1000);
        
        // Width of the flattened area on each side of the track (1m as requested)
        const trackWidth = 1.0;
        
        // Create a line segment representing the track
        const trackVector = new THREE.Vector3().subVectors(trackEnd, trackStart).normalize();
        const pointVector = new THREE.Vector3(x, 0, z);
        
        // Calculate the projection of the point onto the track line
        const trackStartToPoint = new THREE.Vector3().subVectors(pointVector, trackStart);
        const dotProduct = trackStartToPoint.dot(trackVector);
        
        // Clamp the projection to the track segment
        const projectionScalar = Math.max(0, Math.min(dotProduct, trackEnd.distanceTo(trackStart)));
        
        // Calculate the closest point on the track
        const closestPoint = new THREE.Vector3().copy(trackStart).addScaledVector(trackVector, projectionScalar);
        
        // Calculate the distance from the point to the closest point on the track
        const distance = pointVector.distanceTo(closestPoint);
        
        // Check if the point is within the track width and within the track segment
        return distance <= trackWidth && projectionScalar >= 0 && projectionScalar <= trackEnd.distanceTo(trackStart);
    }
    
    // Get blend factor for town area (0 = in town, 1 = full desert)
    getTownBlendFactor(x, z) {
        // Calculate distance from town center
        const distFromTown = Math.sqrt(x * x + z * z);
        
        // Check if point is near train track
        const isOnTrack = this.isNearTrainTrack(x, z);
        
        // If near train track, return 0 to make it flat
        if (isOnTrack) {
            return 0;
        }
        
        // Normal town blending
        if (distFromTown < this.config.townBuffer) {
            // Completely flat within town
            return 0;
        } else if (distFromTown < this.config.townBuffer * 1.5) {
            // Gradual transition at edge of town
            const transitionFactor = (distFromTown - this.config.townBuffer) / (this.config.townBuffer * 0.5);
            return Math.pow(transitionFactor, 2.0); // Squared for smoother transition
        } else {
            // Full desert terrain
            return 1.0;
        }
    }
    
    // Generate terrain mesh
    generateTerrain() {
        // Create textures for sand
        const normalMapTexture = this.createSandNormalMap();
        const roughnessTexture = this.createSandRoughnessMap();
        
        // Create geometry
        const geometry = new THREE.PlaneGeometry(
            this.config.size, 
            this.config.size, 
            this.config.resolution, 
            this.config.resolution
        );
        
        geometry.rotateX(-Math.PI / 2);
        
        const vertices = geometry.attributes.position.array;
        
        // Create vertex colors array
        const colors = new Float32Array(vertices.length);
        
        // Edge fade values
        const edgeFadeStart = this.config.size * 0.4; // Start fading at 40% from center
        const edgeFadeEnd = this.config.size * 0.5;   // Complete fade at edge
        
        // Create buffer for vertex height adjustments (for sand waves)
        const heightAtEdge = this.config.size * 0.03;  // Raise edges slightly to blend with sky better
        
        // Apply noise to create terrain
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 2];
            
            // Calculate distance from center for edge blending
            const distFromCenter = Math.sqrt(x * x + z * z);
            
            // Calculate town blend factor (0 = flat town area, 1 = full desert)
            const townBlend = this.getTownBlendFactor(x, z);
            
            // Base terrain
            let height = this.baseNoise.noise(x * this.config.noiseScale.base, z * this.config.noiseScale.base) * this.config.heightScale.base;
            
            // Add directional dunes with smoothing
            let duneHeight = this.getDirectionalDuneHeight(x, z);
            
            // Smooth transitions between dunes for more natural silhouettes
            if (this.config.dunes.smoothing) {
                // Apply additional smoothing to dune transitions
                const smoothingNoise = this.baseNoise.noise(
                    x * this.config.noiseScale.dunes * 2,
                    z * this.config.noiseScale.dunes * 2
                );
                
                // Use noise to slightly adjust dune height in a natural way
                duneHeight *= (0.85 + smoothingNoise * 0.3);
            }
            
            // Apply town blend factor to terrain height
            height += duneHeight * townBlend;
            
            // Add small ripples to dunes (more pronounced farther from town)
            const detailHeight = this.detailNoise.noise(x * this.config.noiseScale.detail, z * this.config.noiseScale.detail) 
                * this.config.heightScale.detail;
            height += detailHeight * Math.min(1, duneHeight / 20) * townBlend;
            
            // Add micro-ripples from wind patterns - aligned with wind direction
            const windDirection = this.config.duneDirection;
            const alignedX = x * Math.cos(windDirection) + z * Math.sin(windDirection);
            const alignedZ = -x * Math.sin(windDirection) + z * Math.cos(windDirection);
            
            // More pronounced micro-ripples
            const microRipples = this.microRipplesNoise.noise(
                alignedX * this.config.noiseScale.microRipples,
                alignedZ * this.config.noiseScale.microRipples * 5 // More stretching for pronounced directional ripples
            ) * this.config.heightScale.microRipples;
            
            // Create additional small ripple detail for more complex patterns
            const secondaryRipples = this.microRipplesNoise.noise(
                alignedX * this.config.noiseScale.microRipples * 2,
                alignedZ * this.config.noiseScale.microRipples * 7
            ) * this.config.heightScale.microRipples * 0.4;
            
            // Add sand grain detail for very close-up detail
            const sandGrains = this.sandGrainsNoise.noise(
                x * this.config.noiseScale.sandGrains,
                z * this.config.noiseScale.sandGrains
            ) * this.config.heightScale.sandGrains;
            
            // Apply micro-detail based on distance from town (more detail in desert areas)
            height += (microRipples + secondaryRipples + sandGrains) * townBlend;
            
            // Add occasional flat areas (dried lake beds)
            const flatArea = this.baseNoise.noise(x * this.config.noiseScale.flat + 500, z * this.config.noiseScale.flat + 500);
            if (flatArea > 0.6 && townBlend > 0.8) {
                height *= 0.2;
            }
            
            // Apply edge blending - gradually reduce height near edges
            if (distFromCenter > edgeFadeStart) {
                const edgeFactor = 1.0 - Math.min(1, (distFromCenter - edgeFadeStart) / (edgeFadeEnd - edgeFadeStart));
                height *= edgeFactor;
            }
            
            // Apply height to vertex
            vertices[i + 1] = height;
            
            // Calculate color index
            const colorNoise = this.colorNoise.noise(
                x * this.config.noiseScale.base * 2, 
                z * this.config.noiseScale.base * 2
            );
            
            // Calculate slope for color variation (approximation)
            let slope = 0;
            if (i > 3 && i < vertices.length - 3) {
                const prevHeight = vertices[i - 2];
                const nextHeight = vertices[i + 4];
                slope = Math.abs(nextHeight - prevHeight) / 2;
            }
            
            // Blend different sand colors
            const heightFactor = Math.max(0, Math.min(1, (height + 10) / 80));
            
            // Start with base color
            let finalColor = this.config.sandColors[0].clone();
            
            // Add darker sand in valleys
            if (heightFactor < 0.5) {
                finalColor.lerp(this.config.sandColors[1], 0.5 - heightFactor);
            }
            
            // Add lighter sand on peaks
            if (heightFactor > 0.5) {
                finalColor.lerp(this.config.sandColors[2], (heightFactor - 0.5) * 2);
            }
            
            // Add random variation
            if (colorNoise > 0) {
                finalColor.lerp(this.config.sandColors[4], colorNoise * 0.3);
            } else {
                finalColor.lerp(this.config.sandColors[3], -colorNoise * 0.3);
            }
            
            // Add slope-based coloring
            if (slope > 0.2) {
                const slopeFactor = Math.min(1, (slope - 0.2) * 5);
                finalColor.lerp(this.config.sandColors[3], slopeFactor * 0.5);
            }
            
            // Add micro-ripple highlights and shadows
            const microDetail = microRipples / this.config.heightScale.microRipples;
            if (microDetail > 0.3) {
                // Add highlights to ripple peaks
                finalColor.lerp(this.config.sandColors[4], (microDetail - 0.3) * 0.2);
            } else if (microDetail < -0.3) {
                // Add shadows to ripple valleys
                finalColor.lerp(this.config.sandColors[3], Math.abs(microDetail + 0.3) * 0.2);
            }
            
            // Store color
            const colorIdx = i;
            colors[colorIdx] = finalColor.r;
            colors[colorIdx + 1] = finalColor.g;
            colors[colorIdx + 2] = finalColor.b;
            
            // Apply atmospheric haze effect to dune edges and higher areas
            if (this.config.distanceBlur.atmosphericHaze && distFromCenter > this.config.distanceBlur.hazeStartDistance) {
                // Calculate haze factor based on distance and height
                const distanceFactor = Math.min(1.0, (distFromCenter - this.config.distanceBlur.hazeStartDistance) / 
                                   (this.config.distanceBlur.endDistance - this.config.distanceBlur.hazeStartDistance));
                
                // More haze on higher terrain (silhouettes against sky)
                const heightFactor = Math.min(1.0, height / (this.config.heightScale.dunes * 0.5));
                
                // Combine factors with configurable intensity
                const hazeFactor = distanceFactor * heightFactor * this.config.distanceBlur.hazeFactor;
                
                // Apply more intense sky color blending to higher dunes
                const skyColorBlend = this.config.distanceBlur.skyboxColor.clone();
                
                // Apply haze color blend
                colors[colorIdx] = finalColor.r * (1 - hazeFactor) + skyColorBlend.r * hazeFactor;
                colors[colorIdx + 1] = finalColor.g * (1 - hazeFactor) + skyColorBlend.g * hazeFactor;
                colors[colorIdx + 2] = finalColor.b * (1 - hazeFactor) + skyColorBlend.b * hazeFactor;
            }
            
            // Apply distance blur/fog effect by blending with skybox color at edges
            if (this.config.distanceBlur.enabled && distFromCenter > this.config.distanceBlur.startDistance) {
                const blurFactor = Math.min(1.0, (distFromCenter - this.config.distanceBlur.startDistance) / 
                                       (this.config.distanceBlur.endDistance - this.config.distanceBlur.startDistance));
                
                // Apply stronger color blend for more dramatic effect
                colors[colorIdx] = colors[colorIdx] * (1 - blurFactor) + this.config.distanceBlur.skyboxColor.r * blurFactor;
                colors[colorIdx + 1] = colors[colorIdx + 1] * (1 - blurFactor) + this.config.distanceBlur.skyboxColor.g * blurFactor;
                colors[colorIdx + 2] = colors[colorIdx + 2] * (1 - blurFactor) + this.config.distanceBlur.skyboxColor.b * blurFactor;
                
                // Gradually raise the terrain at edges to create a smooth blend with sky
                if (distFromCenter > this.config.distanceBlur.startDistance) {
                    const heightBlendFactor = Math.pow(blurFactor, 2.0); // Stronger curve for height adjustment
                    vertices[i + 1] += heightAtEdge * heightBlendFactor;
                }
            }
        }
        
        // Add colors to geometry
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.computeVertexNormals();
        
        // Create sand material with textures
        const sandMaterial = new THREE.MeshPhongMaterial({
            vertexColors: true,
            shininess: 0,
            specular: new THREE.Color(0x000000),
            normalMap: normalMapTexture,
            normalScale: new THREE.Vector2(1.2, 1.2),
            fog: true
        });
        
        // Ensure no environment reflections
        sandMaterial.envMap = null;
        
        // No custom shader modifications - rely on the built-in fog system and vertex colors
        
        // Create terrain mesh
        this.terrainMesh = new THREE.Mesh(geometry, sandMaterial);
        this.terrainMesh.receiveShadow = true;
        this.terrainMesh.castShadow = true;
        
        // Position the terrain mesh a tiny bit below the current ground plane
        // to avoid z-fighting and ensure seamless transition
        this.terrainMesh.position.y = -0.05;
        
        // Center the terrain on the town's center (0,0,0)
        // This ensures the town is in the center of our desert terrain
        this.terrainMesh.position.set(0, -0.05, 0);
        
        this.scene.add(this.terrainMesh);
        
        return this.terrainMesh;
    }
    
    // Create a procedural normal map for sand texture
    createSandNormalMap() {
        const size = 1024;
        const data = new Uint8Array(size * size * 4);
        const normalStrength = 40; // Increased from 30 to restore groove visibility
        
        // Generate sand ripple and grain patterns using noise
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                // Calculate normalized coordinates
                const nx = x / size;
                const ny = y / size;
                
                // Multiple layers of noise for different scales of detail
                // Wind ripples - elongated with directional flow
                const windDirection = this.config.duneDirection;
                const windAlignedX = nx * Math.cos(windDirection) + ny * Math.sin(windDirection);
                const windAlignedY = -nx * Math.sin(windDirection) + ny * Math.cos(windDirection);
                
                // Enhanced ripple pattern - more pronounced
                const ripples = this.microRipplesNoise.noise(
                    windAlignedX * 35,
                    windAlignedY * 12
                ) * 1.8;
                
                // Fine sand grain texture
                const grains = this.sandGrainsNoise.noise(nx * 200, ny * 200) * 0.2;
                
                // Medium-scale variations
                const mediumVar = this.detailNoise.noise(nx * 40, ny * 40) * 0.5;
                
                // Combine layers - emphasize ripples more but with balanced intensity
                const combined = ripples * 0.8 + grains * 0.3 + mediumVar * 0.2; // Adjusted weights to better show grooves
                
                // Convert to normal map values
                // Calculate local derivatives for normal
                const idx = (y * size + x) * 4;
                
                // Calculate height differences for normal approximation
                const left = x > 0 ? ripples * 0.8 + this.sandGrainsNoise.noise((nx - 1/size) * 200, ny * 200) * 0.2 + 
                    this.detailNoise.noise((nx - 1/size) * 40, ny * 40) * 0.3 : combined;
                const right = x < size-1 ? ripples * 0.8 + this.sandGrainsNoise.noise((nx + 1/size) * 200, ny * 200) * 0.2 +
                    this.detailNoise.noise((nx + 1/size) * 40, ny * 40) * 0.3 : combined;
                const up = y > 0 ? ripples * 0.8 + this.sandGrainsNoise.noise(nx * 200, (ny - 1/size) * 200) * 0.2 +
                    this.detailNoise.noise(nx * 40, (ny - 1/size) * 40) * 0.3 : combined;
                const down = y < size-1 ? ripples * 0.8 + this.sandGrainsNoise.noise(nx * 200, (ny + 1/size) * 200) * 0.2 +
                    this.detailNoise.noise(nx * 40, (ny + 1/size) * 40) * 0.3 : combined;
                
                // X normal component (R)
                data[idx] = Math.min(255, Math.max(0, 128 + normalStrength * (right - left)));
                // Y normal component (G)
                data[idx + 1] = Math.min(255, Math.max(0, 128 + normalStrength * (down - up)));
                // Z normal component (B) - always positive since we're looking at the top
                data[idx + 2] = 255;
                // Alpha
                data[idx + 3] = 255;
            }
        }
        
        // Create texture from data
        const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(15, 15); // Reduced from 20 to make patterns larger
        texture.needsUpdate = true;
        
        return texture;
    }
    
    // Create a procedural roughness map for sand texture
    createSandRoughnessMap() {
        const size = 512;
        const data = new Uint8Array(size * size);
        
        // Generate sand grain patterns
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                // Calculate normalized coordinates
                const nx = x / size;
                const ny = y / size;
                
                // Multi-layer noise for varying roughness
                const baseRoughness = 245; // High base roughness
                
                // Wind direction-aligned roughness variation (simulates sand accumulation)
                const windDirection = this.config.duneDirection;
                const alignedX = nx * Math.cos(windDirection) + ny * Math.sin(windDirection);
                const alignedY = -nx * Math.sin(windDirection) + ny * Math.cos(windDirection);
                
                // More pronounced wind ripples with stronger contrast for roughness variation
                const windPattern = this.microRipplesNoise.noise(alignedX * 30, alignedY * 8);
                
                // Fine grain roughness detail
                const fineGrains = this.sandGrainsNoise.noise(nx * 300, ny * 300) * 5;
                
                // Calculate final roughness value - higher in troughs, slightly lower on crests
                // This variation helps with visual appearance while keeping overall roughness high
                const roughness = Math.min(255, Math.max(230, 
                    baseRoughness + (windPattern < 0 ? 10 : -5) + fineGrains
                ));
                
                // Store the value
                data[y * size + x] = roughness;
            }
        }
        
        // Create texture from data
        const texture = new THREE.DataTexture(data, size, size, THREE.RedFormat);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(20, 20);
        texture.needsUpdate = true;
        
        return texture;
    }
    
    // Add cacti to the scene
    addCacti() {
        // Create cactus materials
        const cactusMaterial = new THREE.MeshStandardMaterial({
            color: 0x2d5c2d,
            roughness: 0.8,
            metalness: 0.2,
        });
        
        // Cactus segments to be instanced
        const segmentGeometries = [
            // Main trunk (shorter now)
            this.createCactusTrunk(2.5, 4, 20, 8),
            // Arm segment (horizontal part)
            this.createCactusArm(1.8, 2.2, 8, 8),
            // Arm tip (vertical part) 
            this.createCactusTrunk(1.5, 1.8, 12, 8),
        ];
        
        // Create instanced mesh for each geometry type
        const cactusCount = this.config.cactiCount;
        const instancedSegments = [];
        
        // Create instanced mesh for each segment type
        for (let i = 0; i < segmentGeometries.length; i++) {
            const instancedMesh = new THREE.InstancedMesh(
                segmentGeometries[i],
                cactusMaterial,
                cactusCount * (i === 0 ? 1 : 2) // One trunk per cactus, two arms per cactus
            );
            instancedMesh.castShadow = true;
            instancedMesh.receiveShadow = true;
            instancedSegments.push(instancedMesh);
        }
        
        // Helper matrices and vectors
        const matrix = new THREE.Matrix4();
        const position = new THREE.Vector3();
        const rotation = new THREE.Euler();
        const quaternion = new THREE.Quaternion();
        const scale = new THREE.Vector3();
        
        // Create cacti in a ring pattern around the town
        for (let i = 0; i < cactusCount; i++) {
            // Random position avoiding town center area using a ring distribution
            let x, z, townBlend;
            const angle = Math.random() * Math.PI * 2; // Random angle around circle
            const minRadius = Math.max(this.townDimensions.width, this.townDimensions.length) + 150; // Min distance from town center
            const maxRadius = this.config.size * 0.3; // Max distance from town center
            
            // Calculate position in a ring around the town
            const radius = minRadius + Math.random() * (maxRadius - minRadius);
            x = Math.cos(angle) * radius;
            z = Math.sin(angle) * radius;
            
            // Verify this position is in the desert part of the terrain
            townBlend = this.getTownBlendFactor(x, z);
            
            // If not in desert, try again with a larger radius
            if (townBlend < 0.9) {
                const adjustedRadius = minRadius * 1.2;
                x = Math.cos(angle) * adjustedRadius;
                z = Math.sin(angle) * adjustedRadius;
                townBlend = this.getTownBlendFactor(x, z);
            }
            
            // Calculate height based on terrain
            const baseHeight = this.baseNoise.noise(x * this.config.noiseScale.base, z * this.config.noiseScale.base) 
                * this.config.heightScale.base;
            const duneHeight = this.getDirectionalDuneHeight(x, z);
            const y = baseHeight + duneHeight;
            
            // Random scale and rotation
            const cactusScale = 0.3 + Math.random() * 0.5; // Slightly smaller scale range
            const trunkRotation = Math.random() * Math.PI * 2;
            
            // Position and orient the trunk
            position.set(x, y, z);
            rotation.set(0, trunkRotation, 0);
            quaternion.setFromEuler(rotation);
            scale.set(cactusScale, cactusScale, cactusScale);
            
            matrix.compose(position, quaternion, scale);
            instancedSegments[0].setMatrixAt(i, matrix);
            
            // Add arms to the cactus with varying heights and angles
            for (let arm = 0; arm < 2; arm++) {
                // Calculate arm position on the trunk
                const armHeight = 5 + Math.random() * 8; // Lower arm position
                const armAngle = arm * Math.PI + (Math.random() * 0.5 - 0.25);
                const armLength = 4 + Math.random() * 3;
                
                // Horizontal arm segment
                const armX = x + Math.cos(trunkRotation + armAngle) * 2 * cactusScale;
                const armZ = z + Math.sin(trunkRotation + armAngle) * 2 * cactusScale;
                const armY = y + armHeight * cactusScale;
                
                position.set(armX, armY, armZ);
                rotation.set(Math.PI/2, trunkRotation + armAngle + Math.PI/2, 0);
                quaternion.setFromEuler(rotation);
                
                matrix.compose(position, quaternion, scale);
                instancedSegments[1].setMatrixAt(i * 2 + arm, matrix);
                
                // Vertical arm tip
                const tipX = armX + Math.cos(trunkRotation + armAngle) * armLength * cactusScale;
                const tipZ = armZ + Math.sin(trunkRotation + armAngle) * armLength * cactusScale;
                const tipY = armY;
                
                position.set(tipX, tipY, tipZ);
                rotation.set(0, trunkRotation, 0);
                quaternion.setFromEuler(rotation);
                
                matrix.compose(position, quaternion, scale);
                instancedSegments[2].setMatrixAt(i * 2 + arm, matrix);
            }
        }
        
        // Update matrices and add to scene
        for (const instancedMesh of instancedSegments) {
            instancedMesh.instanceMatrix.needsUpdate = true;
            this.scene.add(instancedMesh);
        }
        
        return instancedSegments;
    }
    
    // Create a cactus trunk segment
    createCactusTrunk(topRadius, bottomRadius, height, segments) {
        const geometry = new THREE.CylinderGeometry(topRadius, bottomRadius, height, segments);
        geometry.translate(0, height/2, 0);
        return geometry;
    }
    
    // Create a cactus arm segment (horizontal part)
    createCactusArm(topRadius, bottomRadius, length, segments) {
        const geometry = new THREE.CylinderGeometry(topRadius, bottomRadius, length, segments);
        geometry.rotateZ(Math.PI/2);
        geometry.translate(length/2, 0, 0);
        return geometry;
    }
    
    // Generate the entire desert environment
    generate() {
        console.log("Generating procedural desert terrain...");
        
        // Generate terrain mesh
        this.generateTerrain();
        
        // Add cacti
        this.addCacti();
        
        console.log("Desert terrain generation complete");
    }
} 

================================================
File: /public/js/effects.js
================================================
// Import the SmokeRingEffect class 
import { SmokeRingEffect } from './smokeRingEffect.js';

/**
 * Recursively disposes geometry and material for the given object.
 * @param {THREE.Object3D} object - The object to dispose.
 */
function disposeHierarchy(object) {
  object.traverse(child => {
    if (child.geometry) child.geometry.dispose();
    if (child.material) {
      if (Array.isArray(child.material)) {
        child.material.forEach(mat => mat.dispose());
      } else {
        child.material.dispose();
      }
    }
  });
}

/**
 * Helper for spring interpolation used in recoil recovery.
 * @param {number} start - The starting value.
 * @param {number} end - The target value.
 * @param {number} t - Normalized time.
 * @param {number} damping - Damping coefficient.
 * @param {number} frequency - Oscillation frequency.
 * @returns {number} - The interpolated value.
 */
function springInterpolation(start, end, t, damping, frequency) {
  const decay = Math.exp(-damping * t);
  return end + (start - end) * decay * (1 + (damping / frequency) * Math.sin(frequency * t));
}

/**
 * Creates a muzzle flash effect at the given position with the specified direction
 * @param {THREE.Vector3} position - Starting position of the muzzle flash
 * @param {THREE.Vector3} direction - Direction the flash should face
 * @param {THREE.Scene} scene - The scene to add the effect to
 * @param {Object} options - Optional configuration for the effect
 * @param {boolean} isPreloading - Whether this is being created for preloading
 * @returns {Object} The created flash group and meshes for preloading
 */
export function createMuzzleFlash(position, direction, scene, options = null, isPreloading = false) {
  // Skip on mobile devices
  if (window.isMobile && !isPreloading) {
    return;
  }
  
  // Create flash group
  const flashGroup = new THREE.Group();
  flashGroup.position.copy(position);
  
  // Make the flash face the direction of fire
  flashGroup.lookAt(position.clone().add(direction));
  
  // Add to scene
  scene.add(flashGroup);
  
  // Configure flash based on options
  const flashSize = (options && options.size) || 0.2;
  const flashColor = (options && options.color) || 0xFFF7D6;
  const flashDuration = (options && options.duration) || 0.05;
  
  // Create core flash - using MeshBasicMaterial without emissive properties
  const flashGeometry = new THREE.IcosahedronGeometry(flashSize, 1);
  const flashMaterial = new THREE.MeshBasicMaterial({
    color: flashColor,
    transparent: true,
    opacity: 0.9
  });
  const flash = new THREE.Mesh(flashGeometry, flashMaterial);
  
  // Position the flash slightly in front
  flash.position.z = 0.1;
  
  // Add some random rotation
  flash.rotation.x = Math.random() * Math.PI;
  flash.rotation.y = Math.random() * Math.PI;
  flash.rotation.z = Math.random() * Math.PI;
  
  // Add flash to group
  flashGroup.add(flash);
  
  // Add a glow for better visibility - using MeshBasicMaterial without emissive properties
  const glowGeometry = new THREE.IcosahedronGeometry(flashSize * 1.5, 0);
  const glowMaterial = new THREE.MeshBasicMaterial({
    color: flashColor,
    transparent: true,
    opacity: 0.5
  });
  const glow = new THREE.Mesh(glowGeometry, glowMaterial);
  
  // Position the glow slightly in front and larger
  glow.position.z = 0.05;
  glow.scale.set(1.5, 1.5, 0.5);
  
  // Add glow to group
  flashGroup.add(glow);
  
  // Create animation tracking variables
  const startTime = performance.now();
  const endTime = startTime + flashDuration * 1000;
  
  // Store references needed for the animation
  // This closure makes everything accessible to the animateFlash function
  const animation = { startTime, endTime, flash, glow, flashGroup };
  
  // Function to animate the flash
  function animateFlash(timestamp) {
    // Calculate how far through the animation we are (0 to 1)
    const elapsed = timestamp - animation.startTime;
    const duration = animation.endTime - animation.startTime;
    const progress = Math.min(elapsed / duration, 1);
    
    // If animation complete, remove from scene
    if (progress >= 1) {
      if (!isPreloading) {
        scene.remove(animation.flashGroup);
        animation.flash.geometry.dispose();
        animation.flash.material.dispose();
        animation.glow.geometry.dispose();
        animation.glow.material.dispose();
      }
      return false;
    }
    
    // Create a decay curve - quick fade out
    // Use quadratic easing for more visual pop at the start
    const opacityFactor = 1 - (progress * progress);
    
    // Update materials
    animation.flash.material.opacity = 0.9 * opacityFactor;
    animation.glow.material.opacity = 0.5 * opacityFactor;
    
    // Scale down as it fades
    const scaleFactor = 1 - progress * 0.3;
    animation.flashGroup.scale.set(scaleFactor, scaleFactor, 1);
    
    // Continue animation
    if (!isPreloading) {
      requestAnimationFrame(animateFlash);
    }
    return true;
  }
  
  // Start animation loop if not preloading (preloading will call this manually)
  if (!isPreloading) {
    requestAnimationFrame(animateFlash);
  }
  
  // Return objects needed for preloading
  return { flashGroup, flash, glow, animateFlash };
}

/**
 * Creates a smoke effect at the given position with the specified direction
 * @param {THREE.Vector3} position - Starting position of the smoke
 * @param {THREE.Vector3} direction - Direction the smoke should face
 * @param {THREE.Scene} scene - The scene to add the effect to
 * @param {boolean} isPreloading - Whether this is being created for preloading
 * @returns {Object} The created smoke group and particles for preloading
 */
export function createSmokeEffect(position, direction, scene, isPreloading = false) {
  // Create a group for the smoke particles
  const smokeGroup = new THREE.Group();
  smokeGroup.position.copy(position);
  
  // Orient the smoke in the direction of fire
  smokeGroup.lookAt(position.clone().add(direction));
  
  // Add to scene
  scene.add(smokeGroup);
  
  // Generate a random number of particles
  const numParticles = Math.floor(5 + Math.random() * 3);
  const particles = [];
  
  // Create individual smoke particles
  for (let i = 0; i < numParticles; i++) {
    // Random size for each particle
    const size = 0.01 + Math.random() * 0.02;
    
    // Create geometry
    const particleGeometry = new THREE.IcosahedronGeometry(size, 0);
    
    // Smoke material - semi-transparent gray
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xCCCCCC,
      transparent: true,
      opacity: 0.3 + Math.random() * 0.4
    });
    
    // Create mesh
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    
    // Random initial position with slight offset from center
    const offset = 0.03;
    particle.position.set(
      (Math.random() - 0.5) * offset,
      (Math.random() - 0.5) * offset,
      (Math.random() - 0.5) * offset
    );
    
    // Random rotation
    particle.rotation.set(
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2
    );
    
    // Add to group
    smokeGroup.add(particle);
    
    // Generate velocity for this particle
    // Base direction is the fire direction but with added spread
    const spread = 0.3;
    const vel = direction.clone().normalize();
    
    // Add some randomization to velocity
    vel.x += (Math.random() - 0.5) * spread;
    vel.y += (Math.random() - 0.5) * spread;
    vel.z += (Math.random() - 0.5) * spread;
    
    // Scale velocity by a random factor
    vel.multiplyScalar(0.3 + Math.random() * 0.5);
    
    // Store particle properties
    particles.push({
      mesh: particle,
      velocity: vel,
      life: 0,
      maxLife: 0.5 + Math.random() * 0.5
    });
  }
  
  // Animation variables
  const startTime = performance.now();
  const state = { particles, startTime, lastTime: startTime };
  
  // Function to animate the smoke particles
  function animateSmoke(timestamp) {
    // Calculate time delta
    const dt = (timestamp - state.lastTime) / 1000; // in seconds
    state.lastTime = timestamp;
    
    // Track if any particles are still alive
    let anyAlive = false;
    
    // Update each particle
    for (const particle of state.particles) {
      // Increase particle life
      particle.life += dt;
      
      // Check if particle is still alive
      if (particle.life < particle.maxLife) {
        anyAlive = true;
        
        // Calculate remaining life as a percentage
        const lifePercent = particle.life / particle.maxLife;
        
        // Move particle based on its velocity
        particle.mesh.position.x += particle.velocity.x * dt;
        particle.mesh.position.y += particle.velocity.y * dt;
        particle.mesh.position.z += particle.velocity.z * dt;
        
        // Slow down over time - apply drag
        particle.velocity.multiplyScalar(0.98);
        
        // Fade out as it ages
        particle.mesh.material.opacity = 0.5 * (1 - lifePercent);
        
        // Grow slightly larger
        const scale = 1 + lifePercent * 2;
        particle.mesh.scale.set(scale, scale, scale);
        
        // Rotate slowly for some movement
        particle.mesh.rotation.x += dt * 0.2;
        particle.mesh.rotation.y += dt * 0.1;
      } else {
        // Particle has expired, make it invisible
        particle.mesh.visible = false;
      }
    }
    
    // If all particles are dead and not preloading, remove the effect
    if (!anyAlive && !isPreloading) {
      // Clean up
      particles.forEach(p => {
        smokeGroup.remove(p.mesh);
        p.mesh.geometry.dispose();
        p.mesh.material.dispose();
      });
      scene.remove(smokeGroup);
      return false;
    }
    
    // Continue animation if needed
    if (!isPreloading) {
      requestAnimationFrame(animateSmoke);
    }
    return true;
  }
  
  // Start animation loop if not preloading (preloading will call this manually)
  if (!isPreloading) {
    requestAnimationFrame(animateSmoke);
  }
  
  // Return objects needed for preloading
  return { smokeGroup, particles, animateSmoke };
}

// Create global blood effect resources for reuse across all impacts
const BLOOD_POOL = {
  geometries: [],
  materials: [],
  particles: []
};

/**
 * Creates an impact effect when a bullet hits a target.
 * Generates realistic blood particles with varied splatter patterns and curved trajectories.
 * Optimized with object pooling and selective calculations.
 *
 * @param {THREE.Vector3} position - Impact position.
 * @param {THREE.Vector3} direction - Impact (bullet) direction.
 * @param {THREE.Scene} scene - The scene to add the effect.
 * @param {string} hitType - Type of impact: 'player', 'npc', or 'ground'.
 */
export function createImpactEffect(position, direction, scene, hitType) {
  // Skip ground impact effects completely
  if (hitType === 'ground') {
    return;
  }

  const effectGroup = new THREE.Group();
  effectGroup.position.copy(position);
  scene.add(effectGroup);
  
  // Play impact sound based on hit type using positional audio
  if (window.localPlayer && window.localPlayer.soundManager) {
    if (hitType === 'player' || hitType === 'npc') {
      // Calculate distance to local player to avoid playing impact on own body
      const localPlayerPos = window.localPlayer.group.position;
      const distToLocalPlayer = Math.sqrt(
        Math.pow(position.x - localPlayerPos.x, 2) + 
        Math.pow(position.z - localPlayerPos.z, 2)
      );
      
      // Only play flesh impact if not too close to local player
      if (distToLocalPlayer > 0.5) {
        window.localPlayer.soundManager.playSoundAt("fleshimpact", position);
      }
    }
  }

  // Blood effect settings
  const particleCount = 22; // Balance between visual quality and performance
  const particles = [];
  
  // More varied blood colors for visual interest
  const bloodColors = [
    0xCC0000, // Standard red
    0xAA0000, // Darker red
    0x880000, // Very dark red
    0xFF0000, // Bright red
    0xDD0000  // Medium red
  ];
  
  // Precomputed direction vector 
  const negatedDir = direction.clone().negate();
  
  // Create initial blood burst (center of impact)
  const burstSize = 0.04;
  const burstMaterial = new THREE.MeshBasicMaterial({
    color: 0xAA0000,
    transparent: true,
    opacity: 0.9,
    depthWrite: false
  });
  
  let burstGeom;
  if (BLOOD_POOL.geometries.length > 0) {
    burstGeom = BLOOD_POOL.geometries.pop();
  } else {
    burstGeom = new THREE.SphereGeometry(burstSize, 4, 3);
  }
  
  const burst = new THREE.Mesh(burstGeom, burstMaterial);
  effectGroup.add(burst);
  
  // Create impact direction-aligned disc for initial spray pattern
  const spraySize = 0.06;
  const sprayMaterial = new THREE.MeshBasicMaterial({
    color: 0x990000,
    transparent: true,
    opacity: 0.8,
    depthWrite: false
  });
  
  const sprayGeom = new THREE.CircleGeometry(spraySize, 8);
  const spray = new THREE.Mesh(sprayGeom, sprayMaterial);
  
  // Position spray slightly in front of impact point
  spray.position.copy(negatedDir.clone().multiplyScalar(0.01));
  
  // Orient spray to face away from impact direction
  spray.lookAt(spray.position.clone().add(negatedDir));
  
  effectGroup.add(spray);
  
  // Add burst and spray to particles for animation
  particles.push({
    mesh: burst,
    type: 'burst',
    velocity: new THREE.Vector3(0, 0, 0),
    life: 8,
    gravity: new THREE.Vector3(0, 0, 0)
  });
  
  particles.push({
    mesh: spray,
    type: 'spray',
    velocity: new THREE.Vector3(0, 0, 0),
    life: 12,
    gravity: new THREE.Vector3(0, 0, 0)
  });
  
  // Create blood droplets with varied patterns
  for (let i = 0; i < particleCount; i++) {
    // Get or create particle
    let particle, isNewParticle = false;
    let particleType = '';
    
    // Determine particle type (affects behavior)
    const randValue = Math.random();
    if (randValue < 0.6) {
      particleType = 'droplet'; // Small fast droplets
    } else if (randValue < 0.9) {
      particleType = 'medium'; // Medium sized drops
    } else {
      particleType = 'chunk'; // Large slow chunks
    }
    
    // Try to get a particle from the pool
    if (BLOOD_POOL.particles.length > 0) {
      particle = BLOOD_POOL.particles.pop();
      // Reset particle properties
      particle.visible = true;
      particle.scale.set(1, 1, 1);
      
      // Update material color
      const colorIndex = Math.floor(Math.random() * bloodColors.length);
      particle.material.color.setHex(bloodColors[colorIndex]);
      particle.material.opacity = 0.9;
    } else {
      // Create new particle if none in pool
      isNewParticle = true;
      
      // Size based on particle type
      let size;
      if (particleType === 'droplet') {
        size = 0.01 + Math.random() * 0.015;
      } else if (particleType === 'medium') {
        size = 0.02 + Math.random() * 0.02;
      } else {
        size = 0.025 + Math.random() * 0.025;
      }
      
      // Create geometry - varied for different particle types
      let geometry;
      if (BLOOD_POOL.geometries.length > 0) {
        geometry = BLOOD_POOL.geometries.pop();
      } else {
        if (particleType === 'chunk') {
          // Use icosahedron for chunks (more irregular shape)
          geometry = new THREE.IcosahedronGeometry(size, 0);
        } else {
          // Use sphere for droplets (smaller faces for better performance)
          geometry = new THREE.SphereGeometry(size, 3, 2);
        }
      }
      
      // Create material with varied color
      const colorIndex = Math.floor(Math.random() * bloodColors.length);
      const material = new THREE.MeshBasicMaterial({
        color: bloodColors[colorIndex],
        transparent: true,
        opacity: 0.9,
        depthWrite: false
      });
      
      // Create the particle
      particle = new THREE.Mesh(geometry, material);
    }
    
    // Add particle to group
    effectGroup.add(particle);
    
    // Initial position offset for more natural spray formation
    // Offset more along the impact direction
    const dirComponent = 0.015 * Math.random(); 
    const radialComponent = 0.01;
    
    // Create a position that favors the impact direction
    particle.position.copy(negatedDir.clone().multiplyScalar(dirComponent));
    
    // Add randomness to position
    particle.position.x += (Math.random() - 0.5) * radialComponent;
    particle.position.y += (Math.random() - 0.5) * radialComponent;
    particle.position.z += (Math.random() - 0.5) * radialComponent;
    
    // Random rotation
    if (isNewParticle) {
      particle.rotation.set(
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2
      );
    }
    
    // Create velocity vector based on particle type and impact direction
    const velocity = new THREE.Vector3();
    velocity.copy(negatedDir);
    
    // Speed varies by particle type
    let speed;
    let speedRandomness;
    
    if (particleType === 'droplet') {
      // Droplets move fastest with most randomness
      speed = 0.1;
      speedRandomness = 0.15;
    } else if (particleType === 'medium') {
      // Medium particles have moderate speed
      speed = 0.08;
      speedRandomness = 0.12;
    } else {
      // Chunks are slowest
      speed = 0.06;
      speedRandomness = 0.1;
    }
    
    // Apply speed
    const finalSpeed = speed + Math.random() * speedRandomness;
    velocity.multiplyScalar(finalSpeed);
    
    // Create spread pattern based on particle type
    const spread = particleType === 'droplet' ? 0.1 : 0.07;
    
    // Create a cone-shaped pattern mostly in the impact direction
    // but allow some particles to go more perpendicular for better spray effect
    const angleMultiplier = Math.random() < 0.3 ? 1.5 : 0.7;
    velocity.x += (Math.random() - 0.5) * spread * angleMultiplier;
    velocity.y += (Math.random() - 0.5) * spread * angleMultiplier;
    velocity.z += (Math.random() - 0.5) * spread * angleMultiplier;
    
    // Add some upward bias for more pleasing arcs
    if (Math.random() < 0.4) {
      velocity.y += 0.04 * Math.random();
    }
    
    // Different gravity strength based on particle type
    // Smaller particles affected more by air resistance
    let gravityStrength;
    if (particleType === 'droplet') {
      gravityStrength = 0.0035;
    } else if (particleType === 'medium') {
      gravityStrength = 0.0025;
    } else {
      gravityStrength = 0.002;
    }
    
    // Gravity vector always points down
    const gravity = new THREE.Vector3(0, -gravityStrength, 0);
    
    // Lifetimes vary by type
    let lifetime;
    if (particleType === 'droplet') {
      lifetime = 15 + Math.floor(Math.random() * 15);
    } else if (particleType === 'medium') {
      lifetime = 20 + Math.floor(Math.random() * 15);
    } else {
      lifetime = 25 + Math.floor(Math.random() * 15);
    }
    
    // Store particle info for animation
    particles.push({
      mesh: particle,
      velocity: velocity,
      gravity: gravity,
      life: lifetime,
      type: particleType,
      initialLife: lifetime,
      stretchAxis: new THREE.Vector3(),
      // Save initial position for trail calculation
      lastPos: particle.position.clone()
    });
  }

  // Duration in ms - allow more time for gravity arcs
  const duration = 600;
  const startTime = performance.now();
  let lastTime = startTime;

  // Function to animate the blood particles
  function animateEffect(currentTime) {
    // Time delta calculation
    const deltaTime = Math.min(currentTime - lastTime, 20) / 1000;
    lastTime = currentTime;
    
    const elapsed = currentTime - startTime;
    
    // Animation update
    let anyAlive = false;
    
    // Reduced physics frequency - helps performance 
    const dt = deltaTime * 60;
    
    // Update each particle in a single loop pass
    for (const particle of particles) {
      if (particle.life > 0) {
        anyAlive = true;
        
        // Different animation based on particle type
        if (particle.type === 'burst') {
          // Initial burst expands quickly then fades
          const lifeRatio = particle.life / 8;
          const scale = 1 + (1 - lifeRatio) * 3; 
          particle.mesh.scale.set(scale, scale, scale);
          particle.mesh.material.opacity = lifeRatio * 0.8;
        } 
        else if (particle.type === 'spray') {
          // Spray expands and fades
          const lifeRatio = particle.life / 12;
          const scale = 1 + (1 - lifeRatio) * 2;
          particle.mesh.scale.set(scale, scale, 1);
          particle.mesh.material.opacity = lifeRatio * 0.7;
        }
        else {
          // Save previous position for proper stretching
          particle.lastPos.copy(particle.mesh.position);
          
          // Apply gravity to velocity
          particle.velocity.add(particle.gravity);
          
          // Move particle based on velocity
          particle.mesh.position.x += particle.velocity.x;
          particle.mesh.position.y += particle.velocity.y;
          particle.mesh.position.z += particle.velocity.z;
          
          // Apply stretching in direction of movement
          // Only if moving fast enough
          const speedSq = particle.velocity.lengthSq();
          
          if (speedSq > 0.0005) {
            // Calculate movement vector
            particle.stretchAxis.subVectors(particle.mesh.position, particle.lastPos).normalize();
            
            // Different stretch factors based on type
            let stretchAmount;
            if (particle.type === 'droplet') {
              stretchAmount = 1 + speedSq * 35;
              // Extra stretch for small fast particles
              if (speedSq > 0.001) {
                stretchAmount *= 1.3;
              }
            } else if (particle.type === 'medium') {
              stretchAmount = 1 + speedSq * 25;
            } else {
              stretchAmount = 1 + speedSq * 15;
            }
            
            // Find dominant axis for optimized stretching
            const absX = Math.abs(particle.stretchAxis.x);
            const absY = Math.abs(particle.stretchAxis.y);
            const absZ = Math.abs(particle.stretchAxis.z);
            
            // Apply stretch primarily along dominant axis
            if (absX > absY && absX > absZ) {
              particle.mesh.scale.set(stretchAmount, 1, 1);
            } else if (absY > absX && absY > absZ) {
              particle.mesh.scale.set(1, stretchAmount, 1);
            } else {
              particle.mesh.scale.set(1, 1, stretchAmount);
            }
          }
          
          // Apply drag based on particle type
          let drag;
          if (particle.type === 'droplet') {
            drag = 0.97; // Less drag for small particles
          } else if (particle.type === 'medium') {
            drag = 0.96;
          } else {
            drag = 0.95; // More drag for larger chunks
          }
          
          particle.velocity.multiplyScalar(drag);
          
          // Fade out as particles get older
          const lifeRatio = particle.life / particle.initialLife;
          
          // Different fade behavior based on type
          if (particle.type === 'droplet' && lifeRatio < 0.5) {
            // Droplets fade faster
            particle.mesh.material.opacity = lifeRatio * 2 * 0.9;
          } else if (lifeRatio < 0.3) {
            // All particles fade in final phase
            particle.mesh.material.opacity = lifeRatio / 0.3 * 0.9;
          }
        }
        
        // Decrement life
        particle.life--;
      } else if (particle.mesh.visible) {
        // Hide expired particles
        particle.mesh.visible = false;
        
        // Return to pool for reuse
        if (particle.type !== 'burst' && particle.type !== 'spray' && 
            BLOOD_POOL.particles.length < 50) {
          BLOOD_POOL.particles.push(particle.mesh);
          effectGroup.remove(particle.mesh);
        }
      }
    }
    
    // Continue animation if any particles are alive and within duration
    if (anyAlive && elapsed < duration) {
      requestAnimationFrame(animateEffect);
    } else {
      // Clean up
      for (const particle of particles) {
        if (particle.type === 'burst' || particle.type === 'spray') {
          // Clean up spray and burst
          if (particle.mesh.geometry) {
            if (BLOOD_POOL.geometries.length < 10) {
              BLOOD_POOL.geometries.push(particle.mesh.geometry);
            } else {
              particle.mesh.geometry.dispose();
            }
          }
          if (particle.mesh.material) {
            particle.mesh.material.dispose();
          }
        } 
        else if (!BLOOD_POOL.particles.includes(particle.mesh)) {
          // Pool materials and geometries from other particles
          if (BLOOD_POOL.materials.length < 20 && particle.mesh.material) {
            BLOOD_POOL.materials.push(particle.mesh.material);
          } else if (particle.mesh.material) {
            particle.mesh.material.dispose();
          }
          
          if (BLOOD_POOL.geometries.length < 10 && particle.mesh.geometry) {
            BLOOD_POOL.geometries.push(particle.mesh.geometry);
          } else if (particle.mesh.geometry) {
            particle.mesh.geometry.dispose();
          }
        }
      }
      
      // Remove effect group
      scene.remove(effectGroup);
    }
  }
  
  // Start animation
  requestAnimationFrame(animateEffect);
}

/**
 * Apply recoil effect to the player's camera.
 * @param {Player} player - The player instance.
 * @param {number} multiplier - Recoil strength multiplier (default: 1.0).
 */
export function applyRecoil(player, multiplier = 1.0) {
  const originalAimOffset = player.aimOffset.clone();
  const originalFOV = player.camera.fov;
  const originalCameraPos = player.camera.position.clone();
  const originalRotation = player.camera.rotation.clone();

  // Initial recoil changes.
  player.camera.rotation.x -= 0.08 * multiplier;
  player.camera.rotation.z += 0.01 * multiplier;
  player.aimOffset.z += 0.4 * multiplier;
  player.aimOffset.y += 0.15 * multiplier;
  player.aimOffset.x += 0.05 * multiplier;
  player.camera.fov -= 5 * multiplier;
  player.camera.updateProjectionMatrix();

  // Apply physical recoil force for shotgun
  if (player.activeWeapon === 'shotgun') {
    // Get the direction the player is aiming in WORLD space
    const lookDir = new THREE.Vector3(0, 0, -1); // Forward in camera local space
    lookDir.applyQuaternion(player.camera.getWorldQuaternion(new THREE.Quaternion()));
    lookDir.normalize();
    
    // Calculate recoil direction - inverse of look direction
    const recoilDir = lookDir.clone().negate();
    
    // Enable recoil boost mode to prevent normal movement dampening
    player.recoilBoosted = true;
    player.recoilBoostTime = player.recoilBoostDuration;
    
    // Get player's world rotation 
    const playerRotationY = player.group.rotation.y;
    
    // Determine if looking down (for rocket jump)
    if (lookDir.y < -0.3) {
      // Player is aiming down, apply RIDICULOUS upward force
      player.velocity.y = 50.0; // Extreme upward force
      
      // Apply horizontal force aligned with player forward direction
      // This ensures the recoil pushes you in the correct direction
      player.velocity.x = Math.sin(playerRotationY) * -30.0 * recoilDir.z;
      player.velocity.z = Math.cos(playerRotationY) * -30.0 * recoilDir.z;
      
      console.log("🚀 SHOTGUN UPWARD BLAST!", player.velocity);
    } else {
      // Apply force directly opposed to look direction in world space
      // These are applied directly as world-space velocities
      player.velocity.x = recoilDir.x * 50.0;
      player.velocity.z = recoilDir.z * 50.0;
      player.velocity.y = 15.0 + Math.abs(recoilDir.y * 30.0); // Add upward boost
      
      console.log("💥 EXTREME SHOTGUN KNOCKBACK!", player.velocity, "Look dir:", lookDir);
    }
    
    // Disable gravity for a short moment to allow full force expression
    const originalGravity = player.gravity;
    player.gravity = 0;
    setTimeout(() => {
      player.gravity = originalGravity;
    }, 150); // 150ms of zero gravity for maximum effect
    
    // Force jump state regardless of ground contact
    player.canJump = false;
    player.isJumping = true;
    
    // Play an extra sound for the force feedback
    if (player.soundManager) {
      player.soundManager.playSound("recoiljump", 0); // Remove delay for immediacy
      
      // Also play an extra impact sound for drama
      player.soundManager.playSound("shotgunshot", 0, 1.5); // Higher volume
    }
  }

  const recoilSteps = [
    { time: 20, cameraX: -0.04, cameraZ: 0.005, offsetZ: 0.2, offsetY: 0.08, offsetX: 0.03 },
    { time: 40, cameraX: -0.06, cameraZ: 0.008, offsetZ: 0.3, offsetY: 0.12, offsetX: 0.04 },
    { time: 60, cameraX: -0.03, cameraZ: 0.006, offsetZ: 0.25, offsetY: 0.1, offsetX: 0.02 },
    { time: 80, cameraX: -0.02, cameraZ: 0.004, offsetZ: 0.18, offsetY: 0.07, offsetX: 0.01 },
    { time: 100, cameraX: -0.01, cameraZ: 0.002, offsetZ: 0.1, offsetY: 0.05, offsetX: 0.005 }
  ];

  recoilSteps.forEach(step => {
    setTimeout(() => {
      player.camera.rotation.x = originalRotation.x + step.cameraX * multiplier;
      player.camera.rotation.z = originalRotation.z + step.cameraZ * multiplier;
      player.aimOffset.z = originalAimOffset.z + step.offsetZ * multiplier;
      player.aimOffset.y = originalAimOffset.y + step.offsetY * multiplier;
      player.aimOffset.x = originalAimOffset.x + step.offsetX * multiplier;
    }, step.time);
  });

  let shakeIntensity = 0.03 * multiplier;
  const shakeDecay = 0.9;
  const shakeInterval = setInterval(() => {
    if (shakeIntensity > 0.002) {
      player.camera.position.x = originalCameraPos.x + (Math.random() - 0.5) * shakeIntensity;
      player.camera.position.y = originalCameraPos.y + (Math.random() - 0.5) * shakeIntensity;
      shakeIntensity *= shakeDecay;
    } else {
      clearInterval(shakeInterval);
      player.camera.position.copy(originalCameraPos);
    }
  }, 16);

  let progress = 0;
  const duration = 400;
  const startTime = performance.now();

  function recoverFromRecoil(timestamp) {
    progress = (timestamp - startTime) / duration;
    if (progress < 1) {
      const t = progress * 4;
      player.camera.rotation.x = springInterpolation(
        player.camera.rotation.x,
        originalRotation.x,
        t,
        0.4,
        8
      );
      player.camera.rotation.z = springInterpolation(
        player.camera.rotation.z,
        originalRotation.z,
        t,
        0.4,
        8
      );
      player.aimOffset.x = springInterpolation(
        player.aimOffset.x,
        originalAimOffset.x,
        t,
        0.4,
        8
      );
      player.aimOffset.y = springInterpolation(
        player.aimOffset.y,
        originalAimOffset.y,
        t,
        0.4,
        8
      );
      player.aimOffset.z = springInterpolation(
        player.aimOffset.z,
        originalAimOffset.z,
        t,
        0.4,
        8
      );
      player.camera.fov = THREE.MathUtils.lerp(
        player.camera.fov,
        originalFOV,
        progress * 0.3
      );
      player.camera.updateProjectionMatrix();
      requestAnimationFrame(recoverFromRecoil);
    } else {
      player.camera.rotation.copy(originalRotation);
      player.aimOffset.copy(originalAimOffset);
      player.camera.fov = originalFOV;
      player.camera.updateProjectionMatrix();
      player.camera.position.copy(originalCameraPos);
    }
  }
  requestAnimationFrame(recoverFromRecoil);
}

/**
 * Preloads the smoke effect by creating a disposable instance
 * This forces Three.js to compile shaders and cache necessary resources
 * @param {THREE.Scene} scene - The scene where the preloaded effect will be created
 */
export function preloadSmokeEffect(scene) {
  // Create a dummy position far below the scene where it won't be visible
  const dummyPosition = new THREE.Vector3(0, -1000, 0);
  const dummyDirection = new THREE.Vector3(0, 1, 0);
  
  // Create a fully realized smoke effect to warm up all rendering pathways
  // This will ensure the first visible effect doesn't cause frame drops
  const smokeEffect = createSmokeEffect(dummyPosition, dummyDirection, scene, true);
  
  // Force a few animation frames to ensure shaders are compiled
  const fakeTimestamps = [0, 16, 32, 48, 64, 80, 96];
  let frameIndex = 0;
  
  function simulateFrames() {
    if (frameIndex < fakeTimestamps.length) {
      // Manually advance the animation
      smokeEffect.animateSmoke(performance.now() + fakeTimestamps[frameIndex]);
      frameIndex++;
      setTimeout(simulateFrames, 0); // Use setTimeout to avoid blocking the main thread
    } else {
      // Clean up after simulation is complete
      setTimeout(() => {
        scene.remove(smokeEffect.smokeGroup);
        smokeEffect.particles.forEach(p => {
          p.mesh.geometry.dispose();
          p.mesh.material.dispose();
        });
      }, 100);
    }
  }
  
  // Start simulating frames immediately
  simulateFrames();
}

/**
 * Preloads the muzzle flash effect by creating a full instance and running its animation
 * @param {THREE.Scene} scene - The scene to add the preloaded effect
 */
export function preloadMuzzleFlash(scene) {
  // Create a dummy position far below the scene
  const dummyPosition = new THREE.Vector3(0, -1000, 0);
  const dummyDirection = new THREE.Vector3(0, 1, 0);
  
  // Create a full muzzle flash effect - and capture the returned animation function
  const flashEffect = createMuzzleFlash(dummyPosition, dummyDirection, scene, null, true);
  
  // Force a few animation frames to ensure shaders are compiled
  const fakeTimestamps = [0, 16, 32, 48, 64];
  let frameIndex = 0;
  
  function simulateFrames() {
    if (frameIndex < fakeTimestamps.length) {
      // Manually advance the animation using the function from the returned effect
      flashEffect.animateFlash(performance.now() + fakeTimestamps[frameIndex]);
      frameIndex++;
      setTimeout(simulateFrames, 0); // Use setTimeout to avoid blocking the main thread
    } else {
      // Clean up after simulation is complete
      setTimeout(() => {
        scene.remove(flashEffect.flashGroup);
        if (flashEffect.flash) {
          flashEffect.flash.geometry.dispose();
          flashEffect.flash.material.dispose();
        }
        if (flashEffect.glow) {
          flashEffect.glow.geometry.dispose();
          flashEffect.glow.material.dispose();
        }
      }, 100);
    }
  }
  
  // Start simulating frames immediately
  simulateFrames();
}

// Export the SmokeRingEffect class
export { SmokeRingEffect };

/**
 * DrunkennessEffect - Creates a drunkenness camera effect
 * with various visual and motion effects that intensify and fade over time
 */
export class DrunkennessEffect {
  constructor(player, camera) {
    this.player = player;
    this.camera = camera;
    this.active = false;
    this.startTime = 0;
    // Adjust timing as requested - total 30s
    this.duration = 30000; // 30 seconds total
    this.intensifyDuration = 5000; // 5 seconds to intensify
    this.fullIntensityDuration = 20000; // 20 seconds at full intensity
    this.fadeoutDuration = 5000; // 5 seconds to fade out
    this.lastUpdate = 0;
    
    // Original camera values to restore
    this.originalFOV = 0;
    this.originalPosition = new THREE.Vector3();
    this.originalRotation = new THREE.Euler();
    
    // Effect parameters - smoother intensity
    this.maxIntensity = 1.2; // More moderate intensity
    this.currentIntensity = 0;
    
    // Camera wobble parameters - slower frequency for more sway
    this.wobblePhase = 0;
    this.wobbleFrequency = 1.2; // Reduced from 2.5 to 1.2 for slower sway
    this.maxPositionWobble = 0.25; // Increased from 0.13 for more intense swaying
    this.maxRotationWobble = 0.12; // Increased from 0.06 for more intense swaying
    
    // Camera smoothing parameters
    this.targetCameraPosition = new THREE.Vector3();
    this.targetCameraRotation = new THREE.Euler();
    this.cameraLerpFactor = 0.1; // Adjust for smoother/faster transitions
    this.lastPlayerInput = new THREE.Euler();
    
    // Movement jitter parameters
    this.jitterAmount = 0;
    this.jitterDecay = 0.9;
    this.directionShiftAmount = 0;
    this.directionShiftPhase = 0;
    
    // Visual effects
    this.effectsContainer = null;
    this.doubleVisionEnabled = false;
    this.doubleVisionCanvas = null;
    this.doubleVisionCtx = null;
    this.doubleVisionOffset = 0;
    
    // Create visual effects container
    this.createVisualEffects();
    
    // Set to window for access from other modules
    window.drunkennessEffect = this;
  }
  
  /**
   * Creates the DOM elements for visual effects
   */
  createVisualEffects() {
    // Create container for visual effects - minimal approach
    this.effectsContainer = document.createElement('div');
    this.effectsContainer.id = 'drunkenness-effects';
    this.effectsContainer.style.position = 'absolute';
    this.effectsContainer.style.top = '0';
    this.effectsContainer.style.left = '0';
    this.effectsContainer.style.width = '100%';
    this.effectsContainer.style.height = '100%';
    this.effectsContainer.style.pointerEvents = 'none';
    this.effectsContainer.style.zIndex = '10';
    this.effectsContainer.style.display = 'none';
    this.effectsContainer.style.background = 'transparent';
    
    // Create filter layer with NO filters
    this.filterLayer = document.createElement('div');
    this.filterLayer.id = 'drunkenness-filter';
    this.filterLayer.style.position = 'absolute';
    this.filterLayer.style.top = '0';
    this.filterLayer.style.left = '0';
    this.filterLayer.style.width = '100%';
    this.filterLayer.style.height = '100%';
    this.filterLayer.style.backgroundColor = 'rgba(0,0,0,0)';
    this.filterLayer.style.backdropFilter = 'none';
    this.filterLayer.style.pointerEvents = 'none';
    this.filterLayer.style.mixBlendMode = 'normal';
    
    // Add filter layer to container
    this.effectsContainer.appendChild(this.filterLayer);
    
    // Add container to document
    document.body.appendChild(this.effectsContainer);
    
    // Double vision canvas will be created on demand
    this.doubleVisionEnabled = false;
    this.doubleVisionCanvas = null;
    this.doubleVisionCtx = null;
  }
  
  /**
   * Activates the drunkenness effect
   */
  activate() {
    if (this.active) return; // Already active
    
    console.log('Activating drunkenness effect');
    
    // Store original camera values
    this.originalFOV = this.camera.fov;
    this.originalPosition.copy(this.camera.position);
    this.originalRotation.copy(this.camera.rotation);
    
    // Reset effect parameters
    this.currentIntensity = 0;
    this.wobblePhase = 0;
    this.jitterAmount = 0;
    this.directionShiftPhase = 0;
    
    // Start the effect
    this.active = true;
    this.startTime = performance.now();
    this.lastUpdate = this.startTime;
    
    // Show visual effects container
    this.effectsContainer.style.display = 'block';
    
    // Start update loop
    this.update();
  }
  
  /**
   * Deactivates the drunkenness effect and cleans up all elements
   */
  deactivate() {
    if (!this.active) return;
    
    console.log('Deactivating drunkenness effect');
    
    // Restore original camera values
    this.camera.fov = this.originalFOV;
    this.camera.updateProjectionMatrix();
    this.camera.position.copy(this.originalPosition);
    this.camera.rotation.copy(this.originalRotation);
    
    // Hide effects container
    this.effectsContainer.style.display = 'none';
    
    // THOROUGH CLEANUP OF ALL ELEMENTS:
    
    // 1. Remove all style elements
    const styleElements = [
      document.getElementById('drunk-chromatic-aberration'),
      document.getElementById('drunk-brightness-fix')
    ];
    
    styleElements.forEach(element => {
      if (element && element.parentNode) {
        element.parentNode.removeChild(element);
      }
    });
    
    // 2. Remove all overlay elements
    const overlayElements = [
      document.querySelector('.drunk-red-overlay'),
      document.querySelector('.drunk-cyan-overlay')
    ];
    
    overlayElements.forEach(element => {
      if (element && element.parentNode) {
        element.parentNode.removeChild(element);
      }
    });
    
    // 3. Remove double vision canvas
    if (this.doubleVisionCanvas && this.doubleVisionCanvas.parentNode) {
      this.doubleVisionCanvas.parentNode.removeChild(this.doubleVisionCanvas);
      this.doubleVisionCanvas = null;
      this.doubleVisionCtx = null;
    }
    this.doubleVisionEnabled = false;
    
    // End the effect
    this.active = false;
  }
  
  /**
   * Updates the drunkenness effect
   */
  update() {
    if (!this.active) return;
    
    const now = performance.now();
    const deltaTime = (now - this.lastUpdate) / 1000; // in seconds
    this.lastUpdate = now;
    
    // Calculate elapsed time and overall progress
    const elapsed = now - this.startTime;
    
    // Check if effect should end
    if (elapsed >= this.duration) {
      this.deactivate();
      return;
    }
    
    // Calculate intensity based on phase of effect
    if (elapsed < this.intensifyDuration) {
      // Intensifying phase - increase intensity
      this.currentIntensity = (elapsed / this.intensifyDuration) * this.maxIntensity;
    } else if (elapsed < this.intensifyDuration + this.fullIntensityDuration) {
      // Full intensity phase - maintain max intensity
      this.currentIntensity = this.maxIntensity;
    } else {
      // Fadeout phase - decrease intensity
      const fadeOutElapsed = elapsed - (this.intensifyDuration + this.fullIntensityDuration);
      this.currentIntensity = this.maxIntensity * (1 - (fadeOutElapsed / this.fadeoutDuration));
    }
    
    // Capture player's input before applying drunk effects
    this.capturePlayerInput();
    
    // Calculate wobble effect target values
    this.calculateWobbleTargets(deltaTime);
    
    // Smoothly blend camera movement
    this.smoothCameraBlend(deltaTime);
    
    // Apply movement jitter effect
    this.applyMovementJitter(deltaTime);
    
    // Update visual effects
    this.updateVisualEffects();
    
    // Continue update loop
    requestAnimationFrame(() => this.update());
  }
  
  /**
   * Captures the player's current input to blend with drunk wobble
   */
  capturePlayerInput() {
    // Store player's intended camera rotation
    this.lastPlayerInput.copy(this.camera.rotation);
  }
  
  /**
   * Calculates the wobble effect target values
   * @param {number} deltaTime - Time since last update in seconds
   */
  calculateWobbleTargets(deltaTime) {
    // Update wobble phase - slower progression
    this.wobblePhase += deltaTime * this.wobbleFrequency;
    
    // Calculate wobble offsets using smoother sine waves
    const posXOffset = Math.sin(this.wobblePhase * 0.8) 
      * this.maxPositionWobble * this.currentIntensity;
    
    const posYOffset = Math.sin(this.wobblePhase * 0.9) 
      * this.maxPositionWobble * this.currentIntensity;
    
    const posZOffset = Math.sin(this.wobblePhase * 0.7) 
      * this.maxPositionWobble * this.currentIntensity;
    
    // Set target position with wobble applied
    this.targetCameraPosition.set(
      this.originalPosition.x + posXOffset,
      this.originalPosition.y + posYOffset,
      this.originalPosition.z + posZOffset
    );
    
    // Calculate rotation wobble
    const rotYOffset = Math.sin(this.wobblePhase * 0.7)
      * this.maxRotationWobble * this.currentIntensity;
    
    const rotZOffset = Math.sin(this.wobblePhase * 0.8)
      * this.maxRotationWobble * 1.5 * this.currentIntensity;
    
    // Set target rotation with wobble applied, respecting player X rotation
    this.targetCameraRotation.set(
      this.lastPlayerInput.x, // Keep player's up/down look intact
      this.originalRotation.y + rotYOffset,
      this.originalRotation.z + rotZOffset
    );
    
    // Calculate FOV effect
    const fovOffset = Math.sin(this.wobblePhase * 0.4) * 5 * this.currentIntensity;
    this.camera.fov = this.originalFOV + fovOffset;
    this.camera.updateProjectionMatrix();
  }
  
  /**
   * Smoothly blends camera between player input and drunk wobble
   * @param {number} deltaTime - Time since last update in seconds
   */
  smoothCameraBlend(deltaTime) {
    // Adjust lerp factor based on intensity and deltaTime
    const lerpStrength = this.cameraLerpFactor * (1 + this.currentIntensity * 2);
    const lerpFactor = Math.min(1.0, lerpStrength * deltaTime * 60); // Normalize for 60fps
    
    // Smoothly interpolate position
    this.camera.position.lerp(this.targetCameraPosition, lerpFactor);
    
    // Smoothly interpolate Y and Z rotation while preserving player X rotation
    // We only lerp Y and Z because X is controlled directly by player look
    this.camera.rotation.y = THREE.MathUtils.lerp(
      this.camera.rotation.y,
      this.targetCameraRotation.y,
      lerpFactor
    );
    
    this.camera.rotation.z = THREE.MathUtils.lerp(
      this.camera.rotation.z,
      this.targetCameraRotation.z,
      lerpFactor
    );
  }
  
  /**
   * Applies movement jitter to player controls
   * @param {number} deltaTime - Time since last update in seconds
   */
  applyMovementJitter(deltaTime) {
    if (!this.player) return;
    
    // Update direction shift phase - slower
    this.directionShiftPhase += deltaTime * 0.6; // Reduced from 0.9
    
    // Calculate direction shift with smoother curve
    this.directionShiftAmount = Math.sin(this.directionShiftPhase) 
      * 0.6 * this.currentIntensity; // Reduced from 0.8
    
    // Apply random jitter to movement
    if (this.player.isMoving && typeof this.player.isMoving === 'function' && this.player.isMoving()) {
      // Apply random movement jitter - reduced intensity
      const jitterX = (Math.random() - 0.5) * 0.25 * this.currentIntensity; // Reduced from 0.35
      const jitterZ = (Math.random() - 0.5) * 0.25 * this.currentIntensity; // Reduced from 0.35
      
      // Apply jitter to velocity
      if (this.player.velocity) {
        if (this.player.moveForward || this.player.moveBackward) {
          this.player.velocity.x += jitterX;
        }
        if (this.player.moveLeft || this.player.moveRight) {
          this.player.velocity.z += jitterZ;
        }
      }
      
      // Apply direction shift (makes the player veer slightly left/right when moving)
      if (this.player.moveForward || this.player.moveBackward || 
          this.player.moveLeft || this.player.moveRight) {
        this.player.group.rotation.y += this.directionShiftAmount * deltaTime;
      }
      
      // Occasionally apply a rotation push - reduced frequency
      if (Math.random() < 0.02 * this.currentIntensity) { // Reduced from 0.03
        this.player.group.rotation.y += (Math.random() - 0.5) * 0.1 * this.currentIntensity; // Reduced from 0.15
      }
    }
  }
  
  /**
   * Updates visual effects based on current intensity
   */
  updateVisualEffects() {
    // EMERGENCY FIX: Remove all filters/effects that could cause darkening
    
    // Remove any existing overlay elements that might be causing darkening
    const overlaysToRemove = [
      document.querySelector('.drunk-red-overlay'), 
      document.querySelector('.drunk-cyan-overlay'),
      document.querySelector('.drunk-chromatic-red'),
      document.querySelector('.drunk-chromatic-blue')
    ];
    
    overlaysToRemove.forEach(overlay => {
      if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
      }
    });
    
    // Remove any existing style elements that might be adding filters
    const stylesToRemove = [
      document.getElementById('drunk-chromatic-aberration'),
      document.getElementById('drunk-brightness-fix')
    ];
    
    stylesToRemove.forEach(style => {
      if (style && style.parentNode) {
        style.parentNode.removeChild(style);
      }
    });
    
    // Set filter layer to completely transparent
    this.filterLayer.style.backgroundColor = 'rgba(0,0,0,0)';
    this.filterLayer.style.backdropFilter = 'none';
    
    // Add chromatic aberration effect as actual DOM elements
    if (this.currentIntensity > 0.1) {
      const gameCanvas = document.querySelector('canvas');
      if (gameCanvas) {
        const aberrationAmount = this.currentIntensity * 10; // Increased intensity
        const redOffset = Math.sin(this.wobblePhase * 0.7) * aberrationAmount;
        const blueOffset = Math.sin(this.wobblePhase * 0.9) * -aberrationAmount; // Opposite direction
        
        // Create red channel overlay
        const redOverlay = document.createElement('div');
        redOverlay.className = 'drunk-chromatic-red';
        redOverlay.style.position = 'absolute';
        redOverlay.style.top = '0';
        redOverlay.style.left = '0';
        redOverlay.style.width = '100%';
        redOverlay.style.height = '100%';
        redOverlay.style.pointerEvents = 'none';
        redOverlay.style.zIndex = '90';
        redOverlay.style.opacity = '0.5';
        redOverlay.style.mixBlendMode = 'screen';
        redOverlay.style.backgroundColor = 'transparent';
        
        // Clone the game canvas into this div
        const redClone = gameCanvas.cloneNode(true);
        redClone.style.position = 'absolute';
        redClone.style.filter = 'url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"><filter id="red"><feColorMatrix type="matrix" values="1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0"/></filter></svg>#red\')';
        redClone.style.transform = `translate(${redOffset}px, 0)`;
        redClone.style.opacity = '0.8';
        redOverlay.appendChild(redClone);
        
        // Create blue channel overlay
        const blueOverlay = document.createElement('div');
        blueOverlay.className = 'drunk-chromatic-blue';
        blueOverlay.style.position = 'absolute';
        blueOverlay.style.top = '0';
        blueOverlay.style.left = '0';
        blueOverlay.style.width = '100%';
        blueOverlay.style.height = '100%';
        blueOverlay.style.pointerEvents = 'none';
        blueOverlay.style.zIndex = '91';
        blueOverlay.style.opacity = '0.5';
        blueOverlay.style.mixBlendMode = 'screen';
        blueOverlay.style.backgroundColor = 'transparent';
        
        // Clone the game canvas into this div
        const blueClone = gameCanvas.cloneNode(true);
        blueClone.style.position = 'absolute';
        blueClone.style.filter = 'url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"><filter id="blue"><feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0"/></filter></svg>#blue\')';
        blueClone.style.transform = `translate(${blueOffset}px, 0)`;
        blueClone.style.opacity = '0.8';
        blueOverlay.appendChild(blueClone);
        
        // Add the overlays to document
        document.body.appendChild(redOverlay);
        document.body.appendChild(blueOverlay);
      }
    }
    
    // Simplified double vision effect without CSS filters
    // Only show double vision above certain intensity
    if (this.currentIntensity > 0.1) {
      // Calculate double vision offset based on intensity
      const baseOffset = this.currentIntensity * 25; // Increased from 15 for more intense effect
      const wobbleOffset = Math.sin(this.wobblePhase) * 10 * this.currentIntensity; // Increased from 5 for more intense effect
      this.doubleVisionOffset = baseOffset + wobbleOffset;
      
      // Get game canvas for double vision effect
      const gameCanvas = document.querySelector('canvas');
      if (gameCanvas && !this.doubleVisionEnabled) {
        // Create a very simple double vision using plain canvas
        // (without any filter that could cause darkening)
        this.doubleVisionCanvas = document.createElement('canvas');
        this.doubleVisionCanvas.width = window.innerWidth;
        this.doubleVisionCanvas.height = window.innerHeight;
        this.doubleVisionCanvas.style.position = 'absolute';
        this.doubleVisionCanvas.style.top = '0';
        this.doubleVisionCanvas.style.left = '0';
        this.doubleVisionCanvas.style.width = '100%';
        this.doubleVisionCanvas.style.height = '100%';
        this.doubleVisionCanvas.style.pointerEvents = 'none';
        this.doubleVisionCanvas.style.opacity = '0.2';
        this.doubleVisionCanvas.style.zIndex = '100';
        this.doubleVisionCanvas.style.mixBlendMode = 'lighten';
        
        // Only add the canvas once
        document.body.appendChild(this.doubleVisionCanvas);
        this.doubleVisionCtx = this.doubleVisionCanvas.getContext('2d');
        this.doubleVisionEnabled = true;
      }
      
      // Draw the double vision effect if canvas is ready
      if (this.doubleVisionEnabled && this.doubleVisionCtx && gameCanvas) {
        // Clear previous content
        this.doubleVisionCtx.clearRect(0, 0, this.doubleVisionCanvas.width, this.doubleVisionCanvas.height);
        
        // Use simple drawImage for offset vision, with no compositing
        this.doubleVisionCtx.drawImage(
          gameCanvas, 
          this.doubleVisionOffset, 
          -this.doubleVisionOffset / 2
        );
        
        // Force canvas to be fully visible
        this.doubleVisionCanvas.style.display = 'block';
      }
    } else if (this.doubleVisionEnabled) {
      // Hide double vision canvas when intensity is too low
      if (this.doubleVisionCanvas) {
        this.doubleVisionCanvas.style.display = 'none';
      }
      this.doubleVisionEnabled = false;
    }
    
    // Add a single style element that ONLY forces brightness to 100%
    const brightnessStyle = document.createElement('style');
    brightnessStyle.id = 'drunk-brightness-fix';
    brightnessStyle.textContent = `
      * { filter: brightness(100%) !important; }
      body { filter: brightness(100%) !important; }
      canvas { filter: brightness(100%) !important; }
      div { filter: brightness(100%) !important; }
      #game-container { filter: brightness(100%) !important; }
      #game-container * { filter: brightness(100%) !important; }
    `;
    document.head.appendChild(brightnessStyle);
  }
}

================================================
File: /public/js/input.js
================================================
/**
 * Initializes game input (keyboard + mouse) and pointer lock.
 * @param {THREE.WebGLRenderer} renderer - The renderer instance.
 * @param {Player} player - The local Player instance (first-person).
 * @param {SoundManager} soundManager - The SoundManager for audio feedback.
 * @returns {Object} The mobile controls interface if on mobile, otherwise null.
 */

import { isChatInputActive } from './chat.js';

export function initInput(renderer, player, soundManager) {
  // Track if device is mobile
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  // Variable to store the mobile controls interface
  let mobileControls = null;
  
  // Create touch controls for mobile
  if (isMobile) {
    mobileControls = createMobileControls(player, soundManager);
    
    // Hide all instruction elements on mobile
    hideInstructionsOnMobile();
  }
  
  // Request pointer lock on click (desktop only)
  document.body.addEventListener('click', () => {
    if (!isMobile && document.pointerLockElement !== renderer.domElement) {
      renderer.domElement.requestPointerLock();
    }
  });

  // Mouse look
  document.addEventListener('mousemove', (event) => {
    if (document.pointerLockElement === renderer.domElement) {
      const movementX = event.movementX || 0;
      const movementY = event.movementY || 0;

      // Slightly lower sensitivity when aiming
      const sensitivity = player.isAiming ? 0.001 : 0.002;

      // Yaw
      player.group.rotation.y -= movementX * sensitivity;

      // Pitch (limit to avoid flipping)
      player.camera.rotation.x -= movementY * sensitivity;
      player.camera.rotation.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, player.camera.rotation.x)
      );
    }
  });

  // Keyboard down
  document.addEventListener('keydown', (event) => {
    // Skip game input if chat is active
    if (isChatInputActive()) return;
    
    // Weapon switching with number keys
    if (event.code === 'Digit1') {
      player.switchWeapon('revolver');
      return;
    }
    if (event.code === 'Digit2') {
      player.switchWeapon('shotgun');
      return;
    }
    
    switch (event.code) {
      case 'KeyW':
        player.moveForward = true;
        break;
      case 'KeyS':
        player.moveBackward = true;
        break;
      case 'KeyA':
        player.moveLeft = true;
        break;
      case 'KeyD':
        player.moveRight = true;
        break;
      case 'KeyF':
        // Alternative aiming method - holding F to aim
        if (player.canAim && !player.isFAiming) {
          player.isFAiming = true;
          player.isAiming = true;
          
          // Optionally show arms in first-person
          if (player.arms) {
            player.arms.setVisible(true);
          }
          
          // Show and prepare crosshair for animation
          const crosshair = document.getElementById('crosshair');
          if (crosshair) {
            // Reset any existing animation classes
            crosshair.classList.remove('contract', 'expand', 'expanded');
            crosshair.style.display = 'block';
          }

          if (soundManager) {
            soundManager.playSound(player.activeWeapon === 'shotgun' ? "shotgundraw" : "revolverdraw");
          }
        }
        break;
      case 'Space':
        if (player.canJump) {
          // If sprinting, jump higher
          player.velocity.y = player.isSprinting ? 15 : 10;
          player.canJump = false;
          player.isJumping = true;
          
          // Play jump sound
          if (player.soundManager) {
            console.log("Playing jumpup sound from space key");
            player.soundManager.playSound("jumpup", 0, 1.5);
          }
        }
        break;
      case 'KeyR':
        // Start reload
        player.startReload();
        break;
      case 'ShiftLeft':
      case 'ShiftRight':
        // Enable sprinting
        player.isSprinting = true;
        break;
      default:
        break;
    }
  });

  // Keyboard up
  document.addEventListener('keyup', (event) => {
    // Skip game input if chat is active
    if (isChatInputActive()) return;
    
    switch (event.code) {
      case 'KeyW':
        player.moveForward = false;
        break;
      case 'KeyS':
        player.moveBackward = false;
        break;
      case 'KeyA':
        player.moveLeft = false;
        break;
      case 'KeyD':
        player.moveRight = false;
        break;
      case 'KeyF':
        // Stop aiming when F is released (only if F aiming was active)
        if (player.isFAiming) {
          player.isFAiming = false;
          player.isAiming = false;
          
          if (player.arms) {
            player.arms.setVisible(false);
          }
          
          // Play contraction animation before hiding crosshair
          const crosshair = document.getElementById('crosshair');
          if (crosshair) {
            // Reset any existing classes
            crosshair.classList.remove('expand', 'expanded');
            
            // Add contraction animation
            crosshair.classList.add('contract');
            
            // Hide crosshair after animation completes
            setTimeout(() => {
              crosshair.style.display = 'none';
              crosshair.classList.remove('contract');
            }, 250); // Match animation duration
          }
        }
        break;
      case 'ShiftLeft':
      case 'ShiftRight':
        // Disable sprinting
        player.isSprinting = false;
        break;
      default:
        break;
    }
  });

  // Mouse down
  document.addEventListener('mousedown', (event) => {
    // Right-click => Aim (only if canAim is true)
    if (event.button === 2) {
      if (player.canAim && !player.isFAiming) {
        // Traditional right-click aiming (only if not already F-aiming)
        player.isAiming = true;
        
        // Optionally show arms in first-person
        if (player.arms) {
          player.arms.setVisible(true);
        }
        
        // Show and prepare crosshair for animation
        const crosshair = document.getElementById('crosshair');
        if (crosshair) {
          // Reset any existing animation classes
          crosshair.classList.remove('contract', 'expand', 'expanded');
          crosshair.style.display = 'block';
          // Animation will be handled in updateAiming
        }

        if (soundManager) {
          soundManager.playSound(player.activeWeapon === 'shotgun' ? "shotgundraw" : "revolverdraw");
        }
      } else if (player.isFAiming) {
        // RMB pressed while F-aiming - prepare for shoot on release
        player.isFRmbPressed = true;
      }
    }
    // Left-click handling
    else if (event.button === 0) {
      if (player.isAiming && !player.isReloading) {
        // Only use hold-to-shoot when F key is being held (F-aiming mode)
        if (player.isFAiming) {
          // F is being held - use hold-to-shoot mode
          player.isLmbPressed = true;
        } else {
          // Standard aiming - shoot immediately on click
          player.shoot();
        }
      }
    }
  });

  // Mouse up
  document.addEventListener('mouseup', (event) => {
    // Handle right mouse button release
    if (event.button === 2) {
      if (player.isFAiming && player.isFRmbPressed) {
        // F + RMB shoot mechanic: shoot on RMB release while holding F
        player.isFRmbPressed = false;
        
        if (!player.isReloading) {
          player.shoot();
        }
      } else if (!player.isFAiming) {
        // Traditional right-click aim release (only if not F-aiming)
        player.isAiming = false;
        
        if (player.arms) {
          player.arms.setVisible(false);
        }
        
        // Play contraction animation before hiding crosshair
        const crosshair = document.getElementById('crosshair');
        if (crosshair) {
          // Reset any existing classes
          crosshair.classList.remove('expand', 'expanded');
          
          // Add contraction animation
          crosshair.classList.add('contract');
          
          // Hide crosshair after animation completes
          setTimeout(() => {
            crosshair.style.display = 'none';
            crosshair.classList.remove('contract');
          }, 250); // Match animation duration
        }
      }
    }
    // Left mouse button release
    else if (event.button === 0) {
      if (player.isLmbPressed && player.isAiming && !player.isReloading) {
        // Only shoot on release when in F-aiming mode
        if (player.isFAiming) {
          player.shoot();
        }
        player.isLmbPressed = false;
      }
    }
  });

  // Prevent context menu on right-click
  document.addEventListener('contextmenu', (event) => {
    event.preventDefault();
  });

  // Handle window resize
  window.addEventListener('resize', () => {
    player.camera.aspect = window.innerWidth / window.innerHeight;
    player.camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    // Check for device orientation
    checkOrientation();
  });
  
  // Handle orientation change for mobile
  window.addEventListener('orientationchange', checkOrientation);
  
  // Initial orientation check
  checkOrientation();

  // Ensure fullscreen with no white bars
  ensureFullscreen();
  
  // Set up a resize listener to maintain fullscreen when orientation changes
  window.addEventListener('resize', ensureFullscreen);

  // Return the mobile controls interface if on mobile
  return mobileControls;
}

/**
 * Hide all instruction elements and portals on mobile
 */
function hideInstructionsOnMobile() {
  // Hide all instruction elements
  const instructionElements = [
    document.getElementById('portal-instructions'),
    document.getElementById('proper-shootout-instructions'),
    document.getElementById('reload-message'),
    document.getElementById('health-counter'),
    document.getElementById('health-bar-container')
  ];
  
  // Hide each element if it exists
  instructionElements.forEach(element => {
    if (element) {
      element.style.display = 'none';
    }
  });
  
  // Create a mutation observer to catch any new instruction elements
  const observer = new MutationObserver((mutations) => {
    mutations.forEach(mutation => {
      if (mutation.addedNodes && mutation.addedNodes.length > 0) {
        for (let i = 0; i < mutation.addedNodes.length; i++) {
          const node = mutation.addedNodes[i];
          if (node.nodeType === 1) { // Element node
            if (node.id && instructionElements.includes(node.id)) {
              node.style.display = 'none';
            } else if (node.className && node.className.includes('portal-instructions')) {
              node.style.display = 'none';
            }
          }
        }
      }
    });
  });
  
  // Start observing the document
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
}

/**
 * Create touch controls for mobile devices with improved handling
 * @param {Player} player - The Player instance
 * @param {SoundManager} soundManager - The SoundManager instance for audio feedback
 */
function createMobileControls(player, soundManager) {
  // Position constants for easy adjustment
  const CONSTANTS = {
    // Jump button positioning
    JUMP_BUTTON: {
      BOTTOM: 100,  // Distance from bottom edge
      RIGHT: 40,   // Distance from right edge
      SIZE: 60     // Button size
    },
    // Left control hint (movement joystick)
    LEFT_JOYSTICK: {
      BOTTOM: 30,  // Distance from bottom edge
      LEFT: 90,    // Distance from left edge
      SIZE: 120    // Joystick size
    },
    // Right control hint (aim/shoot joystick)
    RIGHT_JOYSTICK: {
      BOTTOM: 30,  // Distance from bottom edge
      RIGHT: 135,   // Distance from right edge
      SIZE: 100    // Joystick size
    },
    // Camera area - not using a dedicated button, instead using the area above the aim joystick
    CAMERA_AREA: {
      Y_OFFSET: 130,  // Distance above the aim joystick
      HEIGHT: 150,    // Height of the camera area
      WIDTH: 120      // Width of the camera area (matching the aim joystick)
    },
    // Sensitivities
    MOVE_THRESHOLD: 10,                // Minimum movement in pixels before registering movement
    MOVE_SENSITIVITY: 0.15,            // Movement speed multiplier
    LOOK_SENSITIVITY: 0.4,             // Look speed multiplier for aiming
    CAMERA_ROTATION_SENSITIVITY: 0.7   // Camera rotation sensitivity for view changes
  };

  // Single large invisible overlay for touch input
  const touchOverlay = document.createElement('div');
  touchOverlay.id = 'touch-overlay';
  touchOverlay.style.position = 'fixed';
  touchOverlay.style.top = '0';
  touchOverlay.style.left = '0';
  touchOverlay.style.width = '100%';
  touchOverlay.style.height = '100%';
  touchOverlay.style.zIndex = '999';
  touchOverlay.style.touchAction = 'none'; // Prevents browser handling of touches
  touchOverlay.style.backgroundColor = 'transparent';
  document.body.appendChild(touchOverlay);
  
  // Create jump button
  const jumpButton = document.createElement('div');
  jumpButton.id = 'jump-button';
  jumpButton.className = 'mobile-button';
  jumpButton.innerText = '↑';
  jumpButton.style.position = 'fixed';
  jumpButton.style.bottom = `${CONSTANTS.JUMP_BUTTON.BOTTOM}px`;
  jumpButton.style.right = `${CONSTANTS.JUMP_BUTTON.RIGHT}px`;
  jumpButton.style.width = `${CONSTANTS.JUMP_BUTTON.SIZE}px`;
  jumpButton.style.height = `${CONSTANTS.JUMP_BUTTON.SIZE}px`;
  jumpButton.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
  jumpButton.style.border = '2px solid rgba(255, 255, 255, 0.5)';
  jumpButton.style.borderRadius = '50%';
  jumpButton.style.display = 'flex';
  jumpButton.style.justifyContent = 'center';
  jumpButton.style.alignItems = 'center';
  jumpButton.style.fontSize = '24px';
  jumpButton.style.fontWeight = 'bold';
  jumpButton.style.color = 'white';
  jumpButton.style.zIndex = '1000'; // Ensure it's above other elements
  
  // Create reload button (initially hidden, shows when out of ammo)
  const reloadButton = document.createElement('div');
  reloadButton.id = 'reload-button';
  reloadButton.className = 'mobile-button';
  reloadButton.innerText = 'R';
  reloadButton.style.position = 'fixed';
  reloadButton.style.top = '50%';
  reloadButton.style.left = '50%';
  reloadButton.style.transform = 'translate(-50%, -50%)';
  reloadButton.style.width = '80px';
  reloadButton.style.height = '80px';
  reloadButton.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
  reloadButton.style.border = '2px solid rgba(255, 255, 255, 0.7)';
  reloadButton.style.borderRadius = '50%';
  reloadButton.style.display = 'none'; // Hidden by default
  reloadButton.style.justifyContent = 'center';
  reloadButton.style.alignItems = 'center';
  reloadButton.style.fontSize = '28px';
  reloadButton.style.fontWeight = 'bold';
  reloadButton.style.color = 'white';
  reloadButton.style.zIndex = '1002';
  
  // Create fire button (always visible but only activates when needed)
  const fireButton = document.createElement('div');
  fireButton.id = 'fire-button';
  fireButton.className = 'mobile-button';
  fireButton.innerText = '🔥';
  fireButton.style.position = 'fixed';
  fireButton.style.top = '50%';
  fireButton.style.left = '50%';
  fireButton.style.transform = 'translate(-50%, -50%)';
  fireButton.style.width = '80px';
  fireButton.style.height = '80px';
  fireButton.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
  fireButton.style.border = '2px solid rgba(255, 255, 255, 0.7)';
  fireButton.style.borderRadius = '50%';
  fireButton.style.display = 'flex';
  fireButton.style.justifyContent = 'center';
  fireButton.style.alignItems = 'center';
  fireButton.style.fontSize = '32px';
  fireButton.style.fontWeight = 'bold';
  fireButton.style.color = 'white';
  fireButton.style.zIndex = '1003';
  
  // Create weapon indicator UI (toggle buttons)
  const weaponContainer = document.createElement('div');
  weaponContainer.id = 'weapon-indicator-container';
  weaponContainer.style.position = 'fixed';
  weaponContainer.style.bottom = '240px';
  weaponContainer.style.right = '20px';
  weaponContainer.style.display = 'flex';
  weaponContainer.style.flexDirection = 'row';
  weaponContainer.style.gap = '10px';
  weaponContainer.style.zIndex = '1000';
  
  // Revolver indicator
  const revolverIndicator = document.createElement('div');
  revolverIndicator.id = 'revolver-indicator';
  revolverIndicator.className = 'weapon-indicator active'; // Start with revolver active
  revolverIndicator.style.width = '40px';
  revolverIndicator.style.height = '40px';
  revolverIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
  revolverIndicator.style.border = '2px solid rgba(255, 255, 255, 0.7)';
  revolverIndicator.style.borderRadius = '5px';
  revolverIndicator.style.display = 'flex';
  revolverIndicator.style.justifyContent = 'center';
  revolverIndicator.style.alignItems = 'center';
  
  // Set revolver icon (can be replaced with image)
  const revolverImg = document.createElement('img');
  revolverImg.src = 'models/revolverindicator.png';
  revolverImg.style.width = '80%';
  revolverImg.style.height = '80%';
  revolverImg.style.objectFit = 'contain';
  revolverIndicator.appendChild(revolverImg);
  
  // Shotgun indicator
  const shotgunIndicator = document.createElement('div');
  shotgunIndicator.id = 'shotgun-indicator';
  shotgunIndicator.className = 'weapon-indicator';
  shotgunIndicator.style.width = '40px';
  shotgunIndicator.style.height = '40px';
  shotgunIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
  shotgunIndicator.style.border = '2px solid rgba(255, 255, 255, 0.5)';
  shotgunIndicator.style.borderRadius = '5px';
  shotgunIndicator.style.display = 'flex';
  shotgunIndicator.style.justifyContent = 'center';
  shotgunIndicator.style.alignItems = 'center';
  
  // Set shotgun icon (can be replaced with image)
  const shotgunImg = document.createElement('img');
  shotgunImg.src = 'models/shotgunindicator.png';
  shotgunImg.style.width = '80%';
  shotgunImg.style.height = '80%';
  shotgunImg.style.objectFit = 'contain';
  shotgunIndicator.appendChild(shotgunImg);
  
  // Add indicators to container
  weaponContainer.appendChild(revolverIndicator);
  weaponContainer.appendChild(shotgunIndicator);
  
  // Add CSS for active weapon
  const style = document.createElement('style');
  style.textContent = `
    .weapon-indicator.active {
      border-color: #ffcc00 !important;
      box-shadow: 0 0 10px #ffcc00;
    }
  `;
  document.head.appendChild(style);
  
  // Add touch event listeners for weapon switching
  revolverIndicator.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (player.activeWeapon !== 'revolver') {
      player.switchWeapon('revolver');
      revolverIndicator.className = 'weapon-indicator active';
      shotgunIndicator.className = 'weapon-indicator';
    }
  });
  
  shotgunIndicator.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (player.activeWeapon !== 'shotgun') {
      player.switchWeapon('shotgun');
      shotgunIndicator.className = 'weapon-indicator active';
      revolverIndicator.className = 'weapon-indicator';
    }
  });
  
  // Create visual joystick hint for movement (left side)
  const leftControlHint = document.createElement('div');
  leftControlHint.id = 'left-control-hint';
  leftControlHint.className = 'control-hint';
  leftControlHint.style.position = 'fixed';
  leftControlHint.style.bottom = `${CONSTANTS.LEFT_JOYSTICK.BOTTOM}px`;
  leftControlHint.style.left = `${CONSTANTS.LEFT_JOYSTICK.LEFT}px`;
  leftControlHint.style.width = `${CONSTANTS.LEFT_JOYSTICK.SIZE}px`;
  leftControlHint.style.height = `${CONSTANTS.LEFT_JOYSTICK.SIZE}px`;
  leftControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
  leftControlHint.style.borderRadius = '50%';
  leftControlHint.style.border = '2px dashed rgba(255, 255, 255, 0.3)';
  leftControlHint.style.zIndex = '998';
  leftControlHint.style.pointerEvents = 'none';
  
  // Create inner knob for left joystick (walk)
  const leftJoystickKnob = document.createElement('div');
  leftJoystickKnob.id = 'left-joystick-knob';
  leftJoystickKnob.className = 'joystick-knob';
  leftJoystickKnob.style.position = 'absolute';
  leftJoystickKnob.style.width = `${CONSTANTS.LEFT_JOYSTICK.SIZE * 0.4}px`; // 40% of the size of the outer circle
  leftJoystickKnob.style.height = `${CONSTANTS.LEFT_JOYSTICK.SIZE * 0.4}px`;
  leftJoystickKnob.style.backgroundColor = 'rgba(255, 255, 255, 0.4)';
  leftJoystickKnob.style.borderRadius = '50%';
  leftJoystickKnob.style.top = '50%';
  leftJoystickKnob.style.left = '50%';
  leftJoystickKnob.style.transform = 'translate(-50%, -50%)';
  leftJoystickKnob.style.zIndex = '999';
  leftJoystickKnob.style.pointerEvents = 'none';
  leftControlHint.appendChild(leftJoystickKnob);
  
  // Create visual joystick hint for aiming (right side)
  const rightControlHint = document.createElement('div');
  rightControlHint.id = 'right-control-hint';
  rightControlHint.className = 'control-hint';
  rightControlHint.style.position = 'fixed';
  rightControlHint.style.bottom = `${CONSTANTS.RIGHT_JOYSTICK.BOTTOM}px`;
  rightControlHint.style.right = `${CONSTANTS.RIGHT_JOYSTICK.RIGHT}px`;
  rightControlHint.style.width = `${CONSTANTS.RIGHT_JOYSTICK.SIZE}px`;
  rightControlHint.style.height = `${CONSTANTS.RIGHT_JOYSTICK.SIZE}px`;
  rightControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
  rightControlHint.style.borderRadius = '50%';
  rightControlHint.style.border = '2px dashed rgba(255, 255, 255, 0.3)';
  rightControlHint.style.zIndex = '998';
  rightControlHint.style.pointerEvents = 'none';
  
  // Create inner knob for right joystick (aim)
  const rightJoystickKnob = document.createElement('div');
  rightJoystickKnob.id = 'right-joystick-knob';
  rightJoystickKnob.className = 'joystick-knob';
  rightJoystickKnob.style.position = 'absolute';
  rightJoystickKnob.style.width = `${CONSTANTS.RIGHT_JOYSTICK.SIZE * 0.4}px`; // 40% of the size of the outer circle
  rightJoystickKnob.style.height = `${CONSTANTS.RIGHT_JOYSTICK.SIZE * 0.4}px`;
  rightJoystickKnob.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
  rightJoystickKnob.style.borderRadius = '50%';
  rightJoystickKnob.style.top = '50%';
  rightJoystickKnob.style.left = '50%';
  rightJoystickKnob.style.transform = 'translate(-50%, -50%)';
  rightJoystickKnob.style.zIndex = '999';
  rightJoystickKnob.style.pointerEvents = 'none';
  
  // Add bullet image to right joystick knob
  const bulletImg = document.createElement('img');
  bulletImg.src = 'models/aimjoystick.png';
  bulletImg.style.width = '70%';
  bulletImg.style.height = '70%';
  bulletImg.style.position = 'absolute';
  bulletImg.style.top = '50%';
  bulletImg.style.left = '50%';
  bulletImg.style.transform = 'translate(-50%, -50%)';
  bulletImg.style.pointerEvents = 'none';
  rightJoystickKnob.appendChild(bulletImg);
  
  rightControlHint.appendChild(rightJoystickKnob);
  
  // Create visual indicator for the camera area (above the aim joystick)
  const cameraControlHint = document.createElement('div');
  cameraControlHint.id = 'camera-control-hint';
  cameraControlHint.style.position = 'fixed';
  cameraControlHint.style.top = '0';
  cameraControlHint.style.left = '0';
  cameraControlHint.style.width = '100%';
  cameraControlHint.style.height = '100%';
  cameraControlHint.style.backgroundColor = 'transparent';
  cameraControlHint.style.border = 'none';
  cameraControlHint.style.zIndex = '900'; // Below other controls
  cameraControlHint.style.pointerEvents = 'none';
  cameraControlHint.innerText = '';
  
  // Create orientation message
  const orientationMsg = document.createElement('div');
  orientationMsg.id = 'orientation-message';
  orientationMsg.innerText = 'Please rotate to landscape mode';
  orientationMsg.style.position = 'fixed';
  orientationMsg.style.top = '0';
  orientationMsg.style.left = '0';
  orientationMsg.style.width = '100%';
  orientationMsg.style.height = '100%';
  orientationMsg.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
  orientationMsg.style.color = 'white';
  orientationMsg.style.display = 'flex';
  orientationMsg.style.justifyContent = 'center';
  orientationMsg.style.alignItems = 'center';
  orientationMsg.style.fontSize = '24px';
  orientationMsg.style.zIndex = '2000';
  orientationMsg.style.display = 'none';
  
  // Add elements to document
  document.body.appendChild(weaponContainer);
  document.body.appendChild(jumpButton);
  document.body.appendChild(reloadButton);
  document.body.appendChild(fireButton);
  document.body.appendChild(leftControlHint);
  document.body.appendChild(rightControlHint);
  document.body.appendChild(cameraControlHint);
  document.body.appendChild(orientationMsg);
  
  // Variables to track touch state
  let leftSideTouchId = null;
  let rightSideTouchId = null;
  let cameraTouchId = null;
  let leftStartPos = { x: 0, y: 0 };
  let rightStartPos = { x: 0, y: 0 };
  let cameraStartPos = { x: 0, y: 0 };
  let rightTouchStartTime = 0;
  let screenWidth = window.innerWidth;
  let isAimingWithTouch = false;
  
  // Initial state of player
  player.moveForward = false;
  player.moveBackward = false;
  player.moveLeft = false;
  player.moveRight = false;
  player.isAiming = false;
  
  // Mobile users should be sprinting by default
  player.isSprinting = true;
  
  // Override auto-reload with manual reload for mobile
  const originalShoot = player.shoot;
  player.shoot = function() {
    const result = originalShoot.apply(this, arguments);
    
    // Show reload button when out of bullets instead of auto-reloading
    if (this.bullets <= 0 && !this.isReloading) {
      reloadButton.style.display = 'flex';
    }
    
    return result;
  };
  
  // Touch start handler
  touchOverlay.addEventListener('touchstart', (e) => {
    // Ensure audio is activated on first touch
    ensureAudioContextResumed();
    
    // Dismiss any instructions/info banner that might be visible
    const instructionsElement = document.getElementById('instructions');
    if (instructionsElement && instructionsElement.parentNode) {
      instructionsElement.parentNode.removeChild(instructionsElement);
    }
    
    // Get joystick element positions for accurate activation areas
    const leftJoystickRect = leftControlHint.getBoundingClientRect();
    const rightJoystickRect = rightControlHint.getBoundingClientRect();
    const jumpButtonRect = jumpButton.getBoundingClientRect();
    
    // Get chat area if it exists
    let chatRect = null;
    const chatContainer = document.getElementById('chat-container');
    if (chatContainer) {
      chatRect = chatContainer.getBoundingClientRect();
    }
    
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      const x = touch.clientX;
      const y = touch.clientY;
      
      // Get the screen dimensions
      const screenHeight = window.innerHeight;
      
      // Skip if touch is on jump button to avoid interfering with its handler
      if (x >= jumpButtonRect.left && 
          x <= jumpButtonRect.right &&
          y >= jumpButtonRect.top && 
          y <= jumpButtonRect.bottom) {
        continue;
      }
      
      // Skip if touch is in chat area
      if (chatRect && 
          x >= chatRect.left && 
          x <= chatRect.right && 
          y >= chatRect.top && 
          y <= chatRect.bottom) {
        continue;
      }
      
      // Check if touch is in left joystick area (movement)
      if (x >= leftJoystickRect.left && 
          x <= leftJoystickRect.right &&
          y >= leftJoystickRect.top && 
          y <= leftJoystickRect.bottom) {
        
        if (leftSideTouchId === null) {
          leftSideTouchId = touch.identifier;
          leftStartPos.x = x;
          leftStartPos.y = y;
          
          // Visual feedback - highlight active control
          leftControlHint.style.borderColor = 'rgba(255, 255, 255, 0.7)';
          leftControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
          
          // Do not move the entire joystick anymore
          // Just keep it in place and let only the knob move
        }
      } 
      // Check if touch is in right joystick area (aim/shoot)
      else if (x >= rightJoystickRect.left && 
               x <= rightJoystickRect.right &&
               y >= rightJoystickRect.top && 
               y <= rightJoystickRect.bottom) {
        
        if (rightSideTouchId === null) {
          rightSideTouchId = touch.identifier;
          rightStartPos.x = x;
          rightStartPos.y = y;
          rightTouchStartTime = Date.now();
          
          // Visual feedback - highlight active control
          rightControlHint.style.borderColor = 'rgba(255, 255, 255, 0.7)';
          rightControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
          
          // Do not move the entire joystick anymore
          // Just keep it in place and let only the knob move
          
          // Start aiming immediately on touch
          player.isAiming = true;
          isAimingWithTouch = true;
          player.isLmbPressed = true; // Mark that touch is being held for shooting
          
          // Show and prepare crosshair for animation
          const crosshair = document.getElementById('crosshair');
          if (crosshair) {
            // Reset any existing animation classes
            crosshair.classList.remove('contract', 'expand', 'expanded');
            crosshair.style.display = 'block';
          }
          
          if (soundManager) {
            soundManager.playSound(player.activeWeapon === 'shotgun' ? "shotgundraw" : "revolverdraw");
          }
        }
      }
      // If not on any specific control, use touch for camera control
      else if (cameraTouchId === null) {
        cameraTouchId = touch.identifier;
        cameraStartPos.x = x;
        cameraStartPos.y = y;
      }
    }
    e.preventDefault();
  });
  
  // Touch move handler
  touchOverlay.addEventListener('touchmove', (e) => {
    // Dismiss any instructions/info banner that might be visible
    const instructionsElement = document.getElementById('instructions');
    if (instructionsElement && instructionsElement.parentNode) {
      instructionsElement.parentNode.removeChild(instructionsElement);
    }
    
    for (let i = 0; i < e.touches.length; i++) {
      const touch = e.touches[i];
      
      // Handle left side touch (movement)
      if (touch.identifier === leftSideTouchId) {
        const deltaX = touch.clientX - leftStartPos.x;
        const deltaY = touch.clientY - leftStartPos.y;
        
        // Move the joystick knob
        const leftJoystickKnob = document.getElementById('left-joystick-knob');
        if (leftJoystickKnob) {
          // Calculate the distance from center
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          // Get the max distance the knob can move (radius of outer circle - radius of knob)
          const maxDistance = CONSTANTS.LEFT_JOYSTICK.SIZE * 0.3; // 30% of the outer circle size
          
          if (distance > 0) {
            // Normalize the position to the max distance
            const normalizedDistance = Math.min(distance, maxDistance);
            const normalizedX = deltaX * (normalizedDistance / distance);
            const normalizedY = deltaY * (normalizedDistance / distance);
            
            // Move the knob from center position
            leftJoystickKnob.style.transform = `translate(calc(-50% + ${normalizedX}px), calc(-50% + ${normalizedY}px))`;
          }
        }
        
        // Only apply movement if joystick is moved beyond threshold
        if (Math.abs(deltaX) > CONSTANTS.MOVE_THRESHOLD || Math.abs(deltaY) > CONSTANTS.MOVE_THRESHOLD) {
          // Forward/backward based on vertical movement
          player.moveForward = deltaY < -CONSTANTS.MOVE_THRESHOLD;
          player.moveBackward = deltaY > CONSTANTS.MOVE_THRESHOLD;
          
          // Left/right based on horizontal movement
          player.moveLeft = deltaX < -CONSTANTS.MOVE_THRESHOLD;
          player.moveRight = deltaX > CONSTANTS.MOVE_THRESHOLD;
        }
      }
      
      // Handle right side touch (aiming + camera rotation)
      if (touch.identifier === rightSideTouchId) {
        const deltaX = touch.clientX - rightStartPos.x;
        const deltaY = touch.clientY - rightStartPos.y;
        
        // Move the joystick knob
        const rightJoystickKnob = document.getElementById('right-joystick-knob');
        if (rightJoystickKnob) {
          // Calculate the distance from center
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          // Get the max distance the knob can move (radius of outer circle - radius of knob)
          const maxDistance = CONSTANTS.RIGHT_JOYSTICK.SIZE * 0.3; // 30% of the outer circle size
          
          if (distance > 0) {
            // Normalize the position to the max distance
            const normalizedDistance = Math.min(distance, maxDistance);
            const normalizedX = deltaX * (normalizedDistance / distance);
            const normalizedY = deltaY * (normalizedDistance / distance);
            
            // Move the knob from center position
            rightJoystickKnob.style.transform = `translate(calc(-50% + ${normalizedX}px), calc(-50% + ${normalizedY}px))`;
          }
        }
        
        // Apply camera rotation - allow for 360° movement
        player.group.rotation.y -= deltaX * CONSTANTS.LOOK_SENSITIVITY * 0.01;
        player.camera.rotation.x -= deltaY * CONSTANTS.LOOK_SENSITIVITY * 0.01;
        
        // Limit vertical rotation to avoid flipping
        player.camera.rotation.x = Math.max(
          -Math.PI / 2,
          Math.min(Math.PI / 2, player.camera.rotation.x)
        );
        
        // Update starting position to prevent continuous rotation
        rightStartPos.x = touch.clientX;
        rightStartPos.y = touch.clientY;
      }
      
      // Handle camera area touch (separate from aiming)
      if (touch.identifier === cameraTouchId) {
        const deltaX = touch.clientX - cameraStartPos.x;
        const deltaY = touch.clientY - cameraStartPos.y;
        
        // Apply full 360° camera rotation based on touch movement
        player.group.rotation.y -= deltaX * CONSTANTS.CAMERA_ROTATION_SENSITIVITY * 0.01;
        player.camera.rotation.x -= deltaY * CONSTANTS.CAMERA_ROTATION_SENSITIVITY * 0.01;
        
        // Limit vertical rotation to avoid flipping
        player.camera.rotation.x = Math.max(
          -Math.PI / 2,
          Math.min(Math.PI / 2, player.camera.rotation.x)
        );
        
        // Update starting position to prevent continuous rotation
        cameraStartPos.x = touch.clientX;
        cameraStartPos.y = touch.clientY;
      }
    }
    e.preventDefault();
  });
  
  // Touch end handler
  touchOverlay.addEventListener('touchend', (e) => {
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      
      // Handle left side touch end (movement)
      if (touch.identifier === leftSideTouchId) {
        leftSideTouchId = null;
        
        // Reset movement flags
        player.moveForward = false;
        player.moveBackward = false;
        player.moveLeft = false;
        player.moveRight = false;
        
        // Reset visual feedback
        leftControlHint.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        leftControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        
        // Reset joystick knob position
        const leftJoystickKnob = document.getElementById('left-joystick-knob');
        if (leftJoystickKnob) {
          leftJoystickKnob.style.transform = 'translate(-50%, -50%)';
        }
      }
      
      // Handle right side touch end (shooting on release)
      if (touch.identifier === rightSideTouchId) {
        // Shoot when releasing the touch if still aiming
        if (isAimingWithTouch && player.isAiming && !player.isReloading) {
          player.shoot();
        }
        player.isLmbPressed = false;
        
        // Stop aiming
        player.isAiming = false;
        isAimingWithTouch = false;
        
        // Play contraction animation before hiding crosshair
        const crosshair = document.getElementById('crosshair');
        if (crosshair) {
          // Reset any existing classes
          crosshair.classList.remove('expand', 'expanded');
          
          // Add contraction animation
          crosshair.classList.add('contract');
          
          // Hide crosshair after animation completes
          setTimeout(() => {
            crosshair.style.display = 'none';
            crosshair.classList.remove('contract');
          }, 250); // Match animation duration
        }
        
        // Reset visual feedback
        rightControlHint.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        rightControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        
        // Reset joystick knob position
        const rightJoystickKnob = document.getElementById('right-joystick-knob');
        if (rightJoystickKnob) {
          rightJoystickKnob.style.transform = 'translate(-50%, -50%)';
        }
        
        rightSideTouchId = null;
      }
      
      // Handle camera touch end
      if (touch.identifier === cameraTouchId) {
        cameraTouchId = null;
      }
    }
    e.preventDefault();
  });
  
  // Touch cancel handler - similar updates
  touchOverlay.addEventListener('touchcancel', (e) => {
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      
      // Reset left side touch (movement)
      if (touch.identifier === leftSideTouchId) {
        leftSideTouchId = null;
        player.moveForward = false;
        player.moveBackward = false;
        player.moveLeft = false;
        player.moveRight = false;
        
        // Reset visual feedback
        leftControlHint.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        leftControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        
        // Reset joystick knob position
        const leftJoystickKnob = document.getElementById('left-joystick-knob');
        if (leftJoystickKnob) {
          leftJoystickKnob.style.transform = 'translate(-50%, -50%)';
        }
      }
      
      // Reset right side touch (aiming)
      if (touch.identifier === rightSideTouchId) {
        rightSideTouchId = null;
        player.isAiming = false;
        isAimingWithTouch = false;
        
        // Clear any pressed state
        if (player.isLmbPressed) {
          player.isLmbPressed = false;
        }
        
        // Reset visual feedback
        rightControlHint.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        rightControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        
        // Reset joystick knob position
        const rightJoystickKnob = document.getElementById('right-joystick-knob');
        if (rightJoystickKnob) {
          rightJoystickKnob.style.transform = 'translate(-50%, -50%)';
        }
        
        // Play contraction animation before hiding crosshair
        const crosshair = document.getElementById('crosshair');
        if (crosshair) {
          // Reset any existing classes
          crosshair.classList.remove('expand', 'expanded');
          
          // Add contraction animation
          crosshair.classList.add('contract');
          
          // Hide crosshair after animation completes
          setTimeout(() => {
            crosshair.style.display = 'none';
            crosshair.classList.remove('contract');
          }, 250);
        }
      }
      
      // Reset camera rotation touch
      if (touch.identifier === cameraTouchId) {
        cameraTouchId = null;
      }
    }
    e.preventDefault();
  });
  
  // Reload button handler
  reloadButton.addEventListener('touchstart', (e) => {
    if (!player.isReloading && player.bullets < player.maxBullets) {
      player.startReload();
      reloadButton.style.display = 'none';
    }
    e.preventDefault();
  });
  
  // Fire button handler
  fireButton.addEventListener('touchstart', (e) => {
    if (player.canAim && !player.isFAiming) {
      player.isAiming = true;
      player.isFAiming = true;
      
      // Optionally show arms in first-person
      if (player.arms) {
        player.arms.setVisible(true);
      }
      
      // Show and prepare crosshair for animation
      const crosshair = document.getElementById('crosshair');
      if (crosshair) {
        // Reset any existing animation classes
        crosshair.classList.remove('contract', 'expand', 'expanded');
        crosshair.style.display = 'block';
      }

      if (soundManager) {
        soundManager.playSound(player.activeWeapon === 'shotgun' ? "shotgundraw" : "revolverdraw");
      }
    }
    e.preventDefault();
  });
  
  // Jump button handler
  jumpButton.addEventListener('touchstart', (e) => {
    if (player.canJump) {
      // Original jump behavior
      player.velocity.y = player.isSprinting ? 15 : 10;
      player.canJump = false;
      player.isJumping = true;
      
      // Play jump sound
      if (player.soundManager) {
        player.soundManager.playSound("jumpup", 0, 1.5);
      }
    }
    e.preventDefault();
  });
  
  // Handle window resize to update the screen width calculation
  window.addEventListener('resize', () => {
    screenWidth = window.innerWidth;
  });
  
  // Ensure audio context is resumed for mobile
  function ensureAudioContextResumed() {
    if (soundManager && soundManager.audioContext && 
        soundManager.audioContext.state !== 'running') {
      // Resume the audio context on first user interaction
      soundManager.audioContext.resume().then(() => {
        console.log('AudioContext resumed successfully');
        // Play a silent sound to fully activate audio
        if (soundManager.buffers['revolverdraw']) {
          const silentSound = soundManager.playSound('revolverdraw', 0, 0.01);
          if (silentSound && silentSound.gainNode) {
            silentSound.gainNode.gain.value = 0.01;
          }
        }
      }).catch(err => {
        console.error('Failed to resume AudioContext:', err);
      });
    }
  }
  
  // Return methods to be called from the game loop
  return {
    checkForNearbyPlayers: function(nearbyPlayersExist) {
      // Show/hide the invite button based on whether there are nearby players
      fireButton.style.display = nearbyPlayersExist ? 'flex' : 'none';
    },
    showBartenderButton: function() {},
    hideBartenderButton: function() {}
  };
}

/**
 * Check device orientation and display warning if not in landscape mode on mobile
 */
function checkOrientation() {
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  if (isMobile) {
    const orientationMsg = document.getElementById('orientation-message');
    
    // Check if we're in portrait mode
    if (window.innerHeight > window.innerWidth) {
      orientationMsg.style.display = 'flex';
    } else {
      orientationMsg.style.display = 'none';
    }
  }
}

// Function to update health display - modified to handle missing health counter
function updateHealthDisplay(health, maxHealth) {
  // Skip the health counter update since we removed it from the UI
  
  // Only update health bar if it exists
  const healthBar = document.getElementById('health-bar');
  if (healthBar) {
    const healthPercent = Math.max(0, health / maxHealth * 100);
    healthBar.style.width = `${healthPercent}%`;
    
    // Change color based on health level
    if (healthPercent > 66) {
      healthBar.style.backgroundColor = '#4CAF50'; // Green
    } else if (healthPercent > 33) {
      healthBar.style.backgroundColor = '#FFC107'; // Yellow
    } else {
      healthBar.style.backgroundColor = '#F44336'; // Red
    }
  }
}

function isMobileDevice() {
  return (window.innerWidth <= 1024 || 'ontouchstart' in window || navigator.maxTouchPoints > 0);
}

// This function ensures the game takes up the full screen space with no white bars
function ensureFullscreen() {
  // Set body and html to full viewport dimensions
  document.documentElement.style.width = '100%';
  document.documentElement.style.height = '100%';
  document.body.style.width = '100%';
  document.body.style.height = '100%';
  document.body.style.margin = '0';
  document.body.style.padding = '0';
  document.body.style.overflow = 'hidden';
  document.body.style.backgroundColor = '#000';
  document.body.style.position = 'fixed';
  
  // Set game container to full viewport
  const gameContainer = document.getElementById('game-container');
  if (gameContainer) {
    gameContainer.style.position = 'fixed';
    gameContainer.style.top = '0';
    gameContainer.style.left = '0';
    gameContainer.style.right = '0';
    gameContainer.style.bottom = '0';
    gameContainer.style.width = '100%';
    gameContainer.style.height = '100%';
    gameContainer.style.margin = '0';
    gameContainer.style.padding = '0';
    gameContainer.style.overflow = 'hidden';
    gameContainer.style.backgroundColor = '#000';
  }
  
  // Make sure canvas fills the screen
  const canvas = document.querySelector('canvas');
  if (canvas) {
    canvas.style.position = 'fixed';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.right = '0';
    canvas.style.bottom = '0';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.margin = '0';
    canvas.style.padding = '0';
    canvas.style.display = 'block';
    canvas.style.backgroundColor = '#000';
    
    // iOS Safari specific fixes
    if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
      // Fix for iOS notch and home indicator
      canvas.style.width = '100vw';
      canvas.style.height = '100vh';
      
      // Prevent elastic scrolling
      document.addEventListener('touchmove', (e) => {
        if (e.scale !== 1) {
          e.preventDefault();
        }
      }, { passive: false });
      
      // Force scroll to top on resize/orientation change
      window.addEventListener('resize', () => {
        window.scrollTo(0, 0);
        document.body.style.height = window.innerHeight + 'px';
        canvas.style.height = window.innerHeight + 'px';
      });
      
      // Initial height fix
      setTimeout(() => {
        window.scrollTo(0, 0);
        document.body.style.height = window.innerHeight + 'px';
        canvas.style.height = window.innerHeight + 'px';
      }, 300);
    }
  }
}

================================================
File: /public/js/logger.js
================================================
/**
 * Logger - A simple configurable logging system for the game
 * Allows toggling debug logs globally to reduce console spam
 */
export class Logger {
  constructor() {
    // Default log levels
    this.levels = {
      error: true,   // Always show errors
      warn: true,    // Always show warnings
      info: false,   // Toggle general info logs
      debug: false,  // Toggle verbose debug logs
      physics: false // Toggle physics-related logs
    };
    
    // Production mode - don't load from localStorage
  }
  
  /**
   * Load logger settings from localStorage
   */
  loadSettings() {
    // Disabled for production
  }
  
  /**
   * Save current settings to localStorage
   */
  saveSettings() {
    // Disabled for production
  }
  
  /**
   * Set a specific log level
   * @param {string} level - Level name
   * @param {boolean} enabled - Whether to enable it
   */
  setLevel(level, enabled) {
    if (level in this.levels) {
      this.levels[level] = enabled;
      this.saveSettings();
    }
  }
  
  /**
   * Log an error message (always shown)
   * @param {...any} args - Arguments to log
   */
  error(...args) {
    console.error(...args);
  }
  
  /**
   * Log a warning message (always shown)
   * @param {...any} args - Arguments to log
   */
  warn(...args) {
    console.warn(...args);
  }
  
  /**
   * Log an info message (can be toggled)
   * @param {...any} args - Arguments to log
   */
  info(...args) {
    if (this.levels.info) {
      console.log(...args);
    }
  }
  
  /**
   * Log a debug message (can be toggled)
   * @param {...any} args - Arguments to log
   */
  debug(...args) {
    if (this.levels.debug) {
      console.log(...args);
    }
  }
  
  /**
   * Log a physics-related message (can be toggled)
   * @param {...any} args - Arguments to log
   */
  physics(...args) {
    if (this.levels.physics) {
      console.log(...args);
    }
  }
  
  /**
   * Create a simple UI for toggling log levels
   * @param {HTMLElement} container - Container element
   */
  createUI(container) {
    const div = document.createElement('div');
    div.className = 'logger-controls';
    div.style.position = 'fixed';
    div.style.bottom = '10px';
    div.style.right = '10px';
    div.style.backgroundColor = 'rgba(0,0,0,0.7)';
    div.style.padding = '10px';
    div.style.borderRadius = '5px';
    div.style.color = 'white';
    div.style.zIndex = '1000';
    div.style.fontSize = '12px';
    
    const title = document.createElement('div');
    title.textContent = 'Debug Logs';
    title.style.fontWeight = 'bold';
    title.style.marginBottom = '5px';
    div.appendChild(title);
    
    // Create toggle for each log level
    Object.keys(this.levels).forEach(level => {
      const label = document.createElement('label');
      label.style.display = 'block';
      label.style.marginBottom = '3px';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = this.levels[level];
      checkbox.addEventListener('change', () => {
        this.setLevel(level, checkbox.checked);
      });
      
      label.appendChild(checkbox);
      label.appendChild(document.createTextNode(` ${level}`));
      div.appendChild(label);
    });
    
    container.appendChild(div);
  }
}

// Create global logger instance
const logger = new Logger();

// Replace console functions with logger if enabled
if (typeof window !== 'undefined') {
  window.logger = logger;
}

export default logger; 

================================================
File: /public/js/main.js
================================================
import { initScene, updateFPS, scene } from './scene.js';
import { initInput } from './input.js';
import { SoundManager } from './soundManager.js';
import { Player } from './player.js';
import { networkManager } from './network.js';
import { MultiplayerManager } from './multiplayerManager.js';
import { Bullet } from './bullet.js';
import { ThirdPersonModel } from './playerModel.js';
import { PhysicsSystem } from './physics.js';
import { createMuzzleFlash, createSmokeEffect, createImpactEffect, preloadMuzzleFlash, preloadSmokeEffect, SmokeRingEffect, DrunkennessEffect } from './effects.js';
import { updateAmmoUI, updateHealthUI } from './ui.js';
import { Viewmodel } from './viewmodel.js';
import { initPlayerIdentity, verifyIdentityWithServer } from './playerIdentity.js';
import logger from './logger.js';
// Removed FlyingEagle import
import { initChat, handleChatMessage, addSystemMessage } from './chat.js';
import './viewmodel-config.js';

// Check if device is mobile
function isMobileDevice() {
  return (window.innerWidth <= 1024 || 'ontouchstart' in window || navigator.maxTouchPoints > 0 || 
         /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
}

// Set global flag for mobile
window.isMobile = isMobileDevice();

// Keep track of all bullets in the game, both local and remote
let bullets = [];

// Anti-cheat: Map bullets by ID for server authority
let bulletMap = new Map(); // bulletId -> Bullet object

// We'll keep references to local player, remote players, and a combined map
let localPlayer;
let remotePlayers = new Map();  // (playerId => ThirdPersonModel)
let playersMap = new Map();     // Master map including local + remote

// Scenes, camera, etc.
let renderer, camera;
let multiplayerManager;
let physics;
let lastTime = 0;

// Smoke ring effects
let smokeRings = [];
let maxSmokeRings = 10; // Limit to prevent performance issues

// Add a flag to track debug visualization mode
window.showHitZoneDebug = false;
window.showTownColliders = false; // Disable for production

// Create a global renderer object to allow camera switching
window.renderer = {
  instance: null,
  camera: null,
  setCamera: function(newCamera) {
    this.camera = newCamera;
  }
};

// Initialize the application
async function init() {
  try {
    // Start the init process without waiting for player identity
    
    // Set debug mode flag
    window.debugMode = false; // Disabled for production
    
    // Initialize logger UI if in debug mode
    if (window.debugMode) {
      const gameContainer = document.getElementById('gameContainer') || document.body;
      logger.createUI(gameContainer);
    }
    
    // Detect if we're on a mobile device
    window.isMobile = isMobileDevice();
    
    // Setup viewport detection and handling
    setupViewportHandling();
    
    // Initialize scene - use the scene from initScene instead of creating a new one
    const sceneSetup = initScene();
    camera = sceneSetup.camera;
    renderer = sceneSetup.renderer;
    
    // Set up global renderer access for camera switching
    window.renderer.instance = renderer;
    window.renderer.camera = camera;
    
    // Initialize physics system first so it's available for the scene
    physics = new PhysicsSystem();
    window.physics = physics; // Make physics globally accessible

    const soundManager = new SoundManager();
    
    // Start loading sounds while the user is entering their name
    // Load shot sounds
    soundManager.loadSound("shot", "sounds/shot.mp3");
    soundManager.loadSound("revolverdraw", "sounds/revolverdraw.mp3");
    // replacing shellejection with the combined reloading sound
    soundManager.loadSound("reloading", "sounds/reloading.mp3");
    // Load impact sounds
    soundManager.loadSound("woodimpact", "sounds/woodimpact.mp3");
    soundManager.loadSound("fleshimpact", "sounds/fleshimpact.mp3");
    
    // Load footstep and jump sounds
    soundManager.loadSound("leftstep", "sounds/leftstep.mp3");
    soundManager.loadSound("rightstep", "sounds/rightstep.mp3");
    soundManager.loadSound("jumpup", "sounds/jumpup.mp3");
    soundManager.loadSound("jumpland", "sounds/jumpland.mp3");
    soundManager.loadSound("recoiljump", "sounds/recoiljump.mp3");
    
    // Load headshot marker sound
    soundManager.loadSound("headshotmarker", "sounds/headshotmarker.mp3");
    
    // Load hitmarker sound
    soundManager.loadSound("hitmarker", "sounds/hitmarker.mp3");
    
    // Load new sound effects
    soundManager.loadSound("dramatic", "sounds/dramatic.mp3");
    soundManager.loadSound("eaglescream", "sounds/eaglescream.mp3");
    soundManager.loadSound("eagledeath", "sounds/eagledeath.mp3");
    soundManager.loadSound("playerfall", "sounds/playerfall.mp3");
    soundManager.loadSound("ambience", "sounds/ambience.mp3");
    
    // Load gun sounds
    soundManager.loadSound("shot", "sounds/shot.mp3");
    soundManager.loadSound("revolverdraw", "sounds/revolverdraw.mp3");
    soundManager.loadSound("reloading", "sounds/reloading.mp3");
    soundManager.loadSound("shotgunempty", "sounds/shotgunempty.mp3");
    soundManager.loadSound("revolverholstering", "sounds/revolverholstering.mp3");
    
    // Load shotgun sounds
    soundManager.loadSound("shotgundraw", "sounds/shotgundraw.mp3");
    soundManager.loadSound("shotgunshot", "sounds/shotgunshot.mp3");
    soundManager.loadSound("shotgunreloading", "sounds/shotgunreloading.mp3");
    soundManager.loadSound("shotgunholstering", "sounds/shotgunholstering.mp3");
    
    // Load impact sounds
    soundManager.loadSound("woodimpact", "sounds/woodimpact.mp3");
    
    // Start background ambient music loop
    setTimeout(() => {
      soundManager.playSound("ambience", 0, 0.4, true); // Play at lower volume in a loop
    }, 1000); // Slight delay to ensure the sound is loaded
    
    // In parallel, initialize player identity
    // This will show the name prompt for first-time users if needed
    // but won't block the rest of the initialization
    const playerIdentityPromise = initPlayerIdentity().then(playerIdentity => {
      console.log(`Welcome back, ${playerIdentity.username}! Player ID: ${playerIdentity.id}`);
      
      // Check if this was a first-time user to determine when to show instructions
      const isFirstTimeUser = playerIdentity.lastLogin === playerIdentity.createdAt;
      
      // Verify identity with server (will be used in future server-side validation)
      return verifyIdentityWithServer(playerIdentity).then(verificationResult => {
        if (!verificationResult.verified) {
          console.warn('Identity verification failed, using local identity only');
        }
        
        // Expose player identity to window for easy access from other modules
        window.playerIdentity = playerIdentity;
        
        return playerIdentity;
      });
    });

    // Preload all visual effects to prevent FPS drops on first use
    if (!window.isMobile) {
      console.log("Preloading visual effects...");
      // Preload muzzle flash effect
      preloadMuzzleFlash(scene);
      // Preload smoke effect
      preloadSmokeEffect(scene);
      
      // Initialize a smoke ring effect pool for reuse
      for (let i = 0; i < 3; i++) {
        const smokeRing = new SmokeRingEffect(scene);
        smokeRing.active = false;
        // Preload resources to prevent fps drop on first use
        smokeRing.preload();
        smokeRings.push(smokeRing);
      }
      
      // Simulate a complete dummy shot cycle in a hidden area
      // This ensures all shaders are compiled and resources are allocated
      console.log("Pre-rendering a dummy shot to warm up rendering pipeline...");
      const dummyPosition = new THREE.Vector3(0, -1000, 0);
      const dummyDirection = new THREE.Vector3(0, 0, 1);
      
      // Create all effects that happen during a shot
      createMuzzleFlash(dummyPosition, dummyDirection, scene);
      createSmokeEffect(dummyPosition, dummyDirection, scene);
      
      // Create a few impact effects of different types
      createImpactEffect(dummyPosition, dummyDirection, scene, 'wood');
      createImpactEffect(dummyPosition, dummyDirection, scene, 'metal');
      createImpactEffect(dummyPosition, dummyDirection, scene, 'dirt');
      
      // Create a dummy bullet - but don't track it since this is just preloading
      const dummyBullet = new Bullet(dummyPosition, dummyDirection);
      scene.add(dummyBullet.mesh);
      // Remove after a short delay
      setTimeout(() => {
        scene.remove(dummyBullet.mesh);
      }, 100);
    }

    // Set up multiplayer manager to handle other players
    multiplayerManager = new MultiplayerManager(scene, soundManager, remotePlayers);
    
    // Wait for player identity to be resolved before continuing with network/player setup
    const playerIdentity = await playerIdentityPromise;
    
    // Initialize the phantom wallet adapter with network manager for NFT verification
    if (typeof phantomWalletAdapter !== 'undefined') {
      console.log('Initializing Phantom wallet adapter');
      phantomWalletAdapter.init(networkManager);
      
      // Listen for wallet connection events to apply skins
      document.addEventListener('walletConnected', (e) => {
        console.log('Wallet connected event received in main.js');
      });
    } else {
      console.warn('Phantom wallet adapter not available');
    }
    
    // Make multiplayerManager globally accessible
    window.multiplayerManager = multiplayerManager;

    // Initialize the local player
    localPlayer = new Player({
      scene: scene,
      camera: camera,
      soundManager: soundManager,
      onShoot: handleLocalPlayerShoot  // callback for local shooting
    });
    // Make localPlayer globally accessible for hit updates.
    window.localPlayer = localPlayer;

    // Initialize UI elements - desktop weapon indicators
    createDesktopWeaponIndicators();
    
    // Initialize first-person controls
    const mobileControls = initInput(renderer, localPlayer, soundManager);
    
    // Make mobile controls globally accessible
    if (isMobileDevice()) {
      window.mobileControls = mobileControls;
    }
    
    // Make scene globally accessible for physics visualization
    window.scene = scene;

    // Initialize drunkenness effect - pass both player and camera arguments
    const drunkennessEffect = new DrunkennessEffect(localPlayer, camera);
    console.log('Drunkenness effect initialized');
    
    // Show connection status
    const networkStatus = document.createElement('div');
    networkStatus.id = 'network-status';
    networkStatus.textContent = 'Connecting...';
    document.getElementById('game-container').appendChild(networkStatus);

    // Update player count UI when server broadcasts the count.
    networkManager.onPlayerCount = (count) => {
      const playerCountEl = document.getElementById('player-count');
      if (playerCountEl) {
        playerCountEl.textContent = `Players: ${count}`;
      }
    };

    // Listen for network open/close
    networkManager.socket.addEventListener('open', () => {
      networkStatus.textContent = 'Connected';
      networkStatus.style.backgroundColor = 'rgba(0,128,0,0.5)';
      setTimeout(() => { networkStatus.style.opacity = '0'; }, 2000);
    });
    networkManager.socket.addEventListener('close', () => {
      networkStatus.textContent = 'Disconnected';
      networkStatus.style.backgroundColor = 'rgba(255,0,0,0.5)';
      networkStatus.style.opacity = '1';
    });

    // Listen for remote players shooting
    networkManager.onPlayerShoot = (playerId, bulletData, bulletId) => {
      handleRemotePlayerShoot(playerId, bulletData, bulletId);
    };

    // Anti-cheat: Listen for bullet impact notifications from server
    networkManager.onBulletImpact = (bulletId, hitType, targetId, position, hitZone) => {
      handleBulletImpact(bulletId, hitType, targetId, position, hitZone);
    };

    // Anti-cheat: Listen for position corrections from server
    networkManager.onPositionCorrection = (correctedPosition) => {
      if (localPlayer) {
        // Store the server position for reconciliation
        localPlayer.serverPosition = new THREE.Vector3(
          correctedPosition.x,
          correctedPosition.y,
          correctedPosition.z
        );
        localPlayer.isReconciling = true;
      }
    };
    
    // Train synchronization: Handle initial train state
    networkManager.onTrainInit = (data) => {
      // Import the train functions from scene.js
      import('./scene.js').then(sceneModule => {
        sceneModule.setTrainInitialState(data);
      });
    };
    
    // Train synchronization: Handle ongoing train state updates
    // We only process the first trainState message if we haven't received trainInit yet
    networkManager.onTrainState = (data) => {
      // Import the train functions from scene.js
      import('./scene.js').then(sceneModule => {
        sceneModule.updateTrainState(data);
      });
    };
    
    // Anti-cheat: Listen for server-initiated respawn
    networkManager.onRespawn = (position, health, bullets) => {
      if (localPlayer) {
        // Set position directly without ground offset adjustment
        if (position) {
          localPlayer.group.position.copy(position);
          localPlayer.previousPosition.copy(position);
        }
        
        // Update health and bullets
        localPlayer.health = health || 100;
        localPlayer.bullets = bullets || localPlayer.maxBullets;
        
        // Reset states
        localPlayer.isReloading = false;
        localPlayer.isAiming = false;
        localPlayer.velocity.y = 0;
        
        // Reset movement flags - critical for allowing movement after respawn
        localPlayer.canMove = true;
        localPlayer.forceLockMovement = false;
        localPlayer.canAim = true;
        
        // Update UI
        updateHealthUI(localPlayer);
        updateAmmoUI(localPlayer);
      }
    };

    // Handle local player death
    networkManager.onDeath = (killerId) => {
      console.log(`You were killed by player ${killerId}`);
      
      // Show death message
      const deathMessage = document.createElement('div');
      deathMessage.innerText = 'YOU DIED';
      deathMessage.style.position = 'fixed';
      deathMessage.style.top = '50%';
      deathMessage.style.left = '50%';
      deathMessage.style.transform = 'translate(-50%, -50%)';
      deathMessage.style.color = '#FF0000';
      deathMessage.style.fontSize = '36px';
      deathMessage.style.fontWeight = 'bold';
      deathMessage.style.zIndex = '1000';
      document.getElementById('game-container').appendChild(deathMessage);
      
      // Create a red overlay effect
      const deathOverlay = document.createElement('div');
      deathOverlay.style.position = 'fixed';
      deathOverlay.style.top = '0';
      deathOverlay.style.left = '0';
      deathOverlay.style.width = '100%';
      deathOverlay.style.height = '100%';
      deathOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
      deathOverlay.style.zIndex = '999';
      document.getElementById('game-container').appendChild(deathOverlay);
      
      // Store original mouse handler for later restoration
      const origMouseMove = document.onmousemove;
      
      // Disable player controls during death animation
      if (localPlayer) {
        localPlayer.canMove = false;
        localPlayer.canAim = false;
        
        // Save original camera rotation
        const originalRotation = localPlayer.camera.rotation.clone();
        
        // Apply death camera rotation - rotate camera to look down at the ground
        // Start a smooth rotation animation from current position to looking down
        const deathCameraDuration = 1000; // 1 second for the rotation animation
        const startTime = Date.now();
        const targetRotationX = Math.PI / 2; // Looking down at the ground (90 degrees) instead of up
        
        // Create an animation function that rotates the camera over time
        const rotateCameraUp = () => {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / deathCameraDuration, 1);
          
          // Use an easing function (ease-out) for smoother animation
          const easeOut = 1 - Math.pow(1 - progress, 2);
          
          // Interpolate between original and target rotation
          localPlayer.camera.rotation.x = originalRotation.x * (1 - easeOut) + targetRotationX * easeOut;
          
          // Continue the animation until complete
          if (progress < 1) {
            requestAnimationFrame(rotateCameraUp);
          }
        };
        
        // Start the camera rotation animation
        rotateCameraUp();
        
        // Disable mouse look temporarily to prevent camera movement
        document.onmousemove = (e) => {
          // Block mouse movement during death animation
          e.stopPropagation();
          return false;
        };
        
        // Play death animation on local player model if it exists
        if (localPlayer.model && typeof localPlayer.model.playDeathAnimation === 'function') {
          localPlayer.model.playDeathAnimation();
        }
        
        // Play death sound
        if (localPlayer.soundManager) {
          localPlayer.soundManager.playSound("playerfall", 0, 0.8);
        }
      }
      
      // Remove message and overlay after animation
      // Also restore mouse control
      setTimeout(() => {
        if (deathMessage.parentNode) {
          deathMessage.parentNode.removeChild(deathMessage);
        }
        if (deathOverlay.parentNode) {
          deathOverlay.parentNode.removeChild(deathOverlay);
        }
        
        // Restore mouse movement control
        document.onmousemove = origMouseMove;
      }, 2000); // Match the server respawn delay
    };
    
    // Handle when the local player kills someone
    networkManager.onKill = (targetId) => {
      console.log(`You killed player ${targetId}`);
      
      // Show kill message
      const killMessage = document.createElement('div');
      killMessage.innerText = 'KILL!';
      killMessage.style.position = 'fixed';
      killMessage.style.top = '50%';
      killMessage.style.left = '50%';
      killMessage.style.transform = 'translate(-50%, -50%)';
      killMessage.style.color = '#00FF00';
      killMessage.style.fontSize = '36px';
      killMessage.style.fontWeight = 'bold';
      killMessage.style.zIndex = '1000';
      document.getElementById('game-container').appendChild(killMessage);
      
      // Remove message after a short time
      setTimeout(() => {
        if (killMessage.parentNode) {
          killMessage.parentNode.removeChild(killMessage);
        }
      }, 1500);
    };

    // Listen for updates to the remotePlayers map so we can refresh the master map
    multiplayerManager.onRemotePlayersUpdated = () => {
      updatePlayersMap();
      
      // If debug mode is on, make sure new players have hit zone debug boxes
      if (window.showHitZoneDebug && physics && physics.debugMode) {
        setTimeout(() => {
          if (physics.refreshHitZoneDebug && typeof physics.refreshHitZoneDebug === 'function') {
            physics.refreshHitZoneDebug();
          }
        }, 100);
      }
    };

    // Add a keyboard handler for showing town colliders (T key)
    window.addEventListener('keydown', function(event) {
      // Toggle town collider visualization with T key
      if (event.code === 'KeyT') {
        window.showTownColliders = !window.showTownColliders;
        
        // Show/hide collider meshes
        if (window.townColliders) {
          window.townColliders.forEach(({ node }) => {
            node.visible = window.showTownColliders;
          });
        }
        
        console.log(`Town collider visualization: ${window.showTownColliders ? 'ENABLED' : 'DISABLED'}`);
      }
      
      // Toggle debug mode with P key
      if (event.code === 'KeyP') {
        window.debugMode = !window.debugMode;
        
        // Synchronize physics debug mode with window debug mode
        if (physics) {
          physics.setDebugMode(window.debugMode);
        }
        
        // Set the hit zone debug flag
        window.showHitZoneDebug = window.debugMode;
        
        console.log(`Debug mode: ${window.debugMode ? 'ENABLED' : 'DISABLED'}`);
        
        // Update debug visualization
        updateDebugVisualization();
        
        // If turning on debug mode, update hit zone debug for all existing players with a delay
        if (window.debugMode) {
          setTimeout(() => {
            // First trigger hit zone debugging on the local player
            if (localPlayer && localPlayer.model && typeof localPlayer.model.createHitZoneVisualizers === 'function') {
              // Use the new method for visualization
              localPlayer.model.createHitZoneVisualizers(true);
            }
            
            // Then create debug boxes for all remote players
            for (const [playerId, remotePlayer] of remotePlayers.entries()) {
              if (remotePlayer && typeof remotePlayer.createHitZoneVisualizers === 'function') {
                // Use the new method
                remotePlayer.createHitZoneVisualizers(true);
              }
            }
            
            console.log("Hit zone debug boxes created for all players");
          }, 50);
        }
      }
      
      // Reload weapon with the R key
      if (event.code === 'KeyR') {
        localPlayer.startReload();
      }
    });

    // Make Bullet constructor globally available for hit zone debug creation
    window.Bullet = Bullet;
    
    // Install the improved hitbox system (after Bullet is globally available)
    initImprovedHitboxSystem();
    
    // Add debug command to console for troubleshooting
    window.printHitboxDebugInfo = function() {
      console.log("--- Hitbox System Debug Info ---");
      if (window.playersMap) {
        console.log(`Players map size: ${window.playersMap.size}`);
        window.playersMap.forEach((model, id) => {
          console.log(`Player ${id}:`, {
            hasCheckBulletHit: typeof model.checkBulletHit === 'function',
            headHitbox: model.headHitbox ? 'present' : 'missing',
            bodyHitbox: model.bodyHitbox ? 'present' : 'missing',
            limbsHitbox: model.limbsHitbox ? 'present' : 'missing'
          });
        });
      } else {
        console.log("Players map not found");
      }
    };
    
    // Initialize chat system
    initChat(networkManager);
    
    // Set up chat message handler
    networkManager.onChatMessage = (senderId, username, message) => {
      // Ignore messages from ourselves to prevent duplicates
      if (senderId === localPlayer.id) return;
      
      // Only handle messages from other players
      handleChatMessage({ username, message });
    };

    // Listen for skin permission updates
    networkManager.handleMessage = (originalHandleMessage => {
      return function(message) {
        // Call the original handler first
        originalHandleMessage.call(this, message);
        
        // Handle skin permission updates
        if (message.type === 'skinPermissionUpdate') {
          // Store the skin permission update in a global cache to prevent duplicate processing
          if (!window.skinPermissionCache) {
            window.skinPermissionCache = new Map();
          }
          
          // Create a cache key for this update
          const updateKey = JSON.stringify(message.skins);
          
          // Check if we've already processed this exact update
          if (window.skinPermissionCache.has(updateKey)) {
            console.log('Skipping duplicate skin permission update');
            return;
          }
          
          // Store this update in the cache
          window.skinPermissionCache.set(updateKey, true);
          
          console.log('Received skin permission update:', message);
          
          // Update local player's skin permissions
          if (localPlayer && localPlayer.model) {
            console.log('Updating skin permissions for local player model');
            localPlayer.model.updateSkinPermissions(message.skins);
            
            // Apply banana skin if permission granted
            if (message.skins.bananaSkin) {
              console.log('Local player has bananaSkin permission, applying skin to model');
              localPlayer.model.updateSkin('bananaSkin');
            }
          } else {
            console.warn('Could not update local player model - model not available');
          }
          
          // Update viewmodel skin to match
          if (localPlayer && localPlayer.viewmodel) {
            console.log('Updating skin permissions for viewmodel');
            localPlayer.viewmodel.updateSkinPermissions(message.skins);
            
            // Apply banana skin if permission granted
            if (message.skins.bananaSkin) {
              console.log('Local player has bananaSkin permission, applying skin to viewmodel');
              localPlayer.viewmodel.updateSkin('bananaSkin');
            }
          } else {
            console.warn('Could not update viewmodel - viewmodel not available');
          }
        }
      };
    })(networkManager.handleMessage);
    
    // Set up separate handler for skin updates
    networkManager.onPlayerSkinUpdate = (message) => {
      // Create a cache key for this update
      const playerUpdateKey = `${message.playerId}_${JSON.stringify(message.skins)}`;
      
      // Check if we've already processed this exact update
      if (window.skinPermissionCache && window.skinPermissionCache.has(playerUpdateKey)) {
        console.log(`Skipping duplicate skin update for player ${message.playerId}`);
        return;
      }
      
      // Store this update in the cache
      if (!window.skinPermissionCache) {
        window.skinPermissionCache = new Map();
      }
      window.skinPermissionCache.set(playerUpdateKey, true);
      
      console.log('Received player skin update:', message);
      
      const remotePlayer = remotePlayers.get(message.playerId);
      if (remotePlayer) {
        console.log(`Updating skin permissions for remote player ${message.playerId}`);
        
        // First, update the permissions in the player model
        remotePlayer.updateSkinPermissions(message.skins);
        
        // Apply banana skin if permission granted
        if (message.skins.bananaSkin) {
          console.log(`Remote player ${message.playerId} has bananaSkin permission, applying skin`);
          
          // Force the skinPermission to be set directly as well (to avoid race condition)
          remotePlayer.skinPermissions.bananaSkin = true;
          
          // Apply the skin
          if (remotePlayer.activeSkin !== 'bananaSkin') {
            remotePlayer.updateSkin('bananaSkin');
          } else {
            console.log(`Skin already applied to player ${message.playerId}`);
          }
          
          // Store skin state to prevent redundant updates in the player model
          if (!remotePlayer._cachedNetworkData) {
            remotePlayer._cachedNetworkData = {};
          }
          remotePlayer._cachedNetworkData.skins = message.skins;
          remotePlayer._initialSkinApplied = true;
          remotePlayer._lastSkinUpdate = JSON.stringify(message.skins);
        }
      } else {
        console.warn(`Could not update remote player ${message.playerId} - player not found in remotePlayers map`);
      }
    };

    // Start the animation loop
    animate(0);
    
    // Show game instructions for all users, first-time users will see it after name entry
    showGameInstructions();
    
    // Done loading, hide the loading screen
    setTimeout(() => {
      const loadingScreen = document.getElementById('loading-screen');
      if (loadingScreen) {
        loadingScreen.style.display = 'none';
      }
    }, 500);
    
  } catch (error) {
    console.error('Error during initialization:', error);
    // Show a user-friendly error message
    const errorElement = document.createElement('div');
    errorElement.className = 'error-message';
    errorElement.textContent = 'Failed to initialize the game. Please try refreshing the page.';
    document.body.appendChild(errorElement);
  }
}

/**
 * The main animation loop.
 */
function animate(time) {
  requestAnimationFrame(animate);
  const deltaTime = (time - lastTime) / 1000;
  lastTime = time;

  // Update physics system
  if (physics) {
    physics.update(deltaTime);
  }

  // Update local player
  localPlayer.update(deltaTime);
  
  // Update remote players (animations, movement interpolation, etc.)
  multiplayerManager.update(deltaTime);
  
  // Update smoke ring effects
  for (let i = smokeRings.length - 1; i >= 0; i--) {
    // If the smoke ring is inactive after update, we can remove it
    // But keep at least 3 in the pool for reuse
    if (!smokeRings[i].update(deltaTime) && smokeRings.length > 3) {
      smokeRings[i].dispose();
      smokeRings.splice(i, 1);
    }
  }

  // Update bullets (both local & remote)
  for (let i = bullets.length - 1; i >= 0; i--) {
    const bullet = bullets[i];
    const result = bullet.update(deltaTime, null, scene, playersMap);
    if (!result.active) {
      // If bullet hit something or traveled too far
      if (result.hit && result.hit.type === 'player') {
        // Use logger for bullet hits
        if (window.logger) {
          window.logger.info(`Bullet hit player ${result.hit.playerId} in the ${result.hit.zone || 'body'} for ${result.hit.damage || 'unknown'} damage`);
        }
        
        // Set the last hit zone for server validation
        if (bullet.bulletId !== null && result.hit.zone) {
          bullet.setLastHitZone(result.hit.zone);
        }
        
        // CRITICAL: Notify server about the player hit
        if (bullet.sourcePlayerId === localPlayer.id) {
          // Only send hit events for bullets fired by the local player
          networkManager.sendPlayerHit(
            result.hit.playerId, // The ID of the player who was hit
            {
              position: {
                x: result.hit.position.x,
                y: result.hit.position.y,
                z: result.hit.position.z
              },
              zone: result.hit.zone || 'body',
              damage: result.hit.damage || 40
            },
            bullet.bulletId // Pass the bullet ID for server validation
          );
          
          if (window.logger) {
            window.logger.info(`Sent hit event to server: player ${result.hit.playerId} hit in ${result.hit.zone} by bullet ${bullet.bulletId}`);
          }
        }
      }
      scene.remove(bullet.mesh);
      bullets.splice(i, 1);
      
      // Anti-cheat: Remove from bullet map if it has an ID
      if (bullet.bulletId !== null) {
        bulletMap.delete(bullet.bulletId);
      }
    }
  }

  // Update FPS display
  updateFPS(renderer, camera, deltaTime);

  // Use the window.renderer camera
  let renderCamera;
  if (window.renderer && window.renderer.camera) {
    renderCamera = window.renderer.camera;
  } else {
    renderCamera = camera;
  }
  
  // Render with selected camera
  renderer.render(scene, renderCamera);
}

/**
 * Called whenever the local player fires.
 * Spawns a bullet locally and also notifies the server.
 * @param {THREE.Vector3} bulletStart 
 * @param {THREE.Vector3} shootDir 
 */
function handleLocalPlayerShoot(bulletStart, shootDir) {
  // Spawn bullet in our local game (client-side prediction)
  const bullet = spawnBullet(localPlayer.id, bulletStart, shootDir);
  
  // Create an array to track local bullet IDs if it doesn't exist
  if (!window.localPlayer.lastFiredBulletIds) {
    window.localPlayer.lastFiredBulletIds = [];
  }
  
  // Add this bullet's ID to our tracking array (if it has one)
  if (bullet && bullet.bulletId) {
    window.localPlayer.lastFiredBulletIds.push(bullet.bulletId);
    
    // Keep the array size manageable (only store last 20 bullet IDs)
    if (window.localPlayer.lastFiredBulletIds.length > 20) {
      window.localPlayer.lastFiredBulletIds.shift();
    }
  }

  // Send bullet data over network
  networkManager.sendShoot({
    position: {
      x: bulletStart.x,
      y: bulletStart.y,
      z: bulletStart.z
    },
    direction: {
      x: shootDir.x,
      y: shootDir.y,
      z: shootDir.z
    }
  });
  
  // Create smoke ring effect - only if not mobile
  if (!window.isMobile) {
    const availableSmokeRing = smokeRings.find(ring => !ring.active);
    if (availableSmokeRing) {
      // Get the effect positioning options from the viewmodel if available
      let smokeRingOptions = null;
      if (localPlayer.viewmodel && localPlayer.viewmodel.EFFECTS && localPlayer.viewmodel.EFFECTS.SMOKE_RING) {
        smokeRingOptions = localPlayer.viewmodel.EFFECTS.SMOKE_RING;
      }
      availableSmokeRing.create(bulletStart.clone(), shootDir.clone(), smokeRingOptions);
    }
  }
}

/**
 * Called whenever a remote player fires (based on network data).
 * @param {number} playerId 
 * @param {Object} bulletData 
 * @param {string|number} bulletId - Server-assigned bullet ID
 */
function handleRemotePlayerShoot(playerId, bulletData, bulletId) {
  // Check if this is a shotgun pellet from the metadata
  const isShotgunPellet = bulletData.isShotgunPellet || false;
  
  // Skip effect creation if this is our own shot coming back from the server
  if (playerId === localPlayer.id) {
    // Just create the bullet with the server's ID without spawning effects again
    const startPos = new THREE.Vector3(bulletData.position.x, bulletData.position.y, bulletData.position.z);
    const dir = new THREE.Vector3(bulletData.direction.x, bulletData.direction.y, bulletData.direction.z);
    
    const bullet = new Bullet(startPos, dir, bulletId, isShotgunPellet);
    
    // Track this bullet ID so we can identify it when impact comes back
    if (!window.localPlayer.lastFiredBulletIds) {
      window.localPlayer.lastFiredBulletIds = [];
    }
    window.localPlayer.lastFiredBulletIds.push(bulletId);
    
    // Keep the array size manageable
    if (window.localPlayer.lastFiredBulletIds.length > 20) {
      window.localPlayer.lastFiredBulletIds.shift();
    }
    
    // Add to bullets array but skip the sound and effects
    bullet.isLocalBullet = true;
    bullet.sourcePlayerId = playerId;
    bullets.push(bullet);
    bulletMap.set(bulletId, bullet);
    
    return;
  }
  
  // For other players' shots, spawn the bullet with full effects
  const startPos = new THREE.Vector3(bulletData.position.x, bulletData.position.y, bulletData.position.z);
  const dir = new THREE.Vector3(bulletData.direction.x, bulletData.direction.y, bulletData.direction.z);
  
  spawnBullet(playerId, startPos, dir, bulletId, isShotgunPellet);
}

/**
 * Handles a bullet impact notification from the server.
 * @param {string|number} bulletId - The bullet ID
 * @param {string} hitType - Type of impact (player, npc, ground, etc.)
 * @param {string|number|null} targetId - Target ID (for player hits)
 * @param {Object} position - Impact position {x, y, z}
 * @param {string} hitZone - Hit zone (head, body, limbs)
 */
function handleBulletImpact(bulletId, hitType, targetId, position, hitZone) {
  // Convert position to THREE.Vector3 if provided
  let impactPosition = null;
  if (position) {
    impactPosition = new THREE.Vector3(position.x, position.y, position.z);
  }
  
  // Find the bullet in our bullet map
  const bullet = bulletMap.get(bulletId);
  
  if (bullet) {
    // Store hit zone information for potential headshot sound
    if (hitZone) {
      bullet.setLastHitZone(hitZone);
    }
    
    // Create appropriate visual effect and deactivate bullet
    const result = bullet.handleServerImpact(hitType, targetId, impactPosition, scene);
    
    // Find and remove bullet from main array
    const bulletIndex = bullets.findIndex(b => b === bullet);
    if (bulletIndex !== -1) {
      scene.remove(bullet.mesh);
      bullets.splice(bulletIndex, 1);
    }
    
    // Remove from bullet map
    bulletMap.delete(bulletId);
  } else {
    // Use logger instead of console.log
    if (window.logger) {
      window.logger.debug(`Bullet ${bulletId} not found for impact event`);
    }
    
    // If we don't have the bullet object, still create visual effect at impact position
    if (impactPosition) {
      // Create a default direction vector (upward)
      const defaultDir = new THREE.Vector3(0, 1, 0);
      createImpactEffect(impactPosition, defaultDir, scene, hitType);
      
      // Only play headshot sound if it was a headshot from another player (not local)
      // Prevents double hitmarker sounds when a bullet is not found for a local hit
      const isFromLocalPlayer = (window.localPlayer && 
                              window.localPlayer.lastFiredBulletIds && 
                              window.localPlayer.lastFiredBulletIds.includes(bulletId));
      
      if (hitZone === 'head' && localPlayer && localPlayer.soundManager && !isFromLocalPlayer) {
        // For headshots, play both a spatialized and a direct sound for better feedback
        // Direct non-spatialized sound for clear feedback
        localPlayer.soundManager.playSound("headshotmarker", 100, 0.8);
        // Spatial sound for immersion
        localPlayer.soundManager.playSoundAt("headshotmarker", impactPosition, 100, 0.5, false);
      }
    }
  }
}

/**
 * Actually spawns a bullet in the world, complete with muzzle flash, etc.
 * @param {string|number} sourcePlayerId 
 * @param {THREE.Vector3} position 
 * @param {THREE.Vector3} direction 
 * @param {string|number} bulletId - Optional server-assigned ID (for remote bullets)
 * @param {boolean} isShotgunPellet - Whether this bullet is a shotgun pellet
 * @returns {Bullet} The created bullet object
 */
function spawnBullet(sourcePlayerId, position, direction, bulletId = null, isShotgunPellet = false) {
  // For local player, determine if this is a shotgun pellet based on their weapon
  const isLocalShotgunPellet = sourcePlayerId === localPlayer.id && localPlayer.activeWeapon === 'shotgun';
  
  // Use the provided flag or infer from local player weapon
  const isPellet = isShotgunPellet || isLocalShotgunPellet;
  
  const bullet = new Bullet(position, direction, bulletId, isPellet);
  bullet.setSourcePlayer(sourcePlayerId);
  
  // Make shotgun pellets smaller
  if (isPellet) {
    bullet.mesh.scale.set(0.5, 0.5, 0.5);
  }
  
  bullets.push(bullet);
  scene.add(bullet.mesh);
  
  // Anti-cheat: Store bullet in map if it has a bulletId
  if (bulletId !== null) {
    bulletMap.set(bulletId, bullet);
  }

  // Get the effect positioning options from the local player viewmodel if available
  let muzzleFlashOptions = null;
  let smokeEffectOptions = null;
  
  // Only use viewmodel options for the local player's effects
  if (sourcePlayerId === localPlayer.id && localPlayer.viewmodel && localPlayer.viewmodel.EFFECTS) {
    if (localPlayer.viewmodel.EFFECTS.MUZZLE_FLASH) {
      muzzleFlashOptions = localPlayer.viewmodel.EFFECTS.MUZZLE_FLASH;
    }
    if (localPlayer.viewmodel.EFFECTS.SMOKE_RING) {
      smokeEffectOptions = localPlayer.viewmodel.EFFECTS.SMOKE_RING;
    }
  }

  // For shotgun pellets after the first one, skip visual effects to avoid overwhelming 
  // the system with too many effects at once
  const showEffects = !isPellet || (isPellet && bullets.length % 3 === 0);
  
  // Visual effects - only for non-pellets or occasionally for pellets
  if (showEffects) {
    createMuzzleFlash(position, direction, scene, muzzleFlashOptions);
    createSmokeEffect(position, direction, scene);
    
    // Add smoke ring effect
    let smokeRing = null;
    
    // Try to reuse an inactive smoke ring first
    for (let i = 0; i < smokeRings.length; i++) {
      if (!smokeRings[i].active) {
        smokeRing = smokeRings[i];
        break;
      }
    }
    
    // If no inactive smoke ring found, create a new one if under the limit
    if (!smokeRing && smokeRings.length < maxSmokeRings) {
      smokeRing = new SmokeRingEffect(scene);
      smokeRings.push(smokeRing);
    }
    
    // Activate the smoke ring
    if (smokeRing) {
      smokeRing.create(position, direction, smokeEffectOptions);
    }
    
    // Sound effects - only play for non-pellets or the first pellet
    if (!isPellet || (isPellet && bullets.length <= 1)) {
      if (localPlayer.soundManager) {
        // Determine weapon type - try to get from source player or fallback to local player
        let weaponType = 'revolver'; // Default fallback
        
        // If it's the local player, use their active weapon
        if (sourcePlayerId === localPlayer.id) {
          weaponType = localPlayer.activeWeapon;
        } 
        // If it's a remote player, try to get their weapon type from the remote players map
        else if (remotePlayers && remotePlayers.has(sourcePlayerId)) {
          const remotePlayer = remotePlayers.get(sourcePlayerId);
          if (remotePlayer && remotePlayer.activeWeapon) {
            weaponType = remotePlayer.activeWeapon;
          }
        }
        
        // Use appropriate sound based on weapon type
        const soundName = weaponType === 'shotgun' ? "shotgunshot" : "shot";
        
        if (sourcePlayerId === localPlayer.id) {
          // Special handling for mobile to prevent audio duplication/sync issues
          if (window.isMobile) {
            // On mobile, use immediate playback with no delay and higher volume
            // This ensures only one clean sound plays
            localPlayer.soundManager.playSound(soundName, 0, 1.0);
          } else {
            // On desktop, play a non-spatialized gunshot for the local player
            localPlayer.soundManager.playSound(soundName, 50, 1.0);
          }
        } else if (!window.isMobile) {
          // For remote players on desktop, use full spatialized audio
          localPlayer.soundManager.playSoundAt(soundName, position, 50, 0.8);
        } else {
          // For remote players on mobile, use non-spatialized audio to prevent issues
          localPlayer.soundManager.playSound(soundName, 0, 0.8);
        }
      }
    }
  }
  
  // Return the bullet
  return bullet;
}

/**
 * Rebuilds a master map of all remote players.
 * This map is passed to bullet collision checks so bullets can hit any remote player.
 */
function updatePlayersMap() {
  playersMap.clear();
  // Only add remote players so that the local (shooter's) model isn't processed in bullet collisions.
  for (const [pid, remoteModel] of remotePlayers.entries()) {
    playersMap.set(pid, remoteModel);
  }
}

function showGameInstructions() {
  // Determine if on mobile or desktop
  const isMobile = window.isMobile || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  // Set dimensions based on device type
  const bannerWidth = isMobile ? '250px' : '1000px'; // Wider for desktop to accommodate two images
  const bannerHeight = isMobile ? '250px' : '500px';
  const startPosition = isMobile ? '-250px' : '-500px';
  
  // Create the instruction banner element
  const instructionBanner = document.createElement('div');
  instructionBanner.id = 'instruction-banner';
  instructionBanner.style.position = 'fixed';
  instructionBanner.style.left = '50%';
  instructionBanner.style.transform = 'translateX(-50%)';
  instructionBanner.style.width = bannerWidth;
  instructionBanner.style.height = bannerHeight;
  instructionBanner.style.zIndex = '2000';
  instructionBanner.style.transition = 'bottom 0.5s ease-out';
  instructionBanner.style.bottom = startPosition; // Start completely off-screen
  instructionBanner.style.display = 'flex'; // Use flex for side-by-side layout
  instructionBanner.style.justifyContent = 'center'; // Center the images
  
  if (isMobile) {
    // For mobile, just add the single mobile manual image
    const instructionImage = document.createElement('img');
    instructionImage.src = 'models/mobilemanual.png';
    instructionImage.style.width = '100%';
    instructionImage.style.height = '100%';
    instructionImage.style.objectFit = 'contain';
    instructionBanner.appendChild(instructionImage);
  } else {
    // For desktop, add both images side by side
    const desktopManualImage = document.createElement('img');
    desktopManualImage.src = 'models/desktopmanual.png';
    desktopManualImage.style.width = '50%';
    desktopManualImage.style.height = '100%';
    desktopManualImage.style.objectFit = 'contain';
    
    const trackpadManualImage = document.createElement('img');
    trackpadManualImage.src = 'models/trackpadmanual.png';
    trackpadManualImage.style.width = '50%';
    trackpadManualImage.style.height = '100%';
    trackpadManualImage.style.objectFit = 'contain';
    
    // Add both images to banner
    instructionBanner.appendChild(desktopManualImage);
    instructionBanner.appendChild(trackpadManualImage);
  }
  
  // Add banner to game container
  document.getElementById('game-container').appendChild(instructionBanner);
  
  // Animate the banner sliding in after a short delay
  setTimeout(() => {
    // Slide up to show the full image
    instructionBanner.style.bottom = '0px';
  }, 100);
  
  // Global function to remove instructions
  window.removeInstructions = () => {
    // Animate the banner sliding out
    instructionBanner.style.bottom = startPosition;
    
    // Remove from DOM after animation completes
    setTimeout(() => {
      if (instructionBanner.parentNode) {
        instructionBanner.parentNode.removeChild(instructionBanner);
      }
    }, 500);
  };
  
  // Add event listener to close banner on any click
  document.addEventListener('click', window.removeInstructions, {once: true});
  document.addEventListener('touchstart', window.removeInstructions, {once: true, passive: false});
}

/**
 * Updates debug visualization for all players.
 * Called when debug mode is toggled.
 */
function updateDebugVisualization() {
  // Local player visualization
  if (localPlayer && localPlayer.model) {
    if (typeof localPlayer.model.createHitZoneVisualizers === 'function') {
      localPlayer.model.createHitZoneVisualizers(window.debugMode);
    }
    
    // Clean up old helpers if debug mode is off
    if (!window.debugMode) {
      const helpers = ["headHelper", "bodyHelper", "leftLegHelper", "rightLegHelper"];
      
      helpers.forEach(helper => {
        if (localPlayer.model[helper]) {
          localPlayer.model.group.remove(localPlayer.model[helper]);
          localPlayer.model[helper] = null;
        }
      });
    }
  }
  
  // Remote players visualization
  if (remotePlayers && remotePlayers.size > 0) {
    remotePlayers.forEach((model, id) => {
      if (model && typeof model.createHitZoneVisualizers === 'function') {
        model.createHitZoneVisualizers(window.debugMode);
        
        // Clean up old helpers if debug mode is off
        if (!window.debugMode) {
          const helpers = ["headHelper", "bodyHelper", "leftLegHelper", "rightLegHelper"];
          
          helpers.forEach(helper => {
            if (model[helper]) {
              model.group.remove(model[helper]);
              model[helper] = null;
            }
          });
        }
      }
    });
  }
  
  // Also check the playersMap (which might contain additional players)
  if (window.playersMap) {
    window.playersMap.forEach((model, id) => {
      if (model && typeof model.createHitZoneVisualizers === 'function' &&
          !remotePlayers.has(id)) { // Only process if not already processed above
        model.createHitZoneVisualizers(window.debugMode);
        
        // Clean up old helpers if debug mode is off
        if (!window.debugMode) {
          const helpers = ["headHelper", "bodyHelper", "leftLegHelper", "rightLegHelper"];
          
          helpers.forEach(helper => {
            if (model[helper]) {
              model.group.remove(model[helper]);
              model[helper] = null;
            }
          });
        }
      }
    });
  }
  
  // Sync physics debug state
  if (physics) {
    physics.setDebugMode(window.debugMode);
  }
}

// Handle window unload to cleanup game mode resources
window.addEventListener('beforeunload', () => {
  if (physics) {
    physics.cleanup();
  }
  
  // Clean up smoke rings
  for (let i = 0; i < smokeRings.length; i++) {
    smokeRings[i].dispose();
  }
  smokeRings = [];
});

/**
 * Initializes the improved hitbox detection system.
 * This completely overwrites the old checkPlayerHitZones method in Bullet.prototype.
 */
function initImprovedHitboxSystem() {
  if (!window.Bullet || !window.Bullet.prototype) {
    console.error("Cannot install improved hitbox system - Bullet class not available");
    return false;
  }

  // Store a reference to the original method for backup
  const originalCheckPlayerHitZones = window.Bullet.prototype.checkPlayerHitZones;

  // Replace the checkPlayerHitZones method with our improved version
  window.Bullet.prototype.checkPlayerHitZones = function(playerObj, bulletPos) {
    // Better local player detection (handle both Player objects and models)
    if (playerObj === localPlayer) {
      if (localPlayer.model && typeof localPlayer.model.checkBulletHit === 'function') {
        return localPlayer.model.checkBulletHit(bulletPos);
      }
    }
    
    // For ThirdPersonModel players, use their built-in hit detection
    if (playerObj && typeof playerObj.checkBulletHit === 'function') {
      return playerObj.checkBulletHit(bulletPos);
    }
    
    // For remote players in the players map
    if (window.playersMap && playerObj.id) {
      const playerModel = window.playersMap.get(playerObj.id);
      if (playerModel && typeof playerModel.checkBulletHit === 'function') {
        return playerModel.checkBulletHit(bulletPos);
      }
    }
    
    // Local player might have a model reference
    if (playerObj.model && typeof playerObj.model.checkBulletHit === 'function') {
      return playerObj.model.checkBulletHit(bulletPos);
    }
    
    // Last resort: fall back to original implementation
    console.warn("Using fallback hit detection for player", playerObj);
    return originalCheckPlayerHitZones.call(this, playerObj, bulletPos);
  };

  // We also need to disable the old hitzone debug visualization
  // This will prevent the old hitboxes from appearing during gameplay
  window.Bullet.prototype.createHitZoneDebugBoxes = function() {
    // Do nothing - this effectively disables the old debug boxes
  };

  console.log("✅ Improved hitbox system successfully installed");
  return true;
}

/**
 * Setup viewport detection and handling, especially for iOS devices
 * where fullscreen is not available by default
 */
function setupViewportHandling() {
  // Store initial viewport dimensions
  updateViewportDimensions();
  
  // Listen for orientation changes and resize events
  window.addEventListener('orientationchange', () => {
    // Small delay to allow browser to complete orientation change
    setTimeout(updateViewportDimensions, 300);
  });
  
  window.addEventListener('resize', () => {
    updateViewportDimensions();
  });
  
  // Initial call to apply any needed viewport adjustments
  applyViewportAdjustments();
  
  // Add keyboard shortcut for toggling debug mode (Alt+D)
  window.addEventListener('keydown', (e) => {
    if (e.altKey && e.key === 'd') {
      window.debugMode = !window.debugMode;
      console.log(`Debug mode ${window.debugMode ? 'enabled' : 'disabled'}`);
      
      // When debug mode is enabled, show a small indicator
      let debugIndicator = document.getElementById('debug-indicator');
      if (window.debugMode) {
        if (!debugIndicator) {
          debugIndicator = document.createElement('div');
          debugIndicator.id = 'debug-indicator';
          debugIndicator.style.position = 'fixed';
          debugIndicator.style.top = '10px';
          debugIndicator.style.right = '10px';
          debugIndicator.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
          debugIndicator.style.color = 'white';
          debugIndicator.style.padding = '5px';
          debugIndicator.style.borderRadius = '3px';
          debugIndicator.style.fontSize = '12px';
          debugIndicator.style.zIndex = '1000';
          document.body.appendChild(debugIndicator);
        }
        debugIndicator.textContent = 'DEBUG MODE';
        debugIndicator.style.display = 'block';
      } else if (debugIndicator) {
        debugIndicator.style.display = 'none';
      }
    }
  });
}

/**
 * Update the viewport dimensions when orientation or size changes
 */
function updateViewportDimensions() {
  // Get current viewport and device dimensions
  const visualWidth = window.innerWidth;
  const visualHeight = window.innerHeight;
  const deviceWidth = window.screen.width;
  const deviceHeight = window.screen.height;
  
  // Store these values globally for access by other modules
  window.viewportInfo = {
    visualWidth,
    visualHeight,
    deviceWidth,
    deviceHeight,
    isLandscape: visualWidth > visualHeight,
    // Calculate ratio of visual height to full device height
    viewportRatio: visualHeight / deviceHeight
  };
  
  // Log information for iOS devices
  if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) {
    console.log(`Viewport updated - Visual: ${visualWidth}x${visualHeight}, Device: ${deviceWidth}x${deviceHeight}`);
    
    if (window.viewportInfo.viewportRatio < 1) {
      console.log(`Unused screen space detected. Viewport ratio: ${window.viewportInfo.viewportRatio.toFixed(2)}`);
    }
  }
  
  // Apply adjustments based on new dimensions
  applyViewportAdjustments();
}

/**
 * Apply necessary adjustments based on viewport dimensions
 */
function applyViewportAdjustments() {
  // If we have a renderer, update the camera aspect ratio
  if (window.renderer && window.renderer.camera) {
    window.renderer.camera.aspect = window.innerWidth / window.innerHeight;
    window.renderer.camera.updateProjectionMatrix();
  }
  
  // Resize renderer if available
  if (window.renderer && window.renderer.instance) {
    window.renderer.instance.setSize(window.innerWidth, window.innerHeight);
  }
}

/**
 * Creates weapon indicator UI for desktop
 */
function createDesktopWeaponIndicators() {
  if (isMobileDevice()) return; // Mobile has its own indicators
  
  // Add styles for weapon indicators
  const style = document.createElement('style');
  style.textContent = `
    .desktop-weapon-indicator {
      position: fixed;
      left: 20px;
      width: 40px;
      height: 40px;
      background-color: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-radius: 5px;
      margin-bottom: 5px;
      opacity: 0.7;
      transition: opacity 0.3s, border-color 0.3s, box-shadow 0.3s;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .desktop-weapon-indicator:hover {
      opacity: 1;
    }
    .desktop-weapon-indicator.active {
      border-color: #ffcc00 !important;
      box-shadow: 0 0 10px #ffcc00;
      opacity: 1;
    }
    #revolver-indicator-desktop {
      bottom: 150px;
    }
    #shotgun-indicator-desktop {
      bottom: 120px;
    }
    .weapon-number {
      position: absolute;
      top: -8px;
      right: -8px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 12px;
      padding: 2px 5px;
      border-radius: 10px;
      font-family: 'Courier New', monospace;
    }
  `;
  document.head.appendChild(style);
  
  // Create container for both indicators
  const container = document.createElement('div');
  container.id = 'desktop-weapon-indicators';
  
  // Create revolver indicator
  const revolverIndicator = document.createElement('div');
  revolverIndicator.id = 'revolver-indicator-desktop';
  revolverIndicator.className = 'desktop-weapon-indicator active';
  
  // Add revolver icon (same as mobile)
  const revolverImg = document.createElement('img');
  revolverImg.src = 'models/revolverindicator.png';
  revolverImg.style.width = '80%';
  revolverImg.style.height = '80%';
  revolverImg.style.objectFit = 'contain';
  revolverIndicator.appendChild(revolverImg);
  
  // Add number indicator
  const revolverNum = document.createElement('div');
  revolverNum.className = 'weapon-number';
  revolverNum.textContent = '1';
  revolverIndicator.appendChild(revolverNum);
  
  // Create shotgun indicator
  const shotgunIndicator = document.createElement('div');
  shotgunIndicator.id = 'shotgun-indicator-desktop';
  shotgunIndicator.className = 'desktop-weapon-indicator';
  
  // Add shotgun icon (same as mobile)
  const shotgunImg = document.createElement('img');
  shotgunImg.src = 'models/shotgunindicator.png';
  shotgunImg.style.width = '80%';
  shotgunImg.style.height = '80%';
  shotgunImg.style.objectFit = 'contain';
  shotgunIndicator.appendChild(shotgunImg);
  
  // Add number indicator
  const shotgunNum = document.createElement('div');
  shotgunNum.className = 'weapon-number';
  shotgunNum.textContent = '2';
  shotgunIndicator.appendChild(shotgunNum);
  
  // Add click handlers
  revolverIndicator.addEventListener('click', () => {
    if (window.localPlayer) {
      window.localPlayer.switchWeapon('revolver');
    }
  });
  
  shotgunIndicator.addEventListener('click', () => {
    if (window.localPlayer) {
      window.localPlayer.switchWeapon('shotgun');
    }
  });
  
  // Add to DOM
  document.body.appendChild(revolverIndicator);
  document.body.appendChild(shotgunIndicator);
}

// Call init() to start the application
init().catch(err => {
  console.error('Error during initialization:', err);
  // Show error to user
  const errorElement = document.createElement('div');
  errorElement.style.position = 'fixed';
  errorElement.style.top = '10px';
  errorElement.style.left = '10px';
  errorElement.style.color = 'red';
  errorElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
  errorElement.style.padding = '10px';
  errorElement.style.borderRadius = '5px';
  errorElement.textContent = 'Failed to initialize the game. Please refresh the page.';
  document.body.appendChild(errorElement);
});

================================================
File: /public/js/multiplayerManager.js
================================================
import { ThirdPersonModel } from './playerModel.js';
import { networkManager } from './network.js';
import { updateHealthUI, showDamageIndicator } from './ui.js';

/**
 * Manages all remote players (their models, animations, etc.) but NOT bullets.
 * Bullets are now handled in main.js.
 */
export class MultiplayerManager {
  constructor(scene, soundManager, remotePlayersMap) {
    /**
     * @param remotePlayersMap {Map<number,ThirdPersonModel>}
     * A shared map that main.js also references. We'll update it here.
     */
    this.scene = scene;
    this.soundManager = soundManager;
    
    // This map is passed in from main.js; we mutate it
    this.remotePlayers = remotePlayersMap;

    // Map to track username labels
    this.playerLabels = new Map(); // playerId -> { sprite, div }
    
    // Initialize nametag visibility - visible by default
    this._nametagsVisible = true;
    
    // Create a container for the username labels
    this.createLabelContainer();

    // Callback that main.js uses to know we changed remotePlayers
    this.onRemotePlayersUpdated = null;

    this.localPlayerId = null;

    // Initialize network handlers
    this.initNetwork();
  }
  
  /**
   * Creates the container for player username labels
   */
  createLabelContainer() {
    // Check if container already exists
    let container = document.getElementById('player-labels-container');
    
    if (!container) {
      // Create a new container
      container = document.createElement('div');
      container.id = 'player-labels-container';
      container.style.position = 'absolute';
      container.style.top = '0';
      container.style.left = '0';
      container.style.width = '100%';
      container.style.height = '100%';
      container.style.pointerEvents = 'none';
      container.style.overflow = 'hidden';
      container.style.zIndex = '10';
      
      // Add to the game container
      const gameContainer = document.getElementById('game-container');
      if (gameContainer) {
        gameContainer.appendChild(container);
      } else {
        document.body.appendChild(container);
      }
    }
    
    // Store the reference to the container
    this.labelContainer = container;
  }
  
  initNetwork() {
    // When we get the "init" message, set local player ID and add any existing players
    networkManager.onInit = (initData) => {
      this.localPlayerId = initData.id;
      console.log(`Local player initialized with ID: ${this.localPlayerId}`);

      // Remove any existing duplicate of the local player (safety check)
      this.removeLocalPlayerDuplicates();

      // Add all existing players (these are remote from our POV)
      if (initData.players && Array.isArray(initData.players)) {
        initData.players.forEach(playerData => {
          this.addPlayer(playerData.id, playerData);
        });
        this.notifyPlayersUpdated();
      }
      
      // Request train state explicitly after a short delay to ensure it's received
      setTimeout(() => {
        if (networkManager && typeof networkManager.requestTrainState === 'function') {
          console.log("Requesting train state from server after initialization");
          networkManager.requestTrainState();
        }
      }, 1000);
    };

    networkManager.onPlayerJoined = (playerData) => {
      if (playerData && playerData.id !== this.localPlayerId) {
        console.log(`Player joined: ${playerData.id}`);
        this.addPlayer(playerData.id, playerData);
        this.notifyPlayersUpdated();
      }
    };

    networkManager.onPlayerLeft = (playerId) => {
      console.log(`Player left: ${playerId}`);
      this.removePlayer(playerId);
      this.notifyPlayersUpdated();
    };

    // Add handler for player death events
    networkManager.onPlayerDeath = (playerId, killedById) => {
      console.log(`Player ${playerId} was killed by player ${killedById}`);
      
      // Find the player model and play death animation
      const playerModel = this.remotePlayers.get(playerId);
      if (playerModel && typeof playerModel.playDeathAnimation === 'function') {
        console.log(`Playing death animation for player ${playerId}`);
        playerModel.playDeathAnimation();
      }
    };

    networkManager.onPlayerUpdate = (playerId, updatedData) => {
      if (playerId === this.localPlayerId) return; // skip ourself
      
      const playerModel = this.remotePlayers.get(playerId);
      
      // Check if this is a full reset request
      if (updatedData && updatedData.fullReset === true) {
        console.log(`[MultiplayerManager] Received full reset for player ${playerId}`);
        
        // If we have this player model, remove it completely
        if (playerModel) {
          playerModel.dispose();
          this.remotePlayers.delete(playerId);
          
          // Remove username label
          this.removePlayerLabel(playerId);
        }
        
        // Create a fresh player model
        this.addPlayer(playerId, updatedData);
        this.notifyPlayersUpdated();
        return;
      }
      
      // Check if player is dying and should play death animation
      if (updatedData && updatedData.isDying === true && playerModel && playerModel.playDeathAnimation && !playerModel.isDying) {
        console.log(`[MultiplayerManager] Playing death animation for remote player ${playerId}`);
        playerModel.playDeathAnimation();
        return; // Skip normal update as death animation takes precedence
      }
      
      // Check if player animation state should be reset (after respawn)
      if (updatedData && updatedData.resetAnimationState === true && playerModel && typeof playerModel.resetAnimationState === 'function') {
        console.log(`[MultiplayerManager] Resetting animation state for player ${playerId}`);
        playerModel.resetAnimationState();
        // Continue with normal update
      }
      
      // Normal update
      if (playerModel) {
        playerModel.update(updatedData);
      } else if (updatedData) {
        // If we don't have this model yet, create it
        this.addPlayer(playerId, updatedData);
      }
    };

    // Anti-cheat: Player got hit (local player) - server validated
    networkManager.onPlayerHit = (sourceId, hitData, newHealth, hitZone) => {
      console.log(`I was hit by player ${sourceId} in the ${hitZone || 'body'}!`);
      
      // This is a regular hit
      this.showHitFeedback();
      
      // Play headshot sound if appropriate
      if (hitZone === 'head' && this.soundManager) {
        this.soundManager.playSound("headshotmarker", 100);
      }
      
      // Reduce local player's health (using value from server)
      if (window.localPlayer) {
        // Calculate damage based on the health difference or hit zone
        let damage = 20; // Default damage
        
        // Check if hitData contains a damage value directly
        if (hitData && typeof hitData.damage === 'number') {
          damage = hitData.damage;
        } else if (newHealth !== undefined) {
          // Calculate damage from previous health
          damage = window.localPlayer.health - newHealth;
          window.localPlayer.health = newHealth;
        } else {
          // Calculate damage based on hit zone if provided
          if (hitZone === 'head') {
            damage = 100;
          } else if (hitZone === 'body') {
            damage = 40;
          } else if (hitZone === 'limbs') {
            damage = 20;
          }
          
          // Apply damage
          window.localPlayer.takeDamage(damage, hitZone);
        }
        
        // Make sure damage is a number
        damage = Number(damage) || 40; // Default to 40 if conversion fails
        
        // Show damage indicator with proper hit zone
        if (typeof showDamageIndicator === 'function') {
          console.log(`Showing damage indicator: ${damage} damage to ${hitZone}`);
          showDamageIndicator(damage, hitZone);
        }
        
        // Ensure health UI is updated
        if (typeof updateHealthUI === 'function') {
          updateHealthUI(window.localPlayer);
        }
      }
    };

    // Anti-cheat: Broadcast that some player was hit (server validated)
    networkManager.onPlayerHitBroadcast = (hitData) => {
      // Make sure we have valid data
      if (!hitData || !hitData.targetId) {
        console.warn("Invalid hit broadcast data received");
        return;
      }
      
      const targetId = hitData.targetId;
      const sourceId = hitData.sourceId;
      const hitPos = hitData.position;
      const newHealth = hitData.health;
      const hitZone = hitData.zone || 'body';
      
      console.log(`Player ${targetId} was hit by ${sourceId} in the ${hitZone}`);
      
      // Convert targetId to integer if it's a string
      const playerId = typeof targetId === 'string' ? parseInt(targetId, 10) : targetId;
      const tPlayer = this.remotePlayers.get(playerId);
      
      if (tPlayer) {
        tPlayer.showHitFeedback();
        
        // Play headshot sound if appropriate
        if (hitZone === 'head' && this.soundManager) {
          this.soundManager.playSound("headshotmarker", 100);
        }
        
        // Calculate damage based on hit zone
        let damage = 20; // Default damage
        if (hitZone === 'head') {
          damage = 100;
        } else if (hitZone === 'body') {
          damage = 40;
        } else if (hitZone === 'limbs') {
          damage = 20;
        }
        
        // Update health directly from server value if provided
        if (newHealth !== undefined) {
          tPlayer.health = newHealth;
        } else {
          // Apply damage
          if (typeof tPlayer.takeDamage === 'function') {
            tPlayer.takeDamage(damage, hitZone);
          } else {
            // If takeDamage is not defined, manually update health
            tPlayer.health = Math.max((tPlayer.health || 100) - damage, 0);
          }
        }
        
        // Create a hit marker or effect at the hit position if available
        if (hitPos && window.scene) {
          this.createHitMarker(hitPos, hitZone);
        }
      }
    };
  }

  showHitFeedback() {
    // Flash the screen red briefly
    const hitOverlay = document.createElement('div');
    hitOverlay.style.position = 'absolute';
    hitOverlay.style.top = '0';
    hitOverlay.style.left = '0';
    hitOverlay.style.width = '100%';
    hitOverlay.style.height = '100%';
    hitOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
    hitOverlay.style.pointerEvents = 'none';
    hitOverlay.style.transition = 'opacity 0.5s ease-out';
    hitOverlay.style.zIndex = '1000';
    document.body.appendChild(hitOverlay);
    
    setTimeout(() => {
      hitOverlay.style.opacity = '0';
      setTimeout(() => {
        if (hitOverlay.parentNode) {
          hitOverlay.parentNode.removeChild(hitOverlay);
        }
      }, 500);
    }, 100);

    // Optional hit sound
    if (this.soundManager) {
      this.soundManager.playSound("revolverdraw");
    }
  }

  /**
   * Creates a visual hit marker at the hit position
   * @param {Object} position - The hit position
   * @param {string} hitZone - The hit zone ('head', 'body', 'limbs')
   */
  createHitMarker(position, hitZone) {
    // Only create if we have THREE.js and a scene
    if (!window.THREE || !window.scene) return;
    
    // Choose color based on hit zone
    let color = 0xFFFFFF; // Default white
    if (hitZone === 'head') {
      color = 0xFF0000; // Red for headshots
    } else if (hitZone === 'body') {
      color = 0xFF6600; // Orange for body shots
    } else if (hitZone === 'limbs') {
      color = 0xFFFF00; // Yellow for limb shots
    }
    
    try {
      // Create a particle system for the hit marker
      const geometry = new window.THREE.BufferGeometry();
      const vertices = [];
      
      // Create particles in a small sphere
      const particleCount = 10;
      const radius = 0.1;
      
      for (let i = 0; i < particleCount; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.sin(phi) * Math.sin(theta);
        const z = radius * Math.cos(phi);
        
        vertices.push(x, y, z);
      }
      
      geometry.setAttribute('position', new window.THREE.Float32BufferAttribute(vertices, 3));
      
      const material = new window.THREE.PointsMaterial({
        color: color,
        size: 0.05,
        transparent: true,
        opacity: 1
      });
      
      const particles = new window.THREE.Points(geometry, material);
      particles.position.copy(position);
      window.scene.add(particles);
      
      // Animate the particles
      const startTime = performance.now();
      const duration = 500; // ms
      
      function animateParticles() {
        const elapsed = performance.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress < 1) {
          // Expand particles
          particles.scale.set(1 + progress * 2, 1 + progress * 2, 1 + progress * 2);
          // Fade out
          material.opacity = 1 - progress;
          
          requestAnimationFrame(animateParticles);
        } else {
          // Clean up
          window.scene.remove(particles);
          geometry.dispose();
          material.dispose();
        }
      }
      
      requestAnimationFrame(animateParticles);
    } catch (error) {
      console.error("Error creating hit marker:", error);
    }
  }

  /**
   * Adds a remote player to the scene with proper model
   * @param {number} playerId - ID of the player to add
   * @param {Object} initialData - Initial player data from server
   */
  addPlayer(playerId, initialData = {}) {
    // Skip if we already have this player
    if (this.remotePlayers.has(playerId)) return;
    
    // Skip if this is the local player ID (safety check to prevent ghost duplicates)
    if (playerId === this.localPlayerId) {
      console.log(`MultiplayerManager: Skipping attempt to add local player (ID: ${playerId}) as remote player`);
      return null;
    }
    
    console.log(`Adding remote player ${playerId} to scene`);
    
    // Create standard player model
    const playerModel = new ThirdPersonModel(this.scene, playerId);
    
    // Add to tracking map - used by main.js for bullet hit detection
    this.remotePlayers.set(playerId, playerModel);
    
    // Set initial position if provided
    if (initialData.position) {
      playerModel.targetPosition.set(
        initialData.position.x, 
        initialData.position.y, 
        initialData.position.z
      );
      playerModel.group.position.copy(playerModel.targetPosition);
    }
    
    // Set initial rotation if provided
    if (initialData.rotation && initialData.rotation.y !== undefined) {
      playerModel.targetRotation = initialData.rotation.y;
      playerModel.group.rotation.y = initialData.rotation.y;
    }
    
    // Apply skin information if provided
    if (initialData.skins) {
      console.log(`Applying initial skin data for player ${playerId}:`, initialData.skins);
      
      // Update skin permissions
      playerModel.updateSkinPermissions(initialData.skins);
      
      // Apply banana skin if permission is granted
      if (initialData.skins.bananaSkin) {
        console.log(`Player ${playerId} has bananaSkin permission, applying skin on initial join`);
        
        // Ensure the model is loaded first
        if (!playerModel.playerModel) {
          console.log(`Waiting for player model to load before applying skin for player ${playerId}`);
          // Add a delay to wait for model to load
          setTimeout(() => {
            if (playerModel.playerModel) {
              playerModel.updateSkin('bananaSkin');
              // Mark as initially applied to prevent duplicate application
              playerModel._initialSkinApplied = true;
              // Store the skin data to prevent redundant updates
              playerModel._lastSkinUpdate = JSON.stringify(initialData.skins);
            } else {
              console.warn(`Player model still not loaded for player ${playerId} after delay`);
            }
          }, 1500); // Longer delay to ensure model loads
        } else {
          playerModel.updateSkin('bananaSkin');
          // Mark as initially applied to prevent duplicate application
          playerModel._initialSkinApplied = true;
          // Store the skin data to prevent redundant updates
          playerModel._lastSkinUpdate = JSON.stringify(initialData.skins);
        }
      }
    }
    
    // Create username label
    this.createPlayerLabel(playerId, initialData.username || `Player_${playerId}`, false);
    
    return playerModel;
  }

  /**
   * Creates a floating username label for a player
   * @param {number} playerId - ID of the player
   * @param {string} username - Username to display
   * @param {boolean} isAiControlled - Whether this is a bot or NPC
   */
  createPlayerLabel(playerId, username, isAiControlled = false) {
    // Remove any existing label first
    this.removePlayerLabel(playerId);
    
    // Create label container
    const div = document.createElement('div');
    div.className = 'player-label';
    
    // Style the label
    div.style.position = 'absolute';
    div.style.color = 'white';
    div.style.fontFamily = 'Arial, sans-serif';
    div.style.fontSize = '14px';
    div.style.fontWeight = 'bold';
    div.style.textShadow = '1px 1px 2px black';
    div.style.padding = '3px 6px';
    div.style.borderRadius = '4px';
    div.style.pointerEvents = 'none';
    div.style.userSelect = 'none';
    div.style.zIndex = '10';
    
    // Regular styling for players
    div.style.backgroundColor = 'rgba(0, 0, 0, 0.5)'; // Regular background for players
    div.textContent = username;
    
    // Add to DOM
    this.labelContainer.appendChild(div);
    
    // Create THREE.js object to position the label in 3D space
    const labelObject = new THREE.Object3D();
    labelObject.position.y = 2.8; // Increased position above player head (was 2.5)
    
    // Store references for updating
    this.playerLabels.set(playerId, { div, labelObject });
    
    // If we have this player model, add the label object to it
    const model = this.remotePlayers.get(playerId);
    if (model && model.group) {
      model.group.add(labelObject);
    }
  }

  removePlayer(playerId) {
    const playerModel = this.remotePlayers.get(playerId);
    if (playerModel) {
      playerModel.dispose();
      this.remotePlayers.delete(playerId);
    }
    
    // Remove username label
    this.removePlayerLabel(playerId);
  }
  
  removePlayerLabel(playerId) {
    const labelData = this.playerLabels.get(playerId);
    if (labelData) {
      // Remove the div from DOM
      if (labelData.div && labelData.div.parentNode) {
        labelData.div.parentNode.removeChild(labelData.div);
      }
      
      // Remove the 3D object from the player model
      const model = this.remotePlayers.get(playerId);
      if (model && model.group && labelData.labelObject) {
        model.group.remove(labelData.labelObject);
      }
      
      // Remove from tracking
      this.playerLabels.delete(playerId);
    }
  }

  update(deltaTime) {
    // Update player models
    for (const [id, playerModel] of this.remotePlayers.entries()) {
      if (playerModel) {
        // Always call animateMovement which handles the snapshot-based animations too
        if (playerModel.animateMovement) {
          playerModel.animateMovement(deltaTime);
        }
        
        // Also call the general update method if it exists
        if (playerModel.update) {
          // DON'T pass deltaTime to update when the player is in a frozen aim pose
          // This prevents animation mixer from resetting the animation each frame
          if (playerModel.isAiming && !playerModel.isShooting && !playerModel.isJumping) {
            // Skip sending deltaTime update which would reset the animation
          } else {
            playerModel.update(deltaTime);
          }
        }
      }
    }
    
    // Update player labels
    this.updatePlayerLabels();
  }
  
  /**
   * Control visibility of ALL player nametags
   * @param {boolean} visible - Whether nametags should be visible
   */
  setAllNametagsVisible(visible) {
    console.log(`[MultiplayerManager] Setting all nametags visible: ${visible}`);
    
    this.playerLabels.forEach((labelData, playerId) => {
      if (labelData && labelData.div) {
        labelData.div.style.display = visible ? 'block' : 'none';
      }
    });
    
    // Store current global visibility setting
    this._nametagsVisible = visible;
  }
  
  updatePlayerLabels() {
    const tempVector = new THREE.Vector3();
    const canvas = document.querySelector('canvas');
    
    if (!canvas) return;
    
    // Get camera for projection
    const camera = window.renderer && window.renderer.camera ? 
                  window.renderer.camera : 
                  this.scene.getObjectByProperty('type', 'PerspectiveCamera');
    
    if (!camera) return;
    
    // If nametags are globally hidden, skip the update
    if (this._nametagsVisible === false) {
      return;
    }
    
    this.playerLabels.forEach((labelData, playerId) => {
      const { div, labelObject } = labelData;
      if (!div) return;
      
      const model = this.remotePlayers.get(playerId);
      if (!model || !model.group) return;
      
      // Get world position
      tempVector.setFromMatrixPosition(labelObject.matrixWorld);
      
      // Project to 2D screen coordinates
      tempVector.project(camera);
      
      // Convert to CSS coordinates
      const x = (tempVector.x * 0.5 + 0.5) * canvas.clientWidth;
      const y = (-(tempVector.y * 0.5) + 0.5) * canvas.clientHeight;
      
      // Check if label is in front of the camera
      if (tempVector.z > 1) {
        div.style.display = 'none';
      } else {
        div.style.display = 'block';
        div.style.transform = `translate(-50%, -50%)`;
        div.style.left = `${x}px`;
        div.style.top = `${y}px`;
      }
    });
  }

  notifyPlayersUpdated() {
    if (typeof this.onRemotePlayersUpdated === 'function') {
      this.onRemotePlayersUpdated(this.remotePlayers);
    }
  }

  /**
   * Removes any existing player models with the same ID as the local player
   * This prevents the "ghost player" issue where a player sees their own model
   */
  removeLocalPlayerDuplicates() {
    if (!this.localPlayerId) return;
    
    // Check if there's a model with our ID in the remote players map
    if (this.remotePlayers.has(this.localPlayerId)) {
      console.log(`Removing duplicate local player model with ID: ${this.localPlayerId}`);
      
      // Get the model
      const duplicateModel = this.remotePlayers.get(this.localPlayerId);
      
      // Dispose of the model properly
      if (duplicateModel) {
        duplicateModel.dispose();
      }
      
      // Remove from the map
      this.remotePlayers.delete(this.localPlayerId);
      
      // Remove username label
      this.removePlayerLabel(this.localPlayerId);
      
      // Notify that remote players have changed
      this.notifyPlayersUpdated();
    }
  }
}

================================================
File: /public/js/network.js
================================================
/**
 * NetworkManager class for WebSocket communication.
 * It provides event callbacks for multiplayer events and methods to send data.
 */
export class NetworkManager {
  constructor() {
    this.socket = null;
    this.playerId = null;
    this.otherPlayers = new Map(); // Maps playerId -> playerData from the server

    // Callbacks
    this.onInit = null;              // Called when we first receive 'init' from server
    this.onPlayerJoined = null;
    this.onPlayerLeft = null;
    this.onPlayerUpdate = null;
    this.onPlayerShoot = null;
    this.onPlayerCount = null;
    this.onPlayerHit = null;         // When this player is hit by someone
    this.onPlayerHitBroadcast = null;// When any player is hit
    this.onOpen = null;
    this.onClose = null;
    this.onError = null;
    this.onChatMessage = null;       // When a chat message is received

    // Train system callbacks
    this.onTrainInit = null;         // When initial train state is received
    this.onTrainState = null;        // When train state updates are received

    // Anti-cheat callbacks
    this.onPositionCorrection = null;// When server corrects client position
    this.onBulletImpact = null;      // When a bullet hits something
    this.onRespawn = null;           // When player respawns

    // Automatic reconnect attempts
    this.connectionAttempts = 0;
    this.maxConnectionAttempts = 5;
    this.reconnectTimer = null;

    // Unique sessionId to prevent multiple tabs from colliding
    this.sessionId = this._generateSessionId();
    
    // Anti-cheat: Sequence number for message ordering
    this.sequenceNumber = 0;
    
    // Anti-cheat: Map to track outgoing messages that need nonces
    this.pendingMessages = new Map();
  }

  /**
   * Generates a unique-ish session ID to detect duplicate connections from the same tab.
   */
  _generateSessionId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2);
  }
  
  /**
   * Generates a unique nonce for secure actions.
   * @returns {string} A unique nonce
   */
  _generateNonce() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2) + 
           Math.random().toString(36).substring(2);
  }

  /**
   * Initiates a connection to the WebSocket server.
   */
  connect() {
    this._cleanupSocket();

    // Get persistent player identity information
    const playerIdentity = window.playerIdentity || {};
    
    // Create query parameters for the WebSocket connection
    const params = new URLSearchParams({
      sessionId: this.sessionId,
      clientId: playerIdentity.id || '',
      username: playerIdentity.username || '',
      token: playerIdentity.token || '' // Add token for auth
    });

    // Determine correct ws:// or wss:// based on current protocol
    const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
    const wsUrl = `${protocol}${window.location.host}?${params.toString()}`;

    console.log('Attempting to connect to:', wsUrl);
    this.socket = new WebSocket(wsUrl);

    this.socket.onopen = (event) => {
      console.log('WebSocket connected');
      this.connectionAttempts = 0;
      if (typeof this.onOpen === 'function') {
        this.onOpen(event);
      }
    };

    this.socket.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        
        // Handle auth failures specifically
        if (message.type === 'authFailure') {
          console.error('Authentication failed:', message.reason);
          // If the server rejected our token, clear it and reload
          if (message.reason === 'invalidToken') {
            try {
              localStorage.removeItem('wildWestPlayerIdentity');
              sessionStorage.removeItem('wildWestPlayerSession');
              alert('Your session has expired. The game will reload.');
              window.location.reload();
            } catch (e) {
              console.error('Failed to clear invalid token:', e);
            }
          }
          return;
        }
        
        this.handleMessage(message);
      } catch (err) {
        console.error('Error parsing server message:', err);
      }
    };

    this.socket.onclose = (event) => {
      console.log(`WebSocket closed: ${event.code} ${event.reason}`);
      if (typeof this.onClose === 'function') {
        this.onClose(event);
      }
      this._scheduleReconnect();
    };

    this.socket.onerror = (error) => {
      console.error('WebSocket error:', error);
      if (typeof this.onError === 'function') {
        this.onError(error);
      }
    };
  }

  /**
   * Clean up any existing WebSocket connection.
   */
  _cleanupSocket() {
    if (this.socket) {
      this.socket.onopen = null;
      this.socket.onmessage = null;
      this.socket.onclose = null;
      this.socket.onerror = null;
      if (
        this.socket.readyState === WebSocket.OPEN ||
        this.socket.readyState === WebSocket.CONNECTING
      ) {
        this.socket.close();
      }
      this.socket = null;
    }

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }

  /**
   * Schedules a reconnect attempt if under max attempts.
   */
  _scheduleReconnect() {
    if (this.connectionAttempts < this.maxConnectionAttempts) {
      this.connectionAttempts++;
      const delay = Math.min(1000 * Math.pow(2, this.connectionAttempts), 30000);
      console.log(`Reconnecting in ${(delay / 1000).toFixed(1)}s... (Attempt ${this.connectionAttempts}/${this.maxConnectionAttempts})`);
      
      this.reconnectTimer = setTimeout(() => {
        console.log(`Reconnecting now (Attempt ${this.connectionAttempts})...`);
        this.connect();
      }, delay);
    } else {
      console.error('Max reconnect attempts reached. Please refresh the page.');
    }
  }

  /**
   * Handles all messages from the server.
   * @param {Object} message The parsed JSON message object.
   */
  handleMessage(message) {
    switch (message.type) {
      // New connection initialization
      case 'init':
        this.playerId = message.id;
        console.log(`Assigned player ID: ${this.playerId}`);

        // If there's a callback
        if (typeof this.onInit === 'function') {
          this.onInit(message);
        }

        // Add known players - exclude any with our own ID
        message.players.forEach(player => {
          // Skip if this is somehow our own ID
          if (player.id === this.playerId) {
            console.log(`Skipping duplicate player with our ID: ${player.id}`);
            return;
          }
          
          if (this.onPlayerJoined) {
            this.onPlayerJoined(player);
          }
          this.otherPlayers.set(player.id, player);
        });
        break;

      // Another player joined
      case 'playerJoined':
        console.log(`Player ${message.id} joined`);
        
        // Skip if this is our own ID
        if (message.id === this.playerId) {
          console.log(`Skipping player join for own player ID: ${message.id}`);
          break;
        }
        
        if (this.onPlayerJoined) {
          this.onPlayerJoined(message);
        }
        this.otherPlayers.set(message.id, {
          id: message.id,
          position: message.position,
          rotation: message.rotation,
          isAiming: false,
          isShooting: false,
          isReloading: false,
          username: message.username || `Player_${message.id}`,
          skins: message.skins || { bananaSkin: false } // Include skin information
        });
        break;

      // Player left
      case 'playerLeft':
        console.log(`Player ${message.id} left`);
        if (this.onPlayerLeft) {
          this.onPlayerLeft(message.id);
        }
        this.otherPlayers.delete(message.id);
        break;

      // General player update (pos/rot/aiming/etc.)
      case 'playerUpdate':
        {
          // Skip if this is our own ID
          if (message.id === this.playerId) {
            console.log(`Skipping update for own player ID: ${message.id}`);
            break;
          }

          const existing = this.otherPlayers.get(message.id);
          if (existing) {
            existing.position = message.position || existing.position;
            existing.rotation = message.rotation || existing.rotation;
            existing.isAiming =
              message.isAiming !== undefined ? message.isAiming : existing.isAiming;
            existing.isShooting =
              message.isShooting !== undefined ? message.isShooting : existing.isShooting;
            existing.isReloading =
              message.isReloading !== undefined ? message.isReloading : existing.isReloading;
            existing.health =
              message.health !== undefined ? message.health : existing.health;
            existing.isDying =
              message.isDying !== undefined ? message.isDying : existing.isDying;
            existing.isWalking =
              message.isWalking !== undefined ? message.isWalking : existing.isWalking;
            
            // Always maintain skin state for syncing to new clients
            if (message.skins) {
              existing.skins = message.skins;
            }
          } else {
            // If this is a new player we hadn't seen before - skip if it's our own ID
            if (message.id !== this.playerId) {
              this.otherPlayers.set(message.id, {
                id: message.id,
                position: message.position || { x: 0, y: 0, z: 0 },
                rotation: message.rotation || { y: 0 },
                isAiming: message.isAiming || false,
                isShooting: message.isShooting || false,
                isReloading: message.isReloading || false, 
                health: message.health || 100,
                isDying: message.isDying || false,
                isWalking: message.isWalking || false,
                username: message.username || `Player_${message.id}`,
                skins: message.skins || { bananaSkin: false } // Include skin information
              });
              
              // Notify about this newly discovered player
              if (this.onPlayerJoined) {
                this.onPlayerJoined(this.otherPlayers.get(message.id));
              }
            }
          }
          
          // Call onPlayerUpdate with the updated or new player data
          if (this.onPlayerUpdate && message.id !== this.playerId) {
            this.onPlayerUpdate(message.id, existing || this.otherPlayers.get(message.id));
          }
        }
        break;

      // Remote player fired
      case 'playerShoot':
        if (this.onPlayerShoot) {
          this.onPlayerShoot(message.id, message.bulletData, message.bulletId);
        }
        break;

      // Current total player count
      case 'playerCount':
        if (this.onPlayerCount) {
          this.onPlayerCount(message.count);
        }
        break;

      // This client was hit by another player
      case 'hit':
        console.log(`I was hit by player ${message.sourceId} in the ${message.hitZone || 'body'} for ${message.hitData?.damage || 20} damage`);
        
        // Add damage to hitData if it's missing
        let damage = 40; // Default body shot damage
        if (message.hitZone === 'head') {
          damage = 100;
        } else if (message.hitZone === 'limbs') {
          damage = 20;
        }
        
        // If hitData is missing, create it
        if (!message.hitData) {
          message.hitData = {
            damage: damage,
            hitZone: message.hitZone || 'body'
          };
        }
        
        // Ensure damage property exists in hitData
        if (message.hitData && !message.hitData.damage) {
          message.hitData.damage = damage;
        }
        
        if (this.onPlayerHit) {
          this.onPlayerHit(message.sourceId, message.hitData, message.health, message.hitZone);
        }
        break;

      // Player hit - broadcast to all players
      case 'playerHitBroadcast':
        if (this.onPlayerHitBroadcast) {
          this.onPlayerHitBroadcast(message.hitData);
        }
        break;
        
      // Anti-cheat: Server correction of client position
      case 'positionCorrection':
        console.log(`Received position correction:`, message.position);
        if (this.onPositionCorrection) {
          this.onPositionCorrection(message.position);
        }
        break;
        
      // Anti-cheat: Bullet impact notification
      case 'bulletImpact':
        if (this.onBulletImpact) {
          this.onBulletImpact(
            message.bulletId, 
            message.hitType, 
            message.targetId, 
            message.position,
            message.hitZone
          );
        }
        break;
        
      // Anti-cheat: Player respawn notification
      case 'respawn':
        console.log(`Respawning at:`, message.position);
        if (this.onRespawn) {
          this.onRespawn(
            message.position, 
            message.health, 
            message.bullets, 
            message.maxBullets, 
            message.activeWeapon
          );
        }
        break;

      // Player death notification - when this player is killed
      case 'death':
        console.log(`You were killed by player ${message.killerId}`);
        if (this.onDeath) {
          this.onDeath(message.killerId);
        }
        break;
        
      // Kill notification - when this player kills another player
      case 'kill':
        console.log(`You killed player ${message.targetId}`);
        if (this.onKill) {
          this.onKill(message.targetId);
        }
        break;
        
      // Player death notification - for other players in the game
      case 'playerDeath':
        console.log(`Player ${message.id} was killed by player ${message.killedById}`);
        if (this.onPlayerDeath) {
          this.onPlayerDeath(message.id, message.killedById);
        }
        break;

      // Generic error from server
      case 'error':
        console.error('Server error:', message.message);
        if (message.fatal) {
          this.connectionAttempts = this.maxConnectionAttempts; // block further reconnect
          alert(`Fatal error: ${message.message}`);
        }
        break;

      // Chat message received
      case 'chatMessage':
        if (this.onChatMessage) {
          this.onChatMessage(message.senderId, message.username, message.message);
        }
        break;

      // Player skin update
      case 'playerSkinUpdate':
        // Update the stored player data for skins
        const playerToUpdate = this.otherPlayers.get(message.playerId);
        if (playerToUpdate) {
          playerToUpdate.skins = message.skins;
        }
        
        // Call the skin update handler in main.js
        if (this.onPlayerSkinUpdate) {
          this.onPlayerSkinUpdate(message);
        }
        break;

      // Train system: Initial train state
      case 'trainInit':
        if (this.onTrainInit) {
          this.onTrainInit(message);
        }
        break;

      // Train system: Ongoing train state updates
      case 'trainState':
        if (this.onTrainState) {
          this.onTrainState(message);
        }
        break;

      default:
        console.warn('Unhandled message:', message);
        break;
    }
  }

  /**
   * Sends local player position/rotation etc. to the server.
   * @param {Object} playerData - { position, rotation, isAiming, isReloading, isSprinting, isShooting }
   */
  sendUpdate(playerData) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'update',
          sequenceNumber: this.sequenceNumber,
          ...playerData
        })
      );
    }
  }

  /**
   * Notifies server that we fired a bullet.
   * @param {Object} bulletData - { position: {x,y,z}, direction: {x,y,z} }
   */
  sendShoot(bulletData) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number and nonce for replay protection
      this.sequenceNumber++;
      const nonce = this._generateNonce();
      
      this.socket.send(
        JSON.stringify({
          type: 'shoot',
          sequenceNumber: this.sequenceNumber,
          nonce: nonce,
          bulletData
        })
      );
    }
  }

  /**
   * Notifies server that we hit another player.
   * @param {number|string} hitPlayerId
   * @param {Object} hitData - { position: {x,y,z}, sourcePlayerId: ..., hitZone: 'head'|'body'|'limbs', damage: number }
   * @param {number|string} bulletId - Optional bulletId if known
   */
  sendPlayerHit(hitPlayerId, hitData, bulletId = null) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number and nonce for replay protection
      this.sequenceNumber++;
      const nonce = this._generateNonce();
      
      this.socket.send(
        JSON.stringify({
          type: 'playerHit',
          sequenceNumber: this.sequenceNumber,
          nonce: nonce,
          targetId: hitPlayerId,
          bulletId: bulletId,
          hitData
        })
      );
    }
  }
  
  /**
   * Notifies server that player is starting to reload.
   */
  sendReload() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'reload',
          sequenceNumber: this.sequenceNumber
        })
      );
    }
  }

  /**
   * Closes the connection manually.
   */
  disconnect() {
    this._cleanupSocket();
  }
  
  /**
   * Send a chat message to all players
   * @param {string} message - The chat message to send
   */
  sendChatMessage(message) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify({
        type: 'chat',
        message: message
      }));
    }
  }

  /**
   * Explicitly requests current train state from the server
   */
  requestTrainState() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      console.log("Requesting train state from server");
      this.socket.send(JSON.stringify({
        type: 'requestTrainState'
      }));
    } else {
      console.warn("Cannot request train state, not connected to server");
    }
  }
}

// Export a singleton instance
export const networkManager = new NetworkManager();
// Make it globally accessible
window.networkManager = networkManager;

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  networkManager.disconnect();
});

================================================
File: /public/js/networkManager.js
================================================
/**
 * Network Manager for handling server communications
 */
export class NetworkManager {
  constructor(serverUrl) {
    this.serverUrl = serverUrl;
    this.socket = null;
    this.connected = false;
    this.playerId = null;
    this.otherPlayers = new Map();
    this.onPlayerJoin = null;
    this.onPlayerLeave = null;
    this.onPlayerUpdate = null;
    this.onMessageReceived = null;
    
    // Initialize connection
    this.connect();
  }
  
  /**
   * Connect to the game server
   */
  connect() {
    try {
      this.socket = new WebSocket(this.serverUrl);
      
      this.socket.onopen = () => {
        console.log("Connected to server");
        this.connected = true;
      };
      
      this.socket.onclose = () => {
        console.log("Disconnected from server");
        this.connected = false;
        
        // Attempt to reconnect after a delay
        setTimeout(() => this.connect(), 5000);
      };
      
      this.socket.onerror = (error) => {
        console.error("WebSocket error:", error);
      };
      
      this.socket.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          this.handleMessage(message);
        } catch (err) {
          console.error("Error parsing message:", err);
        }
      };
    } catch (err) {
      console.error("Failed to connect to server:", err);
    }
  }
  
  /**
   * Handle incoming messages from the server
   * @param {Object} message - The message from the server
   */
  handleMessage(message) {
    // Handle debug visualization messages
    if (message.type === 'debugBoxVisualization') {
      this.createDebugBox(message.box, message.color || 0xFF0000, message.duration || 5000);
    }
    
    if (message.type === 'debugSphereVisualization') {
      this.createDebugSphere(message.position, message.radius || 0.5, message.color || 0xFF0000, message.duration || 5000);
    }
    
    // Call the onMessageReceived callback if defined
    if (this.onMessageReceived) {
      this.onMessageReceived(message);
    }
  }
  
  /**
   * Send a message to the server
   * @param {Object} message - The message to send
   */
  sendMessage(message) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify(message));
    } else {
      console.warn("Cannot send message, not connected to server");
    }
  }
  
  /**
   * Creates a debug box for visualization
   * @param {Object} box - Box parameters {x, y, z, width, height, length}
   * @param {number} color - Color in hex format
   * @param {number} duration - Duration in ms before removal
   */
  createDebugBox(box, color = 0xFF0000, duration = 5000) {
    if (!window.scene) return;
    
    console.log(`Creating debug box at (${box.x.toFixed(2)}, ${box.y.toFixed(2)}, ${box.z.toFixed(2)}) with dimensions ${box.width.toFixed(2)}x${box.height.toFixed(2)}x${box.length.toFixed(2)}`);
    
    // Create geometry and material
    const geometry = new THREE.BoxGeometry(box.width, box.height, box.length);
    const material = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.5,
      wireframe: false
    });
    
    // Create mesh and add to scene
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(box.x, box.y, box.z);
    window.scene.add(mesh);
    
    // Create wireframe for better visibility
    const wireGeometry = new THREE.BoxGeometry(box.width, box.height, box.length);
    const wireMaterial = new THREE.MeshBasicMaterial({
      color: 0xFFFFFF,
      wireframe: true,
      transparent: true,
      opacity: 0.8
    });
    const wireMesh = new THREE.Mesh(wireGeometry, wireMaterial);
    mesh.add(wireMesh);
    
    // Schedule removal after duration
    setTimeout(() => {
      if (window.scene) {
        window.scene.remove(mesh);
        geometry.dispose();
        material.dispose();
        wireGeometry.dispose();
        wireMaterial.dispose();
      }
    }, duration);
    
    return mesh;
  }
  
  /**
   * Creates a debug sphere for visualization
   * @param {Object} position - Position {x, y, z}
   * @param {number} radius - Sphere radius
   * @param {number} color - Color in hex format
   * @param {number} duration - Duration in ms before removal
   */
  createDebugSphere(position, radius = 0.5, color = 0xFF0000, duration = 5000) {
    if (!window.scene) return;
    
    console.log(`Creating debug sphere at (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}) with radius ${radius.toFixed(2)}`);
    
    // Create geometry and material
    const geometry = new THREE.SphereGeometry(radius, 16, 16);
    const material = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.7
    });
    
    // Create mesh and add to scene
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(position.x, position.y, position.z);
    window.scene.add(mesh);
    
    // Schedule removal after duration
    setTimeout(() => {
      if (window.scene) {
        window.scene.remove(mesh);
        geometry.dispose();
        material.dispose();
      }
    }, duration);
    
    return mesh;
  }
  
  /**
   * Disconnect from the server
   */
  disconnect() {
    if (this.socket) {
      this.socket.close();
    }
  }
} 

================================================
File: /public/js/phantom-wallet.js
================================================
// Phantom Wallet Adapter for Solana
const phantomWalletAdapter = {
    // Keep track of connected wallet and public key
    wallet: null,
    publicKey: null,
    isConnected: false,
    
    // Event callback handlers
    onConnect: null,
    onDisconnect: null,
    onError: null,
    
    // Network manager reference for sending wallet data to server
    networkManager: null,
    
    // Initialize the adapter
    init(networkManager) {
        // Store network manager reference if provided
        if (networkManager) {
            this.networkManager = networkManager;
        }
        
        // Create the UI components
        this.createConnectButton();
        
        // Check if Phantom is installed
        if (!this.isPhantomInstalled()) {
            console.warn("Phantom wallet is not installed");
            this.updateConnectButtonStatus(false, "Install Phantom");
            return false;
        }
        
        // Setup event listeners for Phantom provider
        const provider = window.phantom?.solana;
        if (provider) {
            provider.on('connect', (publicKey) => {
                this.handleConnect(publicKey);
            });
            
            provider.on('disconnect', () => {
                this.handleDisconnect();
            });
            
            provider.on('accountChanged', (publicKey) => {
                if (publicKey) {
                    this.handleConnect(publicKey);
                } else {
                    this.handleDisconnect();
                }
            });
        }
        
        return true;
    },
    
    // Set the network manager after initialization (if needed)
    setNetworkManager(networkManager) {
        this.networkManager = networkManager;
        
        // If we're already connected, send the wallet address to the server
        if (this.isConnected && this.publicKey && this.networkManager) {
            this.sendWalletAddressToServer();
        }
    },
    
    // Send the wallet address to the server for NFT verification
    sendWalletAddressToServer() {
        if (!this.networkManager || !this.publicKey) return;
        
        console.log(`Sending wallet address to server: ${this.publicKey}`);
        
        // Use the network manager to send the wallet address
        if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
            this.networkManager.socket.send(JSON.stringify({
                type: 'walletConnect',
                walletAddress: this.publicKey
            }));
        } else {
            console.warn('Unable to send wallet address: WebSocket not connected');
        }
    },
    
    // Check if Phantom wallet is installed
    isPhantomInstalled() {
        const provider = window.phantom?.solana;
        return provider && provider.isPhantom;
    },
    
    // Connect to the wallet
    async connect() {
        try {
            if (!this.isPhantomInstalled()) {
                // Check if mobile device
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                
                if (isMobile) {
                    // Try direct protocol link only - no automatic redirects
                    window.location.href = 'solana-wallet://';
                    
                    // No timeouts or additional redirects
                    return;
                } else {
                    // On desktop, open the Phantom website
                    window.open('https://phantom.app/', '_blank');
                }
                return;
            }
            
            // Connect to the wallet
            const provider = window.phantom?.solana;
            const response = await provider.connect();
            
            // Handle connection
            this.handleConnect(response.publicKey);
            
            return this.publicKey;
        } catch (error) {
            console.error("Error connecting to Phantom wallet:", error);
            this.updateConnectButtonStatus(false);
            
            // Fire error event
            if (typeof this.onError === 'function') {
                this.onError(error);
            }
            
            // Dispatch custom error event
            document.dispatchEvent(new CustomEvent('walletError', {
                detail: { error }
            }));
            
            return null;
        }
    },
    
    // Handle successful wallet connection
    handleConnect(publicKey) {
        const provider = window.phantom?.solana;
        this.wallet = provider;
        this.publicKey = publicKey.toString();
        this.isConnected = true;
        
        // Update button status
        this.updateConnectButtonStatus(true);
        
        console.log("Connected to wallet:", this.publicKey);
        
        // Send the wallet address to the server
        this.sendWalletAddressToServer();
        
        // Fire connect callback
        if (typeof this.onConnect === 'function') {
            this.onConnect(this.publicKey);
        }
        
        // Dispatch custom connect event
        document.dispatchEvent(new CustomEvent('walletConnected', {
            detail: { publicKey: this.publicKey }
        }));
    },
    
    // Disconnect from the wallet
    async disconnect() {
        if (this.wallet) {
            await this.wallet.disconnect();
            this.handleDisconnect();
        }
    },
    
    // Handle wallet disconnection
    handleDisconnect() {
        this.wallet = null;
        this.publicKey = null;
        this.isConnected = false;
        
        // Update button status
        this.updateConnectButtonStatus(false);
        console.log("Disconnected from wallet");
        
        // Fire disconnect callback
        if (typeof this.onDisconnect === 'function') {
            this.onDisconnect();
        }
        
        // Dispatch custom disconnect event
        document.dispatchEvent(new CustomEvent('walletDisconnected'));
    },
    
    // Create the connect button UI
    createConnectButton() {
        // Create the button container
        const container = document.createElement('div');
        container.id = 'phantom-connect-container';
        container.style.position = 'fixed';
        container.style.top = '10px';
        container.style.right = '10px';
        container.style.zIndex = '999999'; // Much higher z-index
        
        // Create the button
        const button = document.createElement('button');
        button.id = 'phantom-connect-button';
        button.textContent = 'Connect';
        button.style.backgroundColor = 'transparent'; // Transparent background
        button.style.color = 'white'; // White text color
        button.style.border = '2px solid #8c5cf5'; // Purple outline
        button.style.borderRadius = '20px';
        button.style.padding = '8px 16px';
        button.style.cursor = 'pointer';
        button.style.fontFamily = 'Arial, sans-serif';
        button.style.fontWeight = 'bold';
        button.style.fontSize = '14px';
        button.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
        button.style.transition = 'all 0.2s ease';
        button.style.pointerEvents = 'auto'; // Ensure clicks are registered
        
        // Add click event
        button.onclick = async (event) => {
            // For desktop gaming, prevent automatic pointer lock after clicking
            if (!(/iPhone|iPad|iPod|Android/i.test(navigator.userAgent))) {
                // Store that user clicked wallet button
                document.body.setAttribute('data-wallet-clicked', 'true');
                
                // If document has pointer lock, release it
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
                
                // Prevent default to stop any automatic pointer lock
                event.preventDefault();
                event.stopPropagation();
            }
            
            if (this.isConnected) {
                await this.disconnect();
            } else {
                await this.connect();
            }
        };
        
        // Add responsive sizing for mobile
        const checkMobileAndResize = () => {
            if (window.innerWidth <= 768 || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
                // More moderate size for mobile
                button.style.cssText += `
                    padding: 3px 8px !important;
                    font-size: 10px !important;
                    border-width: 1px !important;
                    border-radius: 14px !important;
                    opacity: 0.8 !important;
                    background-color: transparent !important;
                    color: white !important;
                `;
                container.style.cssText += `
                    top: 5px !important;
                    right: 5px !important;
                `;
                button.style.boxShadow = 'none !important';
            } else {
                button.style.cssText += `
                    padding: 8px 16px !important;
                    font-size: 14px !important;
                    border-width: 2px !important;
                    border-radius: 20px !important;
                    opacity: 1 !important;
                    background-color: transparent !important;
                    color: white !important;
                `;
                container.style.cssText += `
                    top: 10px !important;
                    right: 10px !important;
                `;
                button.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
            }
        };
        
        // Initial check
        checkMobileAndResize();
        
        // Add resize listener
        window.addEventListener('resize', checkMobileAndResize);
        
        // Force check on mobile devices
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
            setTimeout(checkMobileAndResize, 100);
        }
        
        // Add button to container
        container.appendChild(button);
        
        // Add container to document
        document.body.appendChild(container);
    },
    
    // Update the connect button status
    updateConnectButtonStatus(connected, text) {
        const button = document.getElementById('phantom-connect-button');
        if (!button) return;
        
        if (connected) {
            button.textContent = this.publicKey 
                ? `${this.publicKey.slice(0, 4)}...${this.publicKey.slice(-4)}`
                : 'Connected';
            button.style.borderColor = '#4caf50'; // Green border
            button.style.color = 'white'; // White text
            button.style.backgroundColor = 'transparent';
        } else {
            button.textContent = 'Connect'; // Always use "Connect" regardless of device or install status
            button.style.borderColor = '#8c5cf5'; // Purple border
            button.style.color = 'white'; // White text
            button.style.backgroundColor = 'transparent';
        }
    },
    
    // Sign and send transaction
    async signAndSendTransaction(transaction) {
        if (!this.isConnected || !this.wallet) {
            console.error("Wallet not connected");
            return null;
        }
        
        try {
            // Sign the transaction
            const signedTransaction = await this.wallet.signTransaction(transaction);
            
            // Send the transaction
            const signature = await window.solana.request({
                method: "sendTransaction",
                params: {
                    transaction: signedTransaction.serialize(),
                },
            });
            
            return signature;
        } catch (error) {
            console.error("Error signing transaction:", error);
            
            // Fire error event
            if (typeof this.onError === 'function') {
                this.onError(error);
            }
            
            // Dispatch custom error event
            document.dispatchEvent(new CustomEvent('walletError', {
                detail: { error }
            }));
            
            return null;
        }
    },
    
    // Get the connected wallet balance
    async getBalance() {
        if (!this.isConnected || !this.publicKey) {
            console.error("Wallet not connected");
            return null;
        }
        
        try {
            // Create a connection to the Solana network
            const connection = new solanaWeb3.Connection(
                solanaWeb3.clusterApiUrl('mainnet-beta'),
                'confirmed'
            );
            
            // Get the wallet balance
            const balance = await connection.getBalance(
                new solanaWeb3.PublicKey(this.publicKey)
            );
            
            // Convert lamports to SOL
            return balance / 1000000000; // 1 SOL = 1,000,000,000 lamports
        } catch (error) {
            console.error("Error getting balance:", error);
            return null;
        }
    }
};

// Export the adapter
export default phantomWalletAdapter; 

================================================
File: /public/js/physics.js
================================================
/**
 * Physics system using cannon.js for collision detection and physics simulation.
 */
export class PhysicsSystem {
  constructor() {
    // Create a physics world with gravity
    this.world = new CANNON.World();
    this.world.gravity.set(0, -9.8, 0);
    
    // Set default contact material properties
    this.defaultMaterial = new CANNON.Material('default');
    const defaultContactMaterial = new CANNON.ContactMaterial(
      this.defaultMaterial,
      this.defaultMaterial,
      {
        friction: 0.3,
        restitution: 0.3 // Slightly bouncy
      }
    );
    this.world.addContactMaterial(defaultContactMaterial);
    this.world.defaultContactMaterial = defaultContactMaterial;
    
    // Collection of bodies
    this.bodies = [];
    
    // Debug helper for visualizing physics bodies
    this.debugMeshes = [];
    this.debugMode = false;
    
    // Initialize ground
    this.initGround();
  }
  
  /**
   * Initialize the ground plane
   */
  initGround() {
    const groundBody = new CANNON.Body({
      mass: 0, // Static body
      shape: new CANNON.Plane(),
      material: this.defaultMaterial
    });
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate to be flat
    
    // Tag as ground for quick identification
    groundBody.isGround = true;
    
    this.world.addBody(groundBody);
    this.bodies.push(groundBody);
  }
  
  /**
   * Gets the terrain height at a specific world position
   * @param {number} x - World x coordinate
   * @param {number} z - World z coordinate
   * @returns {number} - Height at that point (0 if terrain not available)
   */
  getTerrainHeightAt(x, z) {
    // If desert terrain is available, use its height
    if (window.desertTerrain) {
      // Get blend factor - 0 means town (flat), 1 means desert
      const townBlend = window.desertTerrain.getTownBlendFactor(x, z);
      
      if (townBlend > 0) {
        // If outside town area, calculate terrain height
        const baseNoise = window.desertTerrain.baseNoise.noise(
          x * window.desertTerrain.config.noiseScale.base, 
          z * window.desertTerrain.config.noiseScale.base
        ) * window.desertTerrain.config.heightScale.base;
        
        const duneHeight = window.desertTerrain.getDirectionalDuneHeight(x, z);
        
        // Scale by blend factor for smooth transition
        return (baseNoise + duneHeight * townBlend) * townBlend;
      }
    }
    
    // Default height for town area or if terrain not available
    return 0;
  }
  
  /**
   * Create a physics body for a player
   * @param {THREE.Vector3} position - Initial position
   * @param {number} radius - Player collision radius
   * @param {number} height - Player height
   * @returns {CANNON.Body} - The created physics body
   */
  createPlayerBody(position, radius = 0.51, height = 3.06) {
    // Create a capsule shape (cylinder with spheres at ends)
    const playerBody = new CANNON.Body({
      mass: 70, // Player mass in kg
      material: this.defaultMaterial,
      fixedRotation: true, // Don't rotate the player when colliding
      linearDamping: 0.9 // Add some damping to prevent excessive sliding
    });
    
    // Use a cylinder for the body
    playerBody.addShape(new CANNON.Cylinder(radius, radius, height, 8));
    
    // Position the player body
    playerBody.position.set(position.x, position.y, position.z);
    
    // Add to world
    this.world.addBody(playerBody);
    this.bodies.push(playerBody);
    
    // If debug mode is enabled, create a visual representation
    if (this.debugMode) {
      this.createDebugMesh(playerBody);
    }
    
    return playerBody;
  }
  
  /**
   * Creates a debug mesh to visualize a physics body
   * @param {CANNON.Body} body - The physics body to visualize
   */
  createDebugMesh(body) {
    // Only used in debug mode
    if (!this.debugMode) return;
    
    // For each shape in the body, create a wireframe mesh
    body.shapes.forEach((shape, i) => {
      let geometry;
      let mesh;
      
      // Get the shape's offset and orientation
      const offset = body.shapeOffsets[i];
      const orientation = body.shapeOrientations[i];
      
      // Create different geometries based on shape type
      if (shape instanceof CANNON.Box) {
        geometry = new THREE.BoxGeometry(
          shape.halfExtents.x * 2,
          shape.halfExtents.y * 2,
          shape.halfExtents.z * 2
        );
        
        mesh = new THREE.Mesh(
          geometry,
          new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
          })
        );
        
        // Apply offset and orientation
        mesh.position.set(offset.x, offset.y, offset.z);
        mesh.quaternion.set(
          orientation.x,
          orientation.y,
          orientation.z,
          orientation.w
        );
      }
      else if (shape instanceof CANNON.Sphere) {
        geometry = new THREE.SphereGeometry(shape.radius, 16, 16);
        
        mesh = new THREE.Mesh(
          geometry,
          new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
          })
        );
        
        // Apply offset
        mesh.position.set(offset.x, offset.y, offset.z);
      }
      else if (shape instanceof CANNON.Cylinder) {
        geometry = new THREE.CylinderGeometry(
          shape.radiusTop,
          shape.radiusBottom,
          shape.height,
          shape.numSegments
        );
        
        mesh = new THREE.Mesh(
          geometry,
          new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
          })
        );
        
        // Rotate to match cannon.js cylinders
        mesh.rotation.x = Math.PI / 2;
        
        // Apply offset and orientation
        mesh.position.set(offset.x, offset.y, offset.z);
        const quat = new THREE.Quaternion(
          orientation.x,
          orientation.y,
          orientation.z,
          orientation.w
        );
        mesh.quaternion.multiply(quat);
      }
      
      if (mesh) {
        // Add to the body's group
        const group = new THREE.Group();
        group.add(mesh);
        
        // Store reference for updating
        this.debugMeshes.push({
          mesh: group,
          body: body
        });
        
        // Add to scene
        window.scene.add(group);
      }
    });
  }
  
  /**
   * Update the physics world
   * @param {number} deltaTime - Time step in seconds
   */
  update(deltaTime) {
    // Limit delta time to prevent large jumps
    const timeStep = Math.min(deltaTime, 0.1);
    
    // Update physics world
    this.world.step(timeStep);
    
    // Update debug meshes if in debug mode
    if (this.debugMode) {
      this.updateDebugMeshes();
    }
  }
  
  /**
   * Update debug mesh positions to match their physics bodies
   */
  updateDebugMeshes() {
    if (!this.debugMode) return;
    
    this.debugMeshes.forEach(item => {
      // Update position
      item.mesh.position.set(
        item.body.position.x,
        item.body.position.y,
        item.body.position.z
      );
      
      // Update orientation
      item.mesh.quaternion.set(
        item.body.quaternion.x,
        item.body.quaternion.y,
        item.body.quaternion.z,
        item.body.quaternion.w
      );
    });
  }
  
  /**
   * Enables or disables debug visualization
   * @param {boolean} enabled - Whether debug mode should be enabled
   */
  setDebugMode(enabled) {
    // Store previous debug mode to detect changes
    const previousDebugMode = this.debugMode;
    this.debugMode = enabled;
    
    // If enabling and we weren't previously in debug mode
    if (enabled && !previousDebugMode) {
      // Create meshes for existing physics bodies
      this.bodies.forEach(body => {
        this.createDebugMesh(body);
      });
      
      // Set a global flag to signal hit zone debug should be created
      window.showHitZoneDebug = true;
      
      console.log("Physics debug mode enabled - hit zones visible");
    }
    // If disabling and we were previously in debug mode
    else if (!enabled && previousDebugMode) {
      // Remove all physics debug meshes
      this.debugMeshes.forEach(item => {
        if (item.mesh && window.scene) {
          window.scene.remove(item.mesh);
          item.mesh.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
        }
      });
      this.debugMeshes = [];
      
      // Remove any hit zone debug visualizations
      this.cleanupHitZoneDebug();
      
      // Clear the global flag for hit zone debugging
      window.showHitZoneDebug = false;
      
      console.log("Physics debug mode disabled - hit zones hidden");
    }
  }
  
  /**
   * Clean up hit zone debug visualizations
   */
  cleanupHitZoneDebug() {
    // Find and remove all hit zone debug objects
    if (window.scene) {
      const hitZoneObjects = [];
      window.scene.traverse(obj => {
        if (obj.name && obj.name.startsWith("hitZoneDebug_")) {
          hitZoneObjects.push(obj);
        }
      });
      
      // Remove each hit zone debug object
      hitZoneObjects.forEach(obj => {
        window.scene.remove(obj);
        // Clean up materials and geometries
        obj.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
      });
      
      if (hitZoneObjects.length > 0) {
        console.log(`Removed ${hitZoneObjects.length} hit zone debug visualizations`);
      }
    }
    
    // Clear player hit zone debug references
    // Find all player objects
    if (window.localPlayer) {
      window.localPlayer._hitZoneDebug = null;
    }
    // Remote players
    if (window.remotePlayers) {
      window.remotePlayers.forEach(player => {
        if (player) {
          player._hitZoneDebug = null;
        }
      });
    }
  }
  
  /**
   * Refreshes hit zone debug visualizations when debug mode is active
   */
  refreshHitZoneDebug() {
    console.log("Refreshing hit zone debug visualizations");
    
    // Don't do anything if debug mode isn't enabled
    if (!this.debugMode) return;
    
    // Create debug boxes for all existing player models
    if (window.playersMap) {
      for (const [playerId, playerModel] of window.playersMap.entries()) {
        if (playerModel && typeof playerModel.createHitZoneVisualizers === 'function') {
          // Use the new direct visualization method with forced visibility
          playerModel.createHitZoneVisualizers(true);
        } else {
          console.warn(`Player ${playerId} doesn't support improved hit zones`);
          // We no longer use the old fallback method
        }
      }
    }
    
    // Also check the local player's model if available
    if (window.localPlayer && window.localPlayer.model && 
        typeof window.localPlayer.model.createHitZoneVisualizers === 'function') {
      window.localPlayer.model.createHitZoneVisualizers(true);
    }
    
    // Print debug info to console
    if (typeof window.printHitboxDebugInfo === 'function') {
      window.printHitboxDebugInfo();
    }
  }
  
  /**
   * Cleans up all physics resources
   */
  cleanup() {
    // Remove all bodies
    this.bodies.forEach(body => {
      this.world.removeBody(body);
    });
    
    // Remove all debug meshes
    if (this.debugMode) {
      this.debugMeshes.forEach(item => {
        if (window.scene) {
          window.scene.remove(item.mesh);
          item.mesh.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
        }
      });
    }
    
    // Clean up hit zone debug visualizations
    this.cleanupHitZoneDebug();
    
    this.bodies = [];
    this.debugMeshes = [];
  }
}

================================================
File: /public/js/player.js
================================================
import { Viewmodel } from './viewmodel.js';
import { updateAmmoUI, updateHealthUI, showDamageIndicator } from './ui.js';
import { applyRecoil } from './effects.js';
import { networkManager } from './network.js';

/**
 * The local Player class (first-person).
 */
export class Player {
  /**
   * @param {Object} config
   * @param {THREE.Scene} config.scene
   * @param {THREE.PerspectiveCamera} config.camera
   * @param {SoundManager} config.soundManager
   * @param {Function} config.onShoot - A callback function called when the player fires a bullet.
   */
  constructor({ scene, camera, soundManager, onShoot }) {
    // Enable ammo debugging by default
    window.debugAmmo = true;
    
    this.scene = scene;
    this.camera = camera;
    this.soundManager = soundManager;
    this.onShootCallback = onShoot;

    this.group = new THREE.Group();
    
    // Initialize previousPosition BEFORE calling spawnPlayerRandomly
    this.previousPosition = new THREE.Vector3();
    
    // Start at a random spawn point in the town street
    this.spawnPlayerRandomly();
    
    this.scene.add(this.group);
    this.camera.position.set(0, -0.7, 0);
    this.group.add(this.camera);

    this.id = null; // will be set by networkManager.onInit
    this.velocity = new THREE.Vector3();
    this.canJump = false;
    this.gravity = 25; // Increased from 15 for much stronger gravity pull

    // Add recoil boost flag to prevent normal velocity dampening
    this.recoilBoosted = false;
    this.recoilBoostTime = 0;
    this.recoilBoostDuration = 0.3; // How long the velocity boost lasts

    // Movement flags
    this.moveForward = false;
    this.moveBackward = false;
    this.moveLeft = false;
    this.moveRight = false;
    
    // Movement control flags
    this.canMove = true; // Whether player can move at all
    this.forceLockMovement = false; // Complete movement override (quickdraw mode)
    this.chatActive = false; // Whether chat input is active
    
    // Sprinting flag - new addition
    this.isSprinting = false;
    this.normalSpeed = 3.5; // Reduced from 5 for slower movement
    this.sprintSpeed = 7; // Reduced from 12 for more realistic running
    this.sprintJumpBoost = 1.1; // Reduced further for more subtle sprint jumping effect

    // Aiming
    this.isAiming = false;
    this.defaultFOV = 75;
    this.aimFOV = 65;
    
    // Camera effects for sprinting - with smoothing parameters
    this.defaultCameraHeight = -0.7;
    this.bobPhase = 0; // Phase accumulator for bob effect
    this.bobIntensity = 0; // Current intensity of bobbing (interpolates)
    this.targetBobIntensity = 0; // Target bobbing intensity
    this.bobTransitionSpeed = 3; // Speed of transition to new bob intensity
    
    // Gun
    this.viewmodel = new Viewmodel();
    this.holsterOffset = new THREE.Vector3(0.6, -1.1, -0.8);
    this.aimOffset = new THREE.Vector3(0.3, -0.9, -0.5);
    this.currentGunOffset = this.holsterOffset.clone();
    
    // Add both models to camera, but we'll only show the viewmodel
    this.camera.add(this.viewmodel.group);
    
    // FOV transition smoothing
    this.currentFOV = this.defaultFOV;
    this.targetFOV = this.defaultFOV;
    this.fovTransitionSpeed = 5; // Speed of FOV transitions

    // Reload
    this.isReloading = false;
    this.reloadTime = 4000; // Changed from 2000ms to 4000ms (4 seconds)
    this.reloadProgress = 0;
    
    // Track bullets for each weapon type separately
    this.weaponAmmo = {
      revolver: 6,
      shotgun: 2
    };
    
    this.bullets = 6; // Current active weapon's bullets
    this.maxBullets = 6;
    this.canShoot = true;

    // Weapon types and switching
    this.activeWeapon = 'revolver'; // 'revolver' or 'shotgun'
    this.weaponStats = {
      revolver: {
        maxBullets: 6,
        reloadTime: 4000,
        bulletCount: 1, // Single bullet per shot
        bulletSpread: 0.0005 // Default spread
      },
      shotgun: {
        maxBullets: 2,
        reloadTime: 6000, // Longer reload for shotgun
        bulletCount: 10, // 10 pellets per shot
        bulletSpread: 0.08, // Increased spread from 0.03 to 0.08
        pelletDamage: {
          head: 10,    // Headshot damage per pellet
          body: 5,     // Body damage per pellet
          limbs: 5     // Limb damage per pellet
        }
      }
    };

    // Health
    this.health = 100;

    // Networking
    this.lastNetworkUpdate = 0;
    this.networkUpdateInterval = 33; // ~30 fps updates, balanced between responsiveness and bandwidth

    // Alternative aiming controls
    this.isFAiming = false; // Whether player is aiming using the F key
    this.isFRmbPressed = false; // Whether right mouse button is pressed during F-aiming
    this.isLmbPressed = false; // Whether left mouse button is being held (for hold-to-shoot)
    
    // Flag to control when aiming is allowed (used by various game systems)
    this.canAim = true;
    
    // Anti-cheat: Server reconciliation
    this.serverPosition = new THREE.Vector3();
    this.isReconciling = false;
    this.reconciliationLerpFactor = 0.3; // How quickly to move to server position

    // Footstep sound system
    this.lastFootstepTime = 0; // Time of last footstep sound
    this.footstepInterval = 0.5; // Base interval in seconds between steps
    this.isLeftFoot = true; // Track which foot is next
    this.isMovingLastFrame = false; // Track if player was moving in the last frame
    this.isJumping = false; // Track jumping state
    
    // Hit zones for damage calculations
    this.hitZones = {
      head: { damage: 100 },
      body: { damage: 40 },
      limbs: { damage: 20 }
    };
    
    // Jump mechanics
    this.jumpCooldown = 0; // Cooldown timer to prevent jump spamming
    this.jumpCooldownTime = 0.3; // Time in seconds between allowed jumps
    
    // Initialize network & UI
    this.initNetworking();
    updateAmmoUI(this);
    updateHealthUI(this);
  }

  /**
   * Spawn the player at a random position along the main street
   */
  spawnPlayerRandomly() {
    // Try to find a valid spawn position with no collisions
    let spawnX, spawnY, spawnZ;
    let validSpawn = false;
    let attempts = 0;
    const maxAttempts = 20;
    
    while (!validSpawn && attempts < maxAttempts) {
      // Random position within the main street
      spawnX = (Math.random() - 0.5) * 10; // Random X between -5 and 5 (main street)
      spawnY = 2.72; // Eye level, no adjustment needed here - we set camera height directly
      spawnZ = (Math.random() - 0.5) * 40; // Random Z between -20 and 20
      
      // Check if this position is valid (not colliding with anything)
      const testPosition = new THREE.Vector3(spawnX, spawnY, spawnZ);
      validSpawn = this.checkBoundaryCollision(testPosition);
      attempts++;
    }
    
    // If we couldn't find a valid position, use a safe fallback position
    if (!validSpawn) {
      console.warn(`Could not find valid spawn position after ${maxAttempts} attempts. Using fallback.`);
      spawnX = 0;
      spawnY = 2.72; // Consistent eye level, no adjustment needed
      spawnZ = 0;
    }

    this.group.position.set(spawnX, spawnY, spawnZ);
    
    // Store the position for collision reference
    this.previousPosition.copy(this.group.position);
    
    // Random rotation (facing any direction)
    this.group.rotation.y = Math.random() * Math.PI * 2;
    
    console.log(`Player spawned at: X=${spawnX.toFixed(2)}, Y=${spawnY.toFixed(2)}, Z=${spawnZ.toFixed(2)}`);
  }

  /**
   * Initialize networking for the player
   */
  initNetworking() {
    // Start the WebSocket
    networkManager.connect();

    networkManager.onInit = (initData) => {
      this.id = initData.id;
      console.log(`Local player initialized with ID: ${this.id}`);
    };
    
    // Handle player hit
    networkManager.onPlayerHit = (sourceId, hitData, newHealth, hitZone) => {
      this.health = newHealth;
      updateHealthUI(this);
      
      // Show hit zone on screen for 100ms
      showDamageIndicator(hitData.damage, hitZone);
    };
    
    // Anti-cheat: Handle respawn from server
    networkManager.onRespawn = (position, health, bullets, maxBullets, activeWeapon) => {
      console.log("Server-initiated respawn");
      
      // Set position directly without ground offset adjustment
      if (position) {
        this.group.position.copy(position);
        this.previousPosition.copy(position);
      }
      
      // Update health
      this.health = health || 100;
      
      // Set active weapon if provided by server
      if (activeWeapon && (activeWeapon === 'revolver' || activeWeapon === 'shotgun')) {
        // Only switch if different from current
        if (this.activeWeapon !== activeWeapon) {
          this.switchWeapon(activeWeapon);
        }
      }
      
      // Reset all weapon ammo to maximum
      this.weaponAmmo = {
        revolver: this.weaponStats.revolver.maxBullets,
        shotgun: this.weaponStats.shotgun.maxBullets
      };
      
      // Set active weapon's bullets
      this.bullets = this.weaponAmmo[this.activeWeapon];
      this.maxBullets = this.weaponStats[this.activeWeapon].maxBullets;
      
      // Cancel any ongoing reloading
      if (this.isReloading) {
        // Cancel reload animation
        if (this.viewmodel) {
          this.viewmodel.cancelReload();
        }
        
        // Hide reload UI elements
        const reloadProgressContainer = document.getElementById('reload-progress-container');
        if (reloadProgressContainer) reloadProgressContainer.style.display = 'none';
      }
      
      // Reset states
      this.isReloading = false;
      this.isAiming = false;
      this.velocity.y = 0;
      
      // Reset movement flags - critical for allowing movement after respawn
      this.canMove = true;
      this.forceLockMovement = false;
      this.canAim = true;
      
      // Make sure UI is updated
      updateAmmoUI(this);
      updateHealthUI(this);
      
      // Reset vertical velocity
      this.velocity.y = 0;
      
      console.log('Player respawned from server');
      console.log(`Position: X=${this.group.position.x.toFixed(2)}, Y=${this.group.position.y.toFixed(2)}, Z=${this.group.position.z.toFixed(2)}`);
      console.log(`Weapon ammo reset - Revolver: ${this.weaponAmmo.revolver}, Shotgun: ${this.weaponAmmo.shotgun}`);
    };
  }

  update(deltaTime) {
    // Skip update if paused
    if (window.isPaused) return;
    
    // Store the previous position for collision detection and footsteps
    this.previousPosition.copy(this.group.position);
    
    // Platform stability check - prevent falling through platforms 
    this.stabilizePlatformPosition();
    
    // Anti-cheat: Handle server reconciliation
    if (this.isReconciling) {
      // Calculate distance to server position
      const distance = this.group.position.distanceTo(this.serverPosition);
      
      // Only apply reconciliation if significant deviation exists
      if (distance > 0.1) {
        // For large corrections, blend gradually
        this.group.position.lerp(this.serverPosition, this.reconciliationLerpFactor);
      } else {
        // Close enough, stop reconciling
        this.isReconciling = false;
      }
    }
    
    // Smoothly interpolate the gun offset & FOV
    const targetOffset = this.isAiming && this.canAim ? this.aimOffset : this.holsterOffset;
    this.currentGunOffset.lerp(targetOffset, 0.1);
    
    // Update viewmodel animation - Ensure this is being called!
    if (this.viewmodel) {
      this.viewmodel.update(deltaTime);
    } else {
      console.warn("Viewmodel is not initialized!");
    }

    // Adjust FOV based on sprinting and aiming with smoother transitions
    if (this.isAiming && this.canAim) {
      this.targetFOV = this.aimFOV;
    } else if (this.isSprinting && this.isMoving()) {
      // FOV effect when sprinting
      this.targetFOV = this.defaultFOV + 7; // Less extreme FOV increase (was 10)
    } else {
      this.targetFOV = this.defaultFOV;
    }
    
    // Smooth FOV transition
    this.currentFOV = THREE.MathUtils.lerp(
      this.currentFOV, 
      this.targetFOV, 
      deltaTime * this.fovTransitionSpeed
    );
    
    // Only update camera FOV if it has changed enough to be noticeable
    if (Math.abs(this.camera.fov - this.currentFOV) > 0.01) {
      this.camera.fov = this.currentFOV;
      this.camera.updateProjectionMatrix();
    }

    // Process movement
    this.move(deltaTime);
    
    // Footstep sounds logic based on movement
    const positionBeforeMovement = this.previousPosition.clone();
    
    // Update camera bob (only if on ground)
    // Always update the head bob regardless of whether we're on ground
    this.updateHeadBob(deltaTime);
    
    // Update aiming effects including crosshair
    this.updateAiming(deltaTime);
    
    // Update footstep sounds based on movement
    this.updateFootstepSounds(deltaTime, positionBeforeMovement);
    
    // Send periodic network updates
    const now = performance.now();
    if (now - this.lastNetworkUpdate > this.networkUpdateInterval) {
      this.lastNetworkUpdate = now;
      this.sendNetworkUpdate();
    }

    if (this.soundManager) {
      // Update audio listener position to follow the player's camera
      // Use precise camera position rather than group position for better audio
      const cameraPosition = new THREE.Vector3();
      this.camera.getWorldPosition(cameraPosition);
      
      // Get forward direction vector from camera
      const cameraDirection = new THREE.Vector3(0, 0, -1);
      cameraDirection.applyQuaternion(this.camera.quaternion);
      
      // Get up vector from camera
      const upVector = new THREE.Vector3(0, 1, 0);
      upVector.applyQuaternion(this.camera.quaternion);
      
      // Update the audio listener position
      this.soundManager.updateListenerPosition(cameraPosition, cameraDirection, upVector);
    }
  }

  /**
   * Process player movement based on input - can be overridden to disable movement
   * @param {number} deltaTime - Time elapsed since last frame
   */
  move(deltaTime) {
    if (!this.canMove) return; // Movement lock
    if (this.chatActive) return; // Don't move when chat is active
    
    // Update jump cooldown if it's active
    if (this.jumpCooldown > 0) {
      this.jumpCooldown = Math.max(0, this.jumpCooldown - deltaTime);
    }
    
    // Update recoil boost timer if active
    if (this.recoilBoosted) {
      this.recoilBoostTime -= deltaTime;
      if (this.recoilBoostTime <= 0) {
        this.recoilBoosted = false;
      }
    }

    // Only apply movement inputs if not in recoil boost mode
    if (!this.recoilBoosted) {
      if (this.moveForward) this.velocity.z = -this.getMoveSpeed();
      else if (this.moveBackward) this.velocity.z = this.getMoveSpeed();
      else this.velocity.z = 0;

      if (this.moveRight) this.velocity.x = this.getMoveSpeed();
      else if (this.moveLeft) this.velocity.x = -this.getMoveSpeed();
      else this.velocity.x = 0;
    }

    // Store previous position before movement for collision detection
    this.previousPosition.copy(this.group.position);

    // Store previous info for comparing changes
    const wasOnGround = this.group.position.y <= 2.72 || this.isOnObject;
    const wasJumping = this.isJumping;
    
    // Calculate new vertical position with gravity - always apply gravity unless in recoil boost
    if (!wasOnGround && (!this.recoilBoosted || this.velocity.y < 0)) {
      this.velocity.y -= this.gravity * deltaTime;
    }
    const newVerticalPos = {
      y: this.group.position.y + (this.velocity.y * deltaTime)
    };
    
    // Check if player will land on an object (like a crate)
    const feetPos = new THREE.Vector3(
      this.group.position.x,
      this.group.position.y - 2.72, // Adjust for player height
      this.group.position.z
    );
    const isOnObject = this.checkStandingOnObject(feetPos);
    
    // Get terrain height at current position
    let terrainHeight = 0;
    if (window.physics) {
      terrainHeight = window.physics.getTerrainHeightAt(this.group.position.x, this.group.position.z);
    }
    
    // Check if player would hit a ceiling
    const headPos = new THREE.Vector3(
      this.group.position.x,
      this.group.position.y + 0.3, // Adjust for player height
      this.group.position.z
    );
    const hitCeiling = this.checkCeilingCollision(headPos);
    
    // Handle vertical movement
    if (this.velocity.y <= 0 && (newVerticalPos.y <= 2.72 + terrainHeight || isOnObject)) {
      // Player landed on ground or object
      if (this.velocity.y < -3 && !wasOnGround) {
        // Play landing sound if falling fast enough
        if (this.soundManager) {
          this.soundManager.playSound("jumpland", 0, 1.2);
        }
      }
      
      // Set to ground or object height
      if (isOnObject && isOnObject.y > 2.72 + terrainHeight) {
        this.group.position.y = isOnObject.y;
      } else {
        this.group.position.y = 2.72 + terrainHeight; // Regular ground level + terrain
      }
      
      this.velocity.y = 0;
      this.canJump = true;
      this.isJumping = false;
    } else if (hitCeiling && this.velocity.y > 0) {
      // Hit ceiling, stop upward momentum
      this.velocity.y = 0;
      this.group.position.y = hitCeiling.y - 0.3; // Adjust position to be just below ceiling
    } else {
      // In air, apply vertical motion
      this.group.position.y = newVerticalPos.y;
      this.canJump = false;
    }
    
    // Apply horizontal movement to a test position (don't actually move yet)
    const movement = new THREE.Vector3();
    
    // Special handling for recoil boost - use absolute world direction
    if (this.recoilBoosted) {
      // For recoil, we use the velocity directly as world-space movement
      movement.x = this.velocity.x * deltaTime;
      movement.z = this.velocity.z * deltaTime;
    } else {
      // Normal movement - apply player rotation
      movement.x = this.velocity.x * deltaTime;
      movement.z = this.velocity.z * deltaTime;
      movement.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.group.rotation.y);
    }
    
    // Calculate desired new position
    const newPosition = this.group.position.clone().add(movement);
    
    // Auto-step detection - check if there's a small step in front of us that we can climb
    const stepHeight = 0.9;
    const stepPosition = this.checkForStep(newPosition, stepHeight);
    if (stepPosition) {
      // Found a step we can climb - adjust our position to step up onto it
      // Smooth the transition by interpolating current height and target height
      const stepUpLerpFactor = 0.5; // Controls how quickly we step up
      this.group.position.y = THREE.MathUtils.lerp(
        this.group.position.y,
        stepPosition.y,
        stepUpLerpFactor
      );
      this.velocity.y = 0; // Reset vertical velocity
      this.canJump = true; // Always can jump on top of a step
      this.isJumping = false;
    }
    
    // Use our enhanced collision system with sliding
    const finalPosition = this.handleCollisionSliding(newPosition);
    
    // Apply the horizontal position
    this.group.position.x = finalPosition.x;
    this.group.position.z = finalPosition.z;
    
    // We no longer need to handle jump sound here since it's handled in the jump() method
  }

  /**
   * Update footstep sounds based on movement
   * @param {number} deltaTime - Time elapsed since last frame
   * @param {THREE.Vector3} previousPosition - Position before movement this frame
   */
  updateFootstepSounds(deltaTime, previousPosition) {
    // Only play footstep sounds if we're on the ground and actually moving
    const isMovingNow = this.isMoving() && this.canJump;
    
    // Calculate how far we've moved this frame
    const distanceMoved = this.group.position.distanceTo(previousPosition);
    
    // Skip if not moving or not on ground
    if (!isMovingNow || distanceMoved < 0.001) {
      this.isMovingLastFrame = false;
      return;
    }
    
    // Calculate the appropriate footstep interval based on speed
    let currentInterval = this.footstepInterval;
    if (this.isSprinting) {
      currentInterval = 0.3; // Faster steps when sprinting
    } else {
      currentInterval = 0.5; // Normal walking pace
    }
    
    // Accumulate time since last footstep
    this.lastFootstepTime += deltaTime;
    
    // Check if it's time for a footstep sound
    if (this.lastFootstepTime >= currentInterval) {
      // Reset the timer, with a small random variation for naturalness
      this.lastFootstepTime = -0.05 + Math.random() * 0.1;
      
      // Determine which foot and play the appropriate sound
      if (this.soundManager) {
        // Use direct sound play instead of positional audio for now
        this.soundManager.playSound(
          this.isLeftFoot ? 'leftstep' : 'rightstep',
          0, // No cooldown
          this.isSprinting ? 1.2 : 0.8 // Adjust volume based on speed
        );
        
        // Try positional audio as fallback
        try {
          this.soundManager.playSoundAt(
            this.isLeftFoot ? 'leftstep' : 'rightstep',
            this.group.position,
            0, // No cooldown
            this.isSprinting ? 1.2 : 0.8 // Adjust volume based on speed
          );
        } catch (err) {
          console.log("Fallback to positional audio failed:", err);
        }
      }
      
      // Switch feet for next step
      this.isLeftFoot = !this.isLeftFoot;
    }
    
    this.isMovingLastFrame = true;
  }

  /**
   * Updates camera head bobbing effect for walking/running with much smoother transitions
   * @param {number} deltaTime - Time elapsed since last frame
   */
  updateHeadBob(deltaTime) {
    // Update target bobbing intensity based on movement
    if (this.isMoving() && this.canJump) {
      // Very subtle bobbing values for higher camera position
      this.targetBobIntensity = this.isSprinting ? 0.022 : 0.011;
    } else {
      this.targetBobIntensity = 0;
    }
    
    // Smoothly transition bob intensity
    this.bobIntensity = THREE.MathUtils.lerp(
      this.bobIntensity,
      this.targetBobIntensity,
      Math.min(1, deltaTime * this.bobTransitionSpeed)
    );
    
    // Only calculate bob if intensity is significant
    if (this.bobIntensity > 0.001) {
      // Update phase at a speed proportional to movement
      // Use different frequencies for vertical and horizontal to create more natural movement
      this.bobPhase += deltaTime * (this.isSprinting ? 10 : 6);
      
      // Calculate vertical and horizontal components
      const verticalBob = Math.sin(this.bobPhase * 2) * this.bobIntensity;
      // Much smaller horizontal component
      const horizontalBob = Math.cos(this.bobPhase) * this.bobIntensity * 0.3;
      
      // Apply to camera position smoothly - ensure we're using defaultCameraHeight
      this.camera.position.y = THREE.MathUtils.lerp(
        this.camera.position.y,
        this.defaultCameraHeight + verticalBob,
        Math.min(1, deltaTime * 8)
      );
      
      // Extremely subtle horizontal movement
      this.camera.position.x = THREE.MathUtils.lerp(
        this.camera.position.x,
        horizontalBob,
        Math.min(1, deltaTime * 3)
      );
    } else {
      // Smoothly return to default position when not moving
      this.camera.position.y = THREE.MathUtils.lerp(
        this.camera.position.y,
        this.defaultCameraHeight,
        Math.min(1, deltaTime * 4)
      );
      
      this.camera.position.x = THREE.MathUtils.lerp(
        this.camera.position.x,
        0,
        Math.min(1, deltaTime * 3)
      );
    }
  }

  /**
   * Returns the current movement speed based on sprint state and location
   * @returns {number} The current movement speed
   */
  getMoveSpeed() {
    // Apply sprint speed if sprint key is pressed
    return this.isSprinting ? this.sprintSpeed : this.normalSpeed;
  }
  
  /**
   * Checks if the player is currently moving
   * @returns {boolean} True if any movement key is pressed
   */
  isMoving() {
    return this.moveForward || this.moveBackward || this.moveLeft || this.moveRight;
  }

  /**
   * Checks for collision with town objects
   * @param {THREE.Vector3} position - The position to check
   * @returns {boolean} - true if no collision, false if colliding
   */
  checkBoundaryCollision(position) {
    // Check collision with town objects/colliders
    if (window.physics && window.physics.bodies) {
      // Create a small sphere for collision detection
      const playerRadius = 0.68; // Increased radius from 0.4 to prevent getting too close
      
      // We'll check two points - one at "shoulder" height and one at "foot" height
      // to make collisions more realistic
      const shoulderPos = new THREE.Vector3(position.x, position.y - 0.5, position.z);
      const footPos = new THREE.Vector3(position.x, position.y - 1.5, position.z);
      
      // Check each physics body that's not a player or arena boundary
      for (const body of window.physics.bodies) {
        // Skip if mass > 0 (non-static body)
        if (body.mass > 0) continue;
        
        // Currently we only handle box shapes
        for (let i = 0; i < body.shapes.length; i++) {
          const shape = body.shapes[i];
          if (shape.type !== CANNON.Shape.types.BOX) continue;
          
          // Get the world position/rotation of this shape
          const shapePos = new CANNON.Vec3();
          const shapeQuat = new CANNON.Quaternion();
          body.pointToWorldFrame(body.shapeOffsets[i], shapePos);
          body.quaternion.mult(body.shapeOrientations[i], shapeQuat);
          
          // Convert to THREE.js objects for easier collision check
          const boxPos = new THREE.Vector3(shapePos.x, shapePos.y, shapePos.z);
          const boxSize = new THREE.Vector3(
            shape.halfExtents.x * 2,
            shape.halfExtents.y * 2,
            shape.halfExtents.z * 2
          );
          
          // Create box3 from position and size
          const box = new THREE.Box3().setFromCenterAndSize(boxPos, boxSize);
          
          // Skip floor-like objects for horizontal collision (if player is above them)
          // This helps with standing on roofs and floors
          if (boxSize.y < 1.0 && position.y > boxPos.y + boxSize.y/2 + 0.1) {
            // This is a thin box below the player - likely a floor, skip horizontal collision
            continue;
          }
          
          // Skip ceiling-like objects for horizontal collision (if player is below them)
          if (boxSize.y < 1.0 && position.y < boxPos.y - boxSize.y/2 - 0.1) {
            // This is a thin box above the player - likely a ceiling, skip horizontal collision
            continue;
          }
          
          // Check if player sphere intersects with box
          const distShoulder = box.distanceToPoint(shoulderPos);
          const distFoot = box.distanceToPoint(footPos);
          
          if (distShoulder < playerRadius || distFoot < playerRadius) {
            return false; // Collision detected
          }
        }
      }
    }
    
    return true; // No collision
  }
  
  /**
   * Handles sliding along walls when colliding
   * @param {THREE.Vector3} desiredPosition - Where player wants to move
   * @returns {THREE.Vector3} - Adjusted position with sliding if needed
   */
  handleCollisionSliding(desiredPosition) {
    // If no collision, return the desired position
    if (this.checkBoundaryCollision(desiredPosition)) {
      return desiredPosition;
    }
    
    // We have a collision, try to slide along the obstacle
    const currentPos = this.group.position.clone();
    
    // Calculate movement vector
    const movement = desiredPosition.clone().sub(currentPos);
    
    // If movement is very small, just return current position to avoid getting stuck
    if (movement.lengthSq() < 0.0001) {
      return currentPos;
    }
    
    // Scale down movement vector to find a non-colliding position
    const scaledMovement = movement.clone();
    let validPosition = false;
    
    // Try sliding along X and Z separately
    const slideX = currentPos.clone();
    slideX.x += movement.x;
    
    const slideZ = currentPos.clone();
    slideZ.z += movement.z;
    
    // Check if either sliding direction is valid
    const canSlideX = this.checkBoundaryCollision(slideX);
    const canSlideZ = this.checkBoundaryCollision(slideZ);
    
    if (canSlideX) {
      // X-axis movement is valid
      return slideX;
    } else if (canSlideZ) {
      // Z-axis movement is valid
      return slideZ;
    }
    
    // If we're really stuck, check if we're penetrating a collider and try to push out
    const escapeDist = 0.05; // Small escape distance
    
    // Try escaping in each cardinal direction
    const escapeVectors = [
      new THREE.Vector3(escapeDist, 0, 0),
      new THREE.Vector3(-escapeDist, 0, 0),
      new THREE.Vector3(0, 0, escapeDist),
      new THREE.Vector3(0, 0, -escapeDist)
    ];
    
    for (const escapeVec of escapeVectors) {
      const escapePos = currentPos.clone().add(escapeVec);
      if (this.checkBoundaryCollision(escapePos)) {
        console.log("Rescued player from being stuck");
        return escapePos;
      }
    }
    
    // If all else fails, return current position
    return currentPos;
  }

  /**
   * Send position/rotation updates to the server.
   */
  sendNetworkUpdate() {
    if (this.id == null) return;
    const direction = new THREE.Vector3();
    this.camera.getWorldDirection(direction);

    networkManager.sendUpdate({
      position: {
        x: this.group.position.x,
        y: this.group.position.y,
        z: this.group.position.z
      },
      rotation: {
        y: this.group.rotation.y
      },
      isAiming: this.isAiming,
      isReloading: this.isReloading,
      isSprinting: this.isSprinting,
      isShooting: this.viewmodel && this.viewmodel.animationState === 'shoot',
      health: this.health
    });
  }

  /**
   * Handle shooting logic
   */
  shoot() {
    if (this.bullets <= 0 || !this.canShoot || this.isReloading) {
      // No bullets or can't shoot
      if (this.bullets === 0) {
        const reloadMessage = document.getElementById('reload-message');
        if (reloadMessage) reloadMessage.style.display = 'block';
        
        // If we're already in the empty animation, don't trigger it again
        if (this.viewmodel && 
            this.viewmodel.animationState !== `${this.activeWeapon}empty`) {
          // Play the empty gun animation when no ammo
          if (this.isAiming && this.viewmodel) {
            this.viewmodel.playFakeShootAnim();
            
            // Play empty gun click sound if sound manager exists
            if (this.soundManager && !window.isMobile) {
              // Only play empty click on desktop - skip on mobile to avoid sound issues
              if (this.activeWeapon === 'shotgun') {
                this.soundManager.playSound("shotgunempty");
              }
            }
          }
        }
      }
      return;
    }
    
    // Actually shoot
    this.bullets--;
    
    // Update weapon-specific ammo storage and ensure consistency
    this._syncWeaponAmmo();
    
    updateAmmoUI(this);

    this.canShoot = false;
    setTimeout(() => { this.canShoot = true; }, 250);

    // Play the shooting animation on the viewmodel if aiming
    if (this.isAiming) {
      this.viewmodel.playShootAnim();
    }

    // Find bullet spawn - use viewmodel instead of revolver
    const bulletStart = this.viewmodel.getBarrelTipWorldPosition();
    
    // Get weapon stats for spread and bullet count
    const weaponStats = this.weaponStats[this.activeWeapon];
    
    // Play the appropriate gunshot sound
    if (this.soundManager) {
      // Set a specific sound name based on weapon type
      const soundName = this.activeWeapon === 'shotgun' ? "shotgunshot" : "shot";
      
      // Play the sound (let the sound manager handle cooldowns internally)
      this.soundManager.playSound(soundName, 100, 0.8);
    }
    
    // For shotgun, create multiple pellets with spread
    for (let i = 0; i < weaponStats.bulletCount; i++) {
      const shootDir = new THREE.Vector3();
      this.camera.getWorldDirection(shootDir);
      
      // Apply spread - more spread for shotgun, less for revolver
      const spread = weaponStats.bulletSpread;
      shootDir.x += (Math.random() - 0.5) * spread;
      shootDir.y += (Math.random() - 0.5) * spread;
      shootDir.z += (Math.random() - 0.5) * spread;
      
      shootDir.normalize();
      
      // Call the callback to spawn bullet in main.js
      if (typeof this.onShootCallback === 'function') {
        this.onShootCallback(bulletStart, shootDir);
      }
    }

    // Recoil effect - stronger for shotgun
    const recoilMultiplier = this.activeWeapon === 'shotgun' ? 2.5 : 1.0;
    applyRecoil(this, recoilMultiplier);
    
    // If out of bullets, show reload hint
    if (this.bullets === 0) {
      const reloadMessage = document.getElementById('reload-message');
      if (reloadMessage) {
        reloadMessage.style.display = 'block';
      }
    }
  }

  /**
   * Called when the player takes damage.
   * @param {number} amount - Damage amount.
   * @param {string} hitZone - Hit zone ('head', 'body', 'limbs')
   */
  takeDamage(amount, hitZone) {
    const previousHealth = this.health;
    this.health = Math.max(this.health - amount, 0);
    console.log(`Player ${this.id} took ${amount} damage in the ${hitZone || 'body'}. Health is now ${this.health}`);
    
    // Show damage indicator with damage amount and hit zone
    if (typeof window.showDamageIndicator === 'function') {
      window.showDamageIndicator(amount, hitZone);
    }
    
    // Update health UI
    updateHealthUI(this);
    
    // Add screen flash effect based on damage amount
    this.showDamageEffect(amount);
    
    // If health reached zero, handle death
    if (previousHealth > 0 && this.health === 0) {
      console.log('Game Over');
      // Respawn after a delay
      setTimeout(() => {
        this.respawn();
      }, 1500);
    }
  }

  /**
   * Shows a screen flash effect when taking damage
   * @param {number} amount - The damage amount
   */
  showDamageEffect(amount) {
    // Create a full-screen flash effect
    const flash = document.createElement('div');
    flash.style.position = 'absolute';
    flash.style.top = '0';
    flash.style.left = '0';
    flash.style.width = '100%';
    flash.style.height = '100%';
    flash.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
    flash.style.opacity = '0';
    flash.style.transition = 'opacity 0.1s ease-in, opacity 0.4s ease-out';
    flash.style.pointerEvents = 'none';
    flash.style.zIndex = '900';
    document.getElementById('game-container').appendChild(flash);
    
    // Adjust intensity based on damage
    const intensity = Math.min(amount / 100, 0.8);
    flash.style.backgroundColor = `rgba(255, 0, 0, ${intensity})`;
    
    // Show and fade out
    setTimeout(() => {
      flash.style.opacity = '1';
      setTimeout(() => {
        flash.style.opacity = '0';
        setTimeout(() => {
          if (flash.parentNode) {
            flash.parentNode.removeChild(flash);
          }
        }, 400);
      }, 100);
    }, 0);
  }

  /**
   * Respawn the player after death
   */
  respawn() {
    // Reset health
    this.health = 100;
    updateHealthUI(this);
    
    // Spawn at a random position
    this.spawnPlayerRandomly();
    
    // Reset weapon state
    // Reset ammo for all weapons to their maximum values
    this.weaponAmmo = {
      revolver: this.weaponStats.revolver.maxBullets,
      shotgun: this.weaponStats.shotgun.maxBullets
    };
    
    // Set active weapon's bullets
    this.bullets = this.weaponAmmo[this.activeWeapon];
    this.maxBullets = this.weaponStats[this.activeWeapon].maxBullets;
    
    // Reset animation and interaction states
    this.isReloading = false;
    this.isAiming = false;
    this.velocity.y = 0;
    
    // Reset movement flags - critical for allowing movement after respawn
    this.canMove = true;
    this.forceLockMovement = false;
    this.canAim = true;
    
    // Make sure UI is updated
    updateAmmoUI(this);
    
    // Reset vertical velocity
    this.velocity.y = 0;
    
    console.log('Player respawned');
    console.log(`Position: X=${this.group.position.x.toFixed(2)}, Y=${this.group.position.y.toFixed(2)}, Z=${this.group.position.z.toFixed(2)}`);
    console.log(`Weapon ammo reset - Revolver: ${this.weaponAmmo.revolver}, Shotgun: ${this.weaponAmmo.shotgun}`);
  }

  /**
   * Start the reload process
   */
  startReload() {
    if (this.isReloading || this.bullets >= this.maxBullets) return;
    
    this.isReloading = true;
    this.reloadProgress = 0;
    
    // Use the current weapon's reload time
    const reloadTime = this.weaponStats[this.activeWeapon].reloadTime;
    
    const reloadMessage = document.getElementById('reload-message');
    const reloadProgressContainer = document.getElementById('reload-progress-container');
    if (reloadMessage) reloadMessage.style.display = 'none';
    if (reloadProgressContainer) reloadProgressContainer.style.display = 'block';

    // Reset aim state tracking to ensure it's synchronized with reload
    if (this.updateAiming && typeof this.updateAiming.lastAimingState !== 'undefined') {
      this.updateAiming.lastAimingState = this.isAiming;
    }
    
    // Always make sure viewmodel is visible during reload
    if (this.viewmodel) {
      // Special handling: allow reload to interrupt empty animation
      const emptyAnimName = `${this.activeWeapon}empty`;
      if (this.viewmodel.animationState === emptyAnimName) {
        // Reset any blocking flags to ensure reload can play
        this.viewmodel.blockHolster = false;
      }
      
      this.viewmodel.group.visible = true;
      this.viewmodel.playReloadAnim();
    }
    
    // Play reload sound based on weapon type
    if (this.soundManager) {
      const soundName = this.activeWeapon === 'shotgun' ? "shotgunreloading" : "reloading";
      this.soundManager.playSound(soundName);
    }

    // Anti-cheat: Notify server about reload start
    networkManager.sendReload();
    
    // Animate the reload progress
    const startTime = performance.now();
    const updateReload = (currentTime) => {
      if (!this.isReloading) return;
      
      const elapsed = currentTime - startTime;
      this.reloadProgress = Math.min(100, (elapsed / reloadTime) * 100);
      
      const reloadProgressBar = document.getElementById('reload-progress-bar');
      if (reloadProgressBar) {
        reloadProgressBar.style.width = this.reloadProgress + '%';
      }
      
      if (elapsed < reloadTime) {
        requestAnimationFrame(updateReload);
      } else {
        this.completeReload();
      }
    };
    
    // Start reload progress animation
    requestAnimationFrame(updateReload);
    
    // Notify server about reload state
    this.sendNetworkUpdate();
  }

  /**
   * Complete the reload process
   */
  completeReload() {
    // Update bullets to max
    this.bullets = this.maxBullets;
    
    // Sync weapon ammo state
    this._syncWeaponAmmo();
    
    updateAmmoUI(this);

    const reloadProgressContainer = document.getElementById('reload-progress-container');
    const reloadProgressBar = document.getElementById('reload-progress-bar');
    if (reloadProgressContainer) reloadProgressContainer.style.display = 'none';
    if (reloadProgressBar) reloadProgressBar.style.width = '0%';
    
    this.isReloading = false;

    // After reload finishes, we don't need to do anything with animations
    // The viewmodel.playReloadAnim's onComplete already handles the transition to idle
    // Just ensure visibility is properly managed after the animation finishes
    if (this.viewmodel) {
      // Update aim state tracking to ensure aim toggle detection will work properly
      if (this.updateAiming && typeof this.updateAiming.lastAimingState !== 'undefined') {
        // Force aim state to be correctly tracked
        this.updateAiming.lastAimingState = this.isAiming;
      }
      
      // Let the animation system handle visibility
      if (!this.isAiming) {
        setTimeout(() => {
          if (!this.isAiming && this.viewmodel && !this.viewmodel.forceVisible) {
            this.viewmodel.group.visible = false;
          }
        }, 500);
      }
    }
    
    this.sendNetworkUpdate(); // let others know
  }
  
  /**
   * Updates aiming effects including crosshair animation
   * @param {number} deltaTime - Time elapsed since last frame
   */
  updateAiming(deltaTime) {
    // Static variable to track previous aiming state
    if (this.updateAiming.lastAimingState === undefined) {
      this.updateAiming.lastAimingState = false;
    }
    
    // Check if aiming state changed
    if (this.isAiming !== this.updateAiming.lastAimingState) {
      // State changed - handle animations
      if (this.isAiming) {
        // Starting to aim - play draw animation and show model
        this.viewmodel.group.visible = true;
        
        // In idle state (possibly after reload), always allow draw animation
        if (this.viewmodel.animationState === 'idle') {
          this.viewmodel.blockHolster = false;
          this.viewmodel.pendingHolster = false;
        }
        
        // Handle case when trying to aim during reload
        if (this.viewmodel.animationState === 'revolverreload') {
          // Don't play draw animation now, the reload onComplete will handle it
          // Just update state tracking
        } else {
          // Always play the draw animation when toggling aim for other states
          this.viewmodel.playDrawAim();
        }
      } else {
        // Stopping aim - handle holstering
        
        // If we're in draw animation, explicitly set pendingHolster to true to 
        // ensure the viewmodel knows we want to holster after draw completes
        if (this.viewmodel.animationState === 'revolverdraw') {
          this.viewmodel.pendingHolster = true;
        }
        
        // Handle case when toggling aim after reload or other animations
        // Make sure we can always holster after animations finish
        if (this.viewmodel.animationState === 'idle' || 
            this.viewmodel.animationState === 'revolveraim') {
          this.viewmodel.blockHolster = false;
          this.viewmodel.pendingHolster = false; // Reset any pending holster flag
        }
        
        // Reset any stuck flags in other states
        if (this.viewmodel.animationState === 'revolverreload' || 
            this.viewmodel.animationState === 'revolvershot' ||
            this.viewmodel.animationState === 'revolverempty') {
          this.viewmodel.pendingHolster = true;
        }
        
        // Only holster if not in a forced-visible state
        if (!this.viewmodel.blockHolster) {
          // Stopping aim - play holster animation
          this.viewmodel.playHolsterAnim();
          
          // When holster animation finishes, hide the model if needed
          const holsterDuration = this.viewmodel.actions.revolverholster._clip.duration * 1000;
          
          setTimeout(() => {
            if (!this.isAiming && !this.viewmodel.forceVisible) { 
              // Double-check we're still not aiming and not forced visible
              this.viewmodel.group.visible = false;
            }
          }, holsterDuration + 100); // Add a small buffer to ensure animation completes
        }
      }
      
      // Update the tracked state
      this.updateAiming.lastAimingState = this.isAiming;
    }
    
    // Special case: in aim state but stuck with blockHolster flag
    // This helps recover from cases where state gets out of sync after reload
    if (!this.isAiming && this.viewmodel.animationState === 'revolveraim' && 
        this.viewmodel.blockHolster) {
      // Force the blockHolster flag to false so we can holster
      this.viewmodel.blockHolster = false;
      this.viewmodel.playHolsterAnim();
    }
    
    // Always keep the gun visible if forceVisible is set
    if (this.viewmodel && this.viewmodel.forceVisible) {
      this.viewmodel.group.visible = true;
    }
    
    // Crosshair animation if aiming
    const crosshair = document.getElementById('crosshair');
    if (crosshair && this.isAiming) {
      // Add subtle size adjustment based on player movement
      const isMoving = this.isMoving();
      const movementFactor = isMoving ? 1.0 + (this.velocity.length() * 0.005) : 1.0;
      
      // Calculate scaled size based on movement (further reduced from 60 to 40)
      const size = 40 * movementFactor;
      crosshair.style.width = `${size}px`;
      crosshair.style.height = `${size}px`;
      
      // Set opacity based on movement
      const opacity = isMoving ? 0.7 : 0.8;
      
      // Update colors differently for paths and circle
      const circleColor = this.health < 30 
        ? `rgba(255, ${Math.floor(255 * (this.health/30))}, ${Math.floor(255 * (this.health/60))}, ${opacity})`
        : `rgba(255, 255, 255, ${opacity})`;
      
      // Use black for paths (arrows)
      const pathColor = `rgba(0, 0, 0, ${opacity})`;
      
      // Apply black color to all SVG paths (the arrows)
      const pathElements = crosshair.querySelectorAll('path');
      pathElements.forEach(el => {
        el.setAttribute('stroke', pathColor);
      });
      
      // Apply white color to the center dot
      const circleElement = crosshair.querySelector('circle');
      if (circleElement) {
        circleElement.setAttribute('fill', circleColor);
      }
      
      // Apply expansion animation class if not already applied
      if (!crosshair.classList.contains('expand') && !crosshair.classList.contains('expanded')) {
        crosshair.classList.add('expand');
        
        // After animation completes, mark as expanded
        setTimeout(() => {
          crosshair.classList.remove('expand');
          crosshair.classList.add('expanded');
        }, 250); // Match animation duration
      }
      
      // IMPORTANT: Don't modify transform - leave the inline style working
    }
  }

  /**
   * Checks if player is standing on an object
   * @param {THREE.Vector3} feetPosition - Position of player's feet
   * @returns {THREE.Vector3|false} The detected ground position or false
   */
  checkStandingOnObject(feetPosition) {
    // Early return if physics not initialized
    if (!window.physics || !window.physics.bodies) {
      return false;
    }
    
    // Create a ray starting slightly above feet and going down
    const rayStart = feetPosition.clone();
    rayStart.y += 0.2; // Start a bit above to ensure we detect even when slightly penetrating
    
    const rayLength = 0.4; // Detection distance
    
    // Check each physics body for ground
    for (const body of window.physics.bodies) {
      // Skip if mass > 0 (non-static body)
      if (body.mass > 0) continue;
      
      // Currently we only handle box shapes
      for (let i = 0; i < body.shapes.length; i++) {
        const shape = body.shapes[i];
        if (shape.type !== CANNON.Shape.types.BOX) continue;
        
        // Get the world position/rotation of this shape
        const shapePos = new CANNON.Vec3();
        body.pointToWorldFrame(body.shapeOffsets[i], shapePos);
        
        // Convert to THREE.js objects
        const boxPos = new THREE.Vector3(shapePos.x, shapePos.y, shapePos.z);
        const boxSize = new THREE.Vector3(
          shape.halfExtents.x * 2,
          shape.halfExtents.y * 2,
          shape.halfExtents.z * 2
        );
        
        // Create box3 from position and size
        const box = new THREE.Box3().setFromCenterAndSize(boxPos, boxSize);
        
        // Check if the ray intersects the box
        if (Math.abs(rayStart.x - boxPos.x) <= boxSize.x/2 + 0.5 && 
            Math.abs(rayStart.z - boxPos.z) <= boxSize.z/2 + 0.5) {
          // We're within the X-Z bounds of the box, check Y
          const topOfBox = boxPos.y + boxSize.y/2;
          
          // If the box top is between our ray start and end points
          if (topOfBox <= rayStart.y && topOfBox >= rayStart.y - rayLength) {
            // Return the position with the adjusted y-coordinate
            return new THREE.Vector3(rayStart.x, topOfBox + 2.72, rayStart.z);
          }
        }
      }
    }
    
    return false;
  }
  
  /**
   * Checks if player's head is hitting a ceiling
   * @param {THREE.Vector3} headPosition - Position of player's head
   * @returns {THREE.Vector3|false} The detected ceiling position or false
   */
  checkCeilingCollision(headPosition) {
    // Early return if physics not initialized
    if (!window.physics || !window.physics.bodies) {
      return false;
    }
    
    // Create a ray starting at head and going up
    const rayStart = headPosition.clone();
    const rayLength = 0.3; // Detection distance
    
    // Check each physics body for ceiling
    for (const body of window.physics.bodies) {
      // Skip if this is an arena boundary
      if (body.arenaBoundary) continue;
      
      // Skip if mass > 0 (non-static body)
      if (body.mass > 0) continue;
      
      // Currently we only handle box shapes
      for (let i = 0; i < body.shapes.length; i++) {
        const shape = body.shapes[i];
        if (shape.type !== CANNON.Shape.types.BOX) continue;
        
        // Get the world position/rotation of this shape
        const shapePos = new CANNON.Vec3();
        const shapeQuat = new CANNON.Quaternion();
        body.pointToWorldFrame(body.shapeOffsets[i], shapePos);
        body.quaternion.mult(body.shapeOrientations[i], shapeQuat);
        
        // Convert to THREE.js objects
        const boxPos = new THREE.Vector3(shapePos.x, shapePos.y, shapePos.z);
        const boxSize = new THREE.Vector3(
          shape.halfExtents.x * 2,
          shape.halfExtents.y * 2,
          shape.halfExtents.z * 2
        );
        
        // Create box3 from position and size
        const box = new THREE.Box3().setFromCenterAndSize(boxPos, boxSize);
        
        // Check if the ray intersects the box
        if (Math.abs(rayStart.x - boxPos.x) <= boxSize.x/2 + 0.5 && 
            Math.abs(rayStart.z - boxPos.z) <= boxSize.z/2 + 0.5) {
          // We're within the X-Z bounds of the box, check Y
          const bottomOfBox = boxPos.y - boxSize.y/2;
          
          // If the box bottom is between our ray start and end points
          if (bottomOfBox >= rayStart.y && bottomOfBox <= rayStart.y + rayLength) {
            // Return the position with the adjusted y-coordinate
            return new THREE.Vector3(rayStart.x, bottomOfBox, rayStart.z);
          }
        }
      }
    }
    
    return false;
  }

  /**
   * Prevents the player from falling through platforms by performing additional checks
   */
  stabilizePlatformPosition() {
    // If we're on the ground or jumping, no need for stabilization
    if (this.canJump || this.velocity.y > 0) return;
    
    // Cast a ray directly below the player to detect platforms we might be falling through
    const feetPos = new THREE.Vector3(
      this.group.position.x,
      this.group.position.y - 2.62, // Slightly higher than feet for early detection
      this.group.position.z
    );
    
    // Check if there's an object below
    const platformBelow = this.checkDirectlyBelow(feetPos, 1.0);
    
    // If we found a platform and we're falling, snap to it
    if (platformBelow && this.velocity.y < 0) {
      this.group.position.y = platformBelow.y;
      this.velocity.y = -0.01; // Very small downward force
      this.canJump = true;
      this.isJumping = false;
    }
  }
  
  /**
   * Checks for a platform directly below the player with a short ray
   * @param {THREE.Vector3} position - Starting position for ray
   * @param {number} maxDistance - Maximum distance to check below
   * @returns {THREE.Vector3|false} Position on top of platform or false
   */
  checkDirectlyBelow(position, maxDistance) {
    // Early return if physics not initialized
    if (!window.physics) return false;
    
    // Get all physics bodies
    const bodies = window.physics.bodies;
    
    // Check each physics body
    for (const body of bodies) {
      // Skip irrelevant bodies
      if (body.isGround || body.arenaBoundary || body.mass > 0) continue;
      
      // Check each shape
      for (let i = 0; i < body.shapes.length; i++) {
        const shape = body.shapes[i];
        if (shape.type !== CANNON.Shape.types.BOX) continue;
        
        // Get shape properties
        const shapePos = new CANNON.Vec3();
        body.pointToWorldFrame(body.shapeOffsets[i], shapePos);
        
        // Convert to THREE.js
        const boxPos = new THREE.Vector3(shapePos.x, shapePos.y, shapePos.z);
        const boxSize = new THREE.Vector3(
          shape.halfExtents.x * 2,
          shape.halfExtents.y * 2,
          shape.halfExtents.z * 2
        );
        
        // Check if we're above the box horizontally (with margin)
        const margin = 0.6; // Wide margin for safety
        if (Math.abs(position.x - boxPos.x) <= boxSize.x/2 + margin && 
            Math.abs(position.z - boxPos.z) <= boxSize.z/2 + margin) {
          
          // Get top of box
          const topOfBox = boxPos.y + boxSize.y/2;
          
          // If we're within maxDistance above the box
          if (position.y >= topOfBox && position.y - topOfBox <= maxDistance) {
            return new THREE.Vector3(this.group.position.x, topOfBox + 2.72, this.group.position.z);
          }
        }
      }
    }
    
    return false;
  }

  /**
   * Make the player jump.
   */
  jump() {
    // Don't allow jumping if on cooldown
    if (this.jumpCooldown > 0) {
      return;
    }
    
    // Double check for platforms first - ensures we can always jump on platforms
    if (!this.canJump) {
      const feetPos = new THREE.Vector3(
        this.group.position.x,
        this.group.position.y - 2.72,
        this.group.position.z
      );
      
      if (this.checkStandingOnObject(feetPos)) {
        this.canJump = true;
      }
    }
    
    if (this.canJump && !this.forceLockMovement && this.canMove) {
      // Much more realistic jump velocity (significantly reduced)
      this.velocity.y = this.isSprinting ? 5.2 * this.sprintJumpBoost : 5.2;
      this.canJump = false;
      this.isJumping = true;
      this.jumpCooldown = this.jumpCooldownTime; // Apply cooldown
      
      // Play jump sound - IMMEDIATELY with full volume
      if (this.soundManager) {
        console.log("Playing jumpup sound from jump method");
        this.soundManager.playSound("jumpup", 0, 1.5);
      }
      
      // Log for debugging
      console.log("Player jumped", this.velocity.y);
    }
  }

  /**
   * Checks if there's a small step or platform in front of the player that can be automatically climbed
   * @param {THREE.Vector3} targetPosition - The desired position to move to
   * @param {number} maxStepHeight - Maximum height difference allowed for auto-stepping
   * @returns {THREE.Vector3|false} The adjusted position with the correct height, or false
   */
  checkForStep(targetPosition, maxStepHeight) {
    // Early return if physics not initialized
    if (!window.physics) return false;
    
    // Calculate movement direction (normalized)
    const moveDir = new THREE.Vector3()
      .subVectors(targetPosition, this.group.position)
      .normalize();
    
    // Ignore if no horizontal movement
    if (Math.abs(moveDir.x) < 0.001 && Math.abs(moveDir.z) < 0.001) return false;
    
    // Cast multiple rays in the movement direction with different offsets
    const rayOffsets = [
      {x: 0, z: 0},            // Center of movement
      {x: moveDir.z*0.4, z: -moveDir.x*0.4},  // Perpendicular right
      {x: -moveDir.z*0.4, z: moveDir.x*0.4},  // Perpendicular left
      {x: moveDir.x*0.5, z: moveDir.z*0.5},   // Forward offset
      {x: moveDir.x*0.8, z: moveDir.z*0.8},   // Further forward
      {x: moveDir.x*1.0, z: moveDir.z*1.0},   // Even further forward
      {x: moveDir.x*1.2, z: moveDir.z*1.2}    // Maximum forward detection
    ];
    
    // Get all physics bodies
    const bodies = window.physics.bodies;
    
    let highestStep = null;
    let highestStepY = this.group.position.y - 10; // Start very low
    
    // Check each ray starting point
    for (const offset of rayOffsets) {
      // Create ray start position with offset
      const rayStart = new THREE.Vector3(
        targetPosition.x + offset.x, 
        this.group.position.y - 2.62, // Slightly above feet level
        targetPosition.z + offset.z
      );
      
      // Check each body with this ray
      for (const body of bodies) {
        // Skip if this is an arena boundary or moving object
        if (body.arenaBoundary || body.mass > 0) continue;
        
        // Currently we only handle box shapes
        for (let i = 0; i < body.shapes.length; i++) {
          const shape = body.shapes[i];
          if (shape.type !== CANNON.Shape.types.BOX) continue;
          
          // Get the world position/rotation of this shape
          const shapePos = new CANNON.Vec3();
          body.pointToWorldFrame(body.shapeOffsets[i], shapePos);
          
          // Convert to THREE.js objects
          const boxPos = new THREE.Vector3(shapePos.x, shapePos.y, shapePos.z);
          const boxSize = new THREE.Vector3(
            shape.halfExtents.x * 2,
            shape.halfExtents.y * 2,
            shape.halfExtents.z * 2
          );
          
          // Use much larger margin for step detection (especially for building entrances)
          const margin = 1.0; // Increased from 0.8 for better detection
          if (Math.abs(rayStart.x - boxPos.x) <= boxSize.x/2 + margin && 
              Math.abs(rayStart.z - boxPos.z) <= boxSize.z/2 + margin) {
            
            // Get the top of the box
            const topOfBox = boxPos.y + boxSize.y/2;
            
            // Check if it's a valid step height:
            // 1. The step must be higher than our current feet position
            // 2. But not too high to climb automatically
            const feetY = this.group.position.y - 2.72;
            const heightDiff = topOfBox - feetY;
            
            if (heightDiff > 0.05 && heightDiff <= maxStepHeight) {
              // Keep track of the highest valid step
              if (topOfBox > highestStepY) {
                highestStepY = topOfBox;
                highestStep = new THREE.Vector3(targetPosition.x, topOfBox + 2.72, targetPosition.z);
              }
            }
          }
        }
      }
    }
    
    // Return the highest step found, or false if none
    return highestStep;
  }

  /**
   * Syncs the weapon ammo state to ensure consistency
   * @private
   */
  _syncWeaponAmmo() {
    // Make sure weaponAmmo is initialized for all weapon types
    if (!this.weaponAmmo) {
      this.weaponAmmo = {
        revolver: this.weaponStats.revolver.maxBullets,
        shotgun: this.weaponStats.shotgun.maxBullets
      };
    }
    
    // Ensure both weapons have entries in the ammo object
    if (this.weaponAmmo.revolver === undefined) {
      this.weaponAmmo.revolver = this.weaponStats.revolver.maxBullets;
    }
    
    if (this.weaponAmmo.shotgun === undefined) {
      this.weaponAmmo.shotgun = this.weaponStats.shotgun.maxBullets;
    }
    
    // Ensure the current weapon's ammo in weaponAmmo matches bullets
    this.weaponAmmo[this.activeWeapon] = this.bullets;
    
    // Ensure max bullets is consistent with weapon stats
    this.maxBullets = this.weaponStats[this.activeWeapon].maxBullets;
    
    // Log ammo state for debugging
    if (window.debugAmmo) {
      console.log(`[AMMO] ${this.activeWeapon}: ${this.bullets}/${this.maxBullets} (Revolver: ${this.weaponAmmo.revolver}, Shotgun: ${this.weaponAmmo.shotgun})`);
    }
  }

  /**
   * Switch to a different weapon
   * @param {string} weaponType - The weapon type to switch to ('revolver' or 'shotgun')
   */
  switchWeapon(weaponType) {
    if (this.activeWeapon === weaponType || this.isReloading) {
      return; // Already using this weapon or currently reloading
    }
    
    // Force sync current weapon ammo to ensure it's saved correctly
    this._syncWeaponAmmo();
    
    // Remember previous weapon for animation transitions
    const prevWeapon = this.activeWeapon;
    
    // Log the current ammo state before switching
    if (window.debugAmmo) {
      console.log(`[SWITCH] FROM ${prevWeapon}(${this.bullets}) TO ${weaponType}(${this.weaponAmmo[weaponType]})`);
    }
    
    // Check if we're in a special animation state that might cause issues
    const currentAnimState = this.viewmodel ? this.viewmodel.animationState : 'idle';
    const isInBlockingAnimation = currentAnimState === `${prevWeapon}empty` || 
                                  currentAnimState === `${prevWeapon}shot` ||
                                  this.viewmodel.blockHolster;
    
    // Save current weapon's ammo state
    this.weaponAmmo[prevWeapon] = this.bullets;
    
    // Update weapon type
    this.activeWeapon = weaponType;
    
    // Update bullet count and max bullets based on new weapon
    this.maxBullets = this.weaponStats[weaponType].maxBullets;
    this.reloadTime = this.weaponStats[weaponType].reloadTime;
    
    // Restore the new weapon's ammo state
    this.bullets = this.weaponAmmo[weaponType];
    
    // Log the new ammo state after switching
    if (window.debugAmmo) {
      console.log(`[SWITCH] COMPLETE - Now ${this.activeWeapon} with ${this.bullets} bullets`);
    }
    
    // Update UI
    updateAmmoUI(this);
    
    // Update weapon indicators in UI
    this.updateWeaponIndicators();
    
    // Reset viewmodel animation flags if switching from a blocking animation state
    if (isInBlockingAnimation && this.viewmodel) {
      console.log(`Resetting viewmodel flags when switching from ${currentAnimState}`);
      this.viewmodel.blockHolster = false;
      this.viewmodel.pendingHolster = false;
      this.viewmodel.forceVisible = false;
      
      // Force animation state to idle to ensure clean transition
      this.viewmodel._transitionTo('idle', {
        resetTimeOnPlay: true,
        onComplete: () => {
          // After forcing idle, setup for the next animation
          if (this.isAiming) {
            // Small delay to ensure state is stable
            setTimeout(() => {
              if (this.isAiming) {
                this.viewmodel.playDrawAim();
              }
            }, 50);
          }
        }
      });
      
      // If not aiming, return early to avoid additional animation calls
      if (!this.isAiming) {
        console.log(`Switched to ${weaponType} (not aiming)`);
        return;
      }
    }
    
    // If currently aiming, transition to the new weapon's aim animation
    if (this.isAiming && this.viewmodel) {
      // If we just reset to idle, let the callback handle it
      if (isInBlockingAnimation) return;
      
      // For clean transition, first holster current weapon
      this.viewmodel.animationState = `${prevWeapon}aim`; // Force the correct state for holstering
      this.viewmodel.playHolsterAnim();
      
      // After holstering, draw new weapon
      setTimeout(() => {
        // Force viewmodel to be visible (might have been hidden during holster)
        this.viewmodel.group.visible = true;
        
        // Reset any animation state flags to ensure clean transition
        this.viewmodel.pendingHolster = false;
        this.viewmodel.blockHolster = false;
        
        // Play draw animation for new weapon
        this.viewmodel.playDrawAim();
      }, 400); // Allow slightly more time for holster animation to complete
    }
    
    console.log(`Switched to ${weaponType}`);
  }
  
  /**
   * Update the weapon indicators in the UI to match the current weapon
   */
  updateWeaponIndicators() {
    // Handle mobile UI weapon indicators
    const revolverIndicator = document.getElementById('revolver-indicator');
    const shotgunIndicator = document.getElementById('shotgun-indicator');
    
    if (revolverIndicator && shotgunIndicator) {
      if (this.activeWeapon === 'revolver') {
        revolverIndicator.className = 'weapon-indicator active';
        shotgunIndicator.className = 'weapon-indicator';
      } else {
        shotgunIndicator.className = 'weapon-indicator active';
        revolverIndicator.className = 'weapon-indicator';
      }
    }
    
    // Handle desktop UI weapon indicators
    const revolverDesktopIndicator = document.getElementById('revolver-indicator-desktop');
    const shotgunDesktopIndicator = document.getElementById('shotgun-indicator-desktop');
    
    if (revolverDesktopIndicator && shotgunDesktopIndicator) {
      if (this.activeWeapon === 'revolver') {
        revolverDesktopIndicator.className = 'desktop-weapon-indicator active';
        shotgunDesktopIndicator.className = 'desktop-weapon-indicator';
      } else {
        shotgunDesktopIndicator.className = 'desktop-weapon-indicator active';
        revolverDesktopIndicator.className = 'desktop-weapon-indicator';
      }
    }
  }
}

================================================
File: /public/js/playerIdentity.js
================================================
/**
 * Player Identity System
 * Handles player naming and identification with client-side persistence.
 * Includes token-based authentication and session recovery.
 */

// Generate a UUID v4 (random)
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = crypto.getRandomValues(new Uint8Array(1))[0] % 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// Generate a secure token
function generateToken() {
  const buffer = new Uint8Array(32);
  crypto.getRandomValues(buffer);
  return Array.from(buffer)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

// Check if we should bypass normal identity flow (for development/testing)
function shouldBypassIdentity() {
  const urlParams = new URLSearchParams(window.location.search);
  return urlParams.has('newplayer') || urlParams.has('dev');
}

// Get player data from storage or create new
function getPlayerIdentity() {
  try {
    // Development bypass: create a new identity if URL param is present
    if (shouldBypassIdentity()) {
      console.log('Development mode: Creating new player identity');
      return createNewPlayerIdentity();
    }
    
    // First try sessionStorage (for this browser tab only)
    const sessionData = sessionStorage.getItem('wildWestPlayerSession');
    if (sessionData) {
      const parsedData = JSON.parse(sessionData);
      console.log('Found session player data');
      return parsedData;
    }
    
    // Then try localStorage (for persistent storage)
    const storedData = localStorage.getItem('wildWestPlayerIdentity');
    if (storedData) {
      try {
        const parsedData = JSON.parse(storedData);
        
        // Verify data integrity
        if (!parsedData.id || !parsedData.token || !parsedData.username) {
          console.warn('Incomplete player identity found, creating new');
          return createNewPlayerIdentity();
        }
        
        // Update session storage for faster access in this tab
        sessionStorage.setItem('wildWestPlayerSession', storedData);
        
        console.log('Found stored player identity');
        return parsedData;
      } catch (e) {
        console.error('Error parsing stored player identity:', e);
        return createNewPlayerIdentity();
      }
    } else {
      return createNewPlayerIdentity();
    }
  } catch (e) {
    // Handle private browsing mode where storage might be unavailable
    console.error('Error accessing storage:', e);
    return createNewPlayerIdentity(true);
  }
}

// Create new player identity
function createNewPlayerIdentity(ephemeral = false) {
  // For development/testing, append timestamp to make usernames unique across tabs
  const devSuffix = shouldBypassIdentity() ? `-${Date.now().toString().slice(-4)}` : '';
  
  const newIdentity = {
    id: generateUUID(),
    token: generateToken(),
    username: generateRandomName() + devSuffix, // Start with a random name
    createdAt: Date.now(),
    lastLogin: Date.now(),
    ephemeral: ephemeral, // Flag for when storage isn't available
    devMode: shouldBypassIdentity() // Flag to mark dev identities
  };
  
  console.log('Created new player identity');
  return newIdentity;
}

// Generate a random western-themed name
function generateRandomName() {
  const firstParts = [
    // Titles
    "Sheriff", "Deputy", "Marshal", "Doc", "Judge", "Colonel", "General", "Captain", 
    "Ranger", "Bandit", "Outlaw", "Desperado", "Gunslinger", "Bounty", "Rustler",
    // Adjectives
    "Quick", "Fast", "Slick", "Dusty", "Rusty", "Wild", "Mad", "Crazy", "Lazy", 
    "Lucky", "Unlucky", "Smoky", "Grumpy", "Gritty", "Salty", "One-eye", "One-shot",
    "Crooked", "Sneaky", "Dead-eye", "Two-gun", "Lone", "Tall", "Short", "Big", "Little"
  ];
  
  const middleParts = [
    "Dog", "Cat", "Wolf", "Iron", "Steel", "Silver", "Gold", "Copper", "Tin", 
    "Hand", "Eye", "Shot", "Gun", "Draw", "Boot", "Hat", "Star", "Badge", 
    "River", "Canyon", "Mesa", "Valley", "Rock", "Stone", "Mountain", "Desert",
    "", "", "", "", "", "" // Empty strings to increase chance of 2-part names
  ];
  
  const lastParts = [
    // Names
    "Jack", "Jim", "Joe", "Bill", "Bob", "Sam", "Tom", "Will", "Frank", "Jesse",
    "Wyatt", "Doc", "Billy", "Butch", "Roy", "Tex", "Hank", "Pete", "Buck", "Duke",
    // Nouns
    "Kid", "Smith", "Jones", "McGraw", "James", "Cassidy", "Earp", "Holliday", 
    "Dalton", "Garrett", "Hickok", "Carson", "Crockett", "Walker", "Jackson"
  ];
  
  // Randomly decide if we want 2 or 3 parts
  const useMiddlePart = Math.random() > 0.5;
  
  const first = firstParts[Math.floor(Math.random() * firstParts.length)];
  const last = lastParts[Math.floor(Math.random() * lastParts.length)];
  
  if (useMiddlePart) {
    const middle = middleParts[Math.floor(Math.random() * middleParts.length)];
    return middle ? `${first} ${middle} ${last}` : `${first} ${last}`;
  } else {
    return `${first} ${last}`;
  }
}

// Save player data to storage
function savePlayerIdentity(playerData) {
  try {
    playerData.lastLogin = Date.now();
    
    // For development mode identities, only save to session storage
    // to avoid overwriting the main identity in localStorage
    if (playerData.devMode) {
      const dataStr = JSON.stringify(playerData);
      sessionStorage.setItem('wildWestPlayerSession', dataStr);
      console.log('Development mode: Saved player identity to session storage only');
      return true;
    }
    
    // Always save to session storage for this tab
    const dataStr = JSON.stringify(playerData);
    sessionStorage.setItem('wildWestPlayerSession', dataStr);
    
    // Save to localStorage if not ephemeral
    if (!playerData.ephemeral) {
      localStorage.setItem('wildWestPlayerIdentity', dataStr);
    }
    
    return true;
  } catch (e) {
    console.error('Failed to save player identity:', e);
    return false;
  }
}

// Preload game content in background while user sets their name
function preloadGameContent() {
  console.log("Starting background preload of game content...");
  // The actual preloading happens in parallel in main.js
  // We've removed the progress bar but kept the preloading logic
}

// Show username prompt
function promptForUsername(playerData) {
  // Get device info for responsive design
  const isMobile = window.innerWidth < 768;
  const isSmallMobile = window.innerWidth < 480;
  const isVerySmallMobile = window.innerWidth < 360;
  const isSmallScreen = window.innerWidth < 1024;
  
  // Constants for easy adjustments - responsive values based on screen size
  const UI_CONSTANTS = {
    // Image sizes (percentage of container width)
    TITLE_IMAGE_WIDTH: isVerySmallMobile ? '260px' : (isSmallMobile ? '300px' : (isMobile ? '350px' : (isSmallScreen ? '400px' : '450px'))),
    NAME_SUBMIT_WIDTH: isVerySmallMobile ? '260px' : (isSmallMobile ? '300px' : (isMobile ? '350px' : (isSmallScreen ? '400px' : '450px'))),
    ENTER_GAME_WIDTH: isVerySmallMobile ? '260px' : (isSmallMobile ? '300px' : (isMobile ? '350px' : (isSmallScreen ? '400px' : '450px'))),
    
    // Spacing
    VERTICAL_SPACING: isMobile ? '15px' : '20px',
    
    // Text input positioning and sizing
    TEXT_INPUT_WIDTH: isMobile ? '60%' : '65%',
    TEXT_INPUT_TOP: '50%',
    TEXT_INPUT_LEFT: isMobile ? '12%' : '9%',
    TEXT_INPUT_FONT_SIZE: isVerySmallMobile ? '14px' : (isSmallMobile ? '16px' : (isMobile ? '18px' : (isSmallScreen ? '24px' : '28px'))),
    
    // Regenerate button positioning and sizing
    REGEN_BUTTON_SIZE: isVerySmallMobile ? '28px' : (isSmallMobile ? '35px' : (isMobile ? '40px' : (isSmallScreen ? '60px' : '80px'))),
    REGEN_BUTTON_RIGHT: isMobile ? '10%' : '6%',
    REGEN_BUTTON_TOP: isMobile ? '50%' : '39%'
  };

  return new Promise((resolve) => {
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'username-modal';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.backgroundColor = 'rgba(0, 0, 0, 0.65)';
    modal.style.zIndex = '2000'; // Higher than other game overlays
    modal.style.display = 'flex';
    modal.style.justifyContent = 'center';
    modal.style.alignItems = 'center';
    modal.style.pointerEvents = 'auto'; // Ensure it captures input
    
    // Create modal content
    const modalContent = document.createElement('div');
    modalContent.style.textAlign = 'center';
    modalContent.style.display = 'flex';
    modalContent.style.flexDirection = 'column';
    modalContent.style.alignItems = 'center';
    modalContent.style.width = '100%';
    modalContent.style.padding = isMobile ? '10px' : '20px';
    
    // Game title image
    const titleImage = document.createElement('img');
    titleImage.src = '/models/westweltbeta.png';
    titleImage.style.marginBottom = UI_CONSTANTS.VERTICAL_SPACING;
    titleImage.style.maxWidth = UI_CONSTANTS.TITLE_IMAGE_WIDTH;
    
    // Name submit image container
    const nameSubmitContainer = document.createElement('div');
    nameSubmitContainer.style.position = 'relative';
    nameSubmitContainer.style.marginBottom = UI_CONSTANTS.VERTICAL_SPACING;
    nameSubmitContainer.style.width = UI_CONSTANTS.NAME_SUBMIT_WIDTH;
    
    // Name submit image
    const nameSubmitImage = document.createElement('img');
    nameSubmitImage.src = '/models/namesubmit.png';
    nameSubmitImage.style.maxWidth = '100%';
    
    // Input field (positioned on top of namesubmit.png)
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = isMobile ? 'Enter name...' : 'Your name, partner...';
    input.value = playerData.username || generateRandomName();
    input.maxLength = 16; // Restrict input to 16 characters
    input.style.position = 'absolute';
    input.style.top = UI_CONSTANTS.TEXT_INPUT_TOP;
    input.style.left = UI_CONSTANTS.TEXT_INPUT_LEFT;
    input.style.transform = 'translateY(-50%)'; // Only vertical centering
    input.style.width = UI_CONSTANTS.TEXT_INPUT_WIDTH;
    input.style.padding = isMobile ? '4px' : '8px';
    input.style.backgroundColor = 'transparent';
    input.style.border = 'none';
    input.style.outline = 'none';
    input.style.color = 'white';
    input.style.fontSize = UI_CONSTANTS.TEXT_INPUT_FONT_SIZE;
    input.style.textAlign = 'left'; // Left align text instead of center
    
    // Regenerate button (positioned on the right side of namesubmit.png)
    const regenButton = document.createElement('button');
    regenButton.textContent = ''; // Completely remove the symbol
    regenButton.title = "Generate new name";
    regenButton.style.position = 'absolute';
    regenButton.style.top = UI_CONSTANTS.REGEN_BUTTON_TOP;
    regenButton.style.right = UI_CONSTANTS.REGEN_BUTTON_RIGHT;
    regenButton.style.transform = 'translateY(-50%)';
    regenButton.style.width = UI_CONSTANTS.REGEN_BUTTON_SIZE;
    regenButton.style.height = UI_CONSTANTS.REGEN_BUTTON_SIZE;
    regenButton.style.backgroundColor = 'transparent';
    regenButton.style.color = 'white';
    regenButton.style.border = 'none';
    regenButton.style.borderRadius = '4px';
    regenButton.style.cursor = 'pointer';
    regenButton.style.fontSize = '18px';
    regenButton.style.display = 'flex';
    regenButton.style.justifyContent = 'center';
    regenButton.style.alignItems = 'center';
    
    // Add window resize handler for dynamic adjustments
    const handleResize = () => {
      const newIsMobile = window.innerWidth < 768;
      const newIsSmallMobile = window.innerWidth < 480;
      const newIsVerySmallMobile = window.innerWidth < 360;
      const newIsSmallScreen = window.innerWidth < 1024;
      
      // Update sizes based on new screen dimensions
      const titleWidth = newIsVerySmallMobile ? '260px' : (newIsSmallMobile ? '300px' : (newIsMobile ? '350px' : (newIsSmallScreen ? '400px' : '450px')));
      titleImage.style.maxWidth = titleWidth;
      nameSubmitContainer.style.width = titleWidth;
      enterGameImage.style.maxWidth = titleWidth;
      
      // Update font size
      input.style.fontSize = newIsVerySmallMobile ? '14px' : (newIsSmallMobile ? '16px' : (newIsMobile ? '18px' : (newIsSmallScreen ? '24px' : '28px')));
      input.style.left = newIsMobile ? '12%' : '9%';
      input.style.width = newIsMobile ? '60%' : '65%';
      
      // Update button size
      const buttonSize = newIsVerySmallMobile ? '28px' : (newIsSmallMobile ? '35px' : (newIsMobile ? '40px' : (newIsSmallScreen ? '60px' : '80px')));
      regenButton.style.width = buttonSize;
      regenButton.style.height = buttonSize;
      regenButton.style.right = newIsMobile ? '10%' : '6%';
      regenButton.style.top = newIsMobile ? '50%' : '39%';
    };
    
    window.addEventListener('resize', handleResize);
    
    // Regenerate button click handler
    regenButton.addEventListener('click', () => {
      input.value = generateRandomName();
      input.focus();
    });
    
    // Enter game button image
    const enterGameImage = document.createElement('img');
    enterGameImage.src = '/models/entergame.png';
    enterGameImage.style.maxWidth = UI_CONSTANTS.ENTER_GAME_WIDTH;
    enterGameImage.style.cursor = 'pointer';
    
    // Form handling
    const handleSubmit = () => {
      let username = input.value.trim();
      
      // Client-side validation to prevent XSS attacks
      if (username) {
        // Check for potentially malicious content
        const hasSuspiciousContent = /<[^>]*>|javascript:|on\w+=/i.test(username);
        
        if (hasSuspiciousContent) {
          // Clean the username for safety
          username = username
            .replace(/</g, '')
            .replace(/>/g, '')
            .replace(/javascript:/gi, '')
            .replace(/on\w+=/gi, '');
          
          // Show warning
          input.style.border = '2px solid orange';
          setTimeout(() => {
            input.style.border = 'none';
          }, 2000);
        }
        
        // Limit length
        if (username.length > 16) {
          username = username.substring(0, 16);
        }
        
        playerData.username = username;
        
        // Save immediately after username is set
        const saved = savePlayerIdentity(playerData);
        if (!saved && !playerData.ephemeral) {
          // Mark as ephemeral if save failed
          playerData.ephemeral = true;
          console.warn('Storage unavailable, using ephemeral player identity');
        }
        
        // Animate the modal fading out
        modal.style.transition = 'opacity 0.3s ease';
        modal.style.opacity = '0';
        
        setTimeout(() => {
          if (modal.parentNode) {
            document.body.removeChild(modal);
            // Remove resize listener when modal is closed
            window.removeEventListener('resize', handleResize);
          }
          resolve(playerData);
        }, 300);
      } else {
        input.style.border = '2px solid red';
        setTimeout(() => {
          input.style.border = 'none';
        }, 1000);
      }
    };
    
    // Add event listeners
    enterGameImage.addEventListener('click', handleSubmit);
    input.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        handleSubmit();
      }
    });
    
    // Focus the input field when modal appears
    setTimeout(() => input.focus(), 100);
    
    // Assemble modal
    nameSubmitContainer.appendChild(nameSubmitImage);
    nameSubmitContainer.appendChild(input);
    nameSubmitContainer.appendChild(regenButton);
    
    modalContent.appendChild(titleImage);
    modalContent.appendChild(nameSubmitContainer);
    modalContent.appendChild(enterGameImage);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    
    // Add fade-in animation for a smooth appearance
    modal.style.opacity = '0';
    modal.style.transition = 'opacity 0.3s ease';
    setTimeout(() => {
      modal.style.opacity = '1';
    }, 10);
  });
}

// Prompt to recover saved identity
function promptIdentityRecovery(storedIdentity, newIdentity) {
  return new Promise((resolve) => {
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'identity-recovery-modal';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
    modal.style.zIndex = '1000';
    modal.style.display = 'flex';
    modal.style.justifyContent = 'center';
    modal.style.alignItems = 'center';
    
    // Create modal content
    const modalContent = document.createElement('div');
    modalContent.style.backgroundColor = '#2c2c2c';
    modalContent.style.borderRadius = '8px';
    modalContent.style.padding = '20px';
    modalContent.style.width = '90%';
    modalContent.style.maxWidth = '450px';
    modalContent.style.boxShadow = '0 4px 10px rgba(0, 0, 0, 0.5)';
    modalContent.style.textAlign = 'center';
    
    // Title
    const title = document.createElement('h2');
    title.textContent = 'Welcome Back, Partner!';
    title.style.color = '#f8bb00';
    title.style.marginBottom = '10px';
    title.style.fontFamily = 'Western, serif';
    
    // Message
    const message = document.createElement('p');
    message.textContent = `We found your saved gunslinger, ${storedIdentity.username}. Would you like to continue with this character?`;
    message.style.color = '#fff';
    message.style.marginBottom = '20px';
    
    // Buttons container
    const buttonsContainer = document.createElement('div');
    buttonsContainer.style.display = 'flex';
    buttonsContainer.style.justifyContent = 'center';
    buttonsContainer.style.gap = '15px';
    
    // Yes button
    const yesButton = document.createElement('button');
    yesButton.textContent = 'Yes, continue';
    yesButton.style.padding = '10px 20px';
    yesButton.style.backgroundColor = '#336633';
    yesButton.style.color = '#fff';
    yesButton.style.border = 'none';
    yesButton.style.borderRadius = '4px';
    yesButton.style.cursor = 'pointer';
    yesButton.style.fontWeight = 'bold';
    
    // No button
    const noButton = document.createElement('button');
    noButton.textContent = 'No, start fresh';
    noButton.style.padding = '10px 20px';
    noButton.style.backgroundColor = '#8b0000';
    noButton.style.color = '#fff';
    noButton.style.border = 'none';
    noButton.style.borderRadius = '4px';
    noButton.style.cursor = 'pointer';
    noButton.style.fontWeight = 'bold';
    
    // Button hover effects
    yesButton.onmouseover = () => { yesButton.style.backgroundColor = '#3c7a3c'; };
    yesButton.onmouseout = () => { yesButton.style.backgroundColor = '#336633'; };
    noButton.onmouseover = () => { noButton.style.backgroundColor = '#a00000'; };
    noButton.onmouseout = () => { noButton.style.backgroundColor = '#8b0000'; };
    
    // Button handlers
    yesButton.addEventListener('click', () => {
      document.body.removeChild(modal);
      resolve(storedIdentity);
    });
    
    noButton.addEventListener('click', () => {
      // Clear stored identity when user chooses to start fresh
      try {
        localStorage.removeItem('wildWestPlayerIdentity');
      } catch (e) {
        console.error('Error clearing stored identity:', e);
      }
      document.body.removeChild(modal);
      resolve(newIdentity);
    });
    
    // Assemble modal
    buttonsContainer.appendChild(yesButton);
    buttonsContainer.appendChild(noButton);
    modalContent.appendChild(title);
    modalContent.appendChild(message);
    modalContent.appendChild(buttonsContainer);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
  });
}

// Check if there's a stored identity in another storage medium (like localStorage)
// that doesn't match our current session
async function checkForIdentityConflict(currentIdentity) {
  try {
    // Skip conflict resolution in development mode
    if (shouldBypassIdentity() || currentIdentity.devMode) {
      return currentIdentity;
    }
    
    // Only check if our current identity is new (no username yet)
    if (currentIdentity.username) {
      return currentIdentity;
    }
    
    const storedDataStr = localStorage.getItem('wildWestPlayerIdentity');
    if (!storedDataStr) {
      return currentIdentity;
    }
    
    const storedIdentity = JSON.parse(storedDataStr);
    
    // If stored identity has a username and doesn't match our current ID
    if (storedIdentity && 
        storedIdentity.username && 
        storedIdentity.id !== currentIdentity.id) {
      
      // Ask user if they want to recover the stored identity
      return await promptIdentityRecovery(storedIdentity, currentIdentity);
    }
    
    return currentIdentity;
  } catch (e) {
    console.error('Error checking for identity conflict:', e);
    return currentIdentity;
  }
}

// Initialize player identity system
async function initPlayerIdentity() {
  // Get the basic identity first
  let playerData = getPlayerIdentity();
  
  // Check if there's a conflict with stored identity
  playerData = await checkForIdentityConflict(playerData);
  
  // Start preloading game content in background
  preloadGameContent();
  
  // For first-time users, we'll show the username prompt but game continues loading
  const isFirstTime = playerData.createdAt === playerData.lastLogin || shouldBypassIdentity();
  
  if (isFirstTime) {
    // Return a promise that will resolve when the user submits their name
    return new Promise(resolve => {
      // Show username prompt immediately, but don't wait for it
      promptForUsername(playerData).then(updatedPlayerData => {
        // Update last login time and save
        updatedPlayerData.lastLogin = Date.now();
        savePlayerIdentity(updatedPlayerData);
        resolve(updatedPlayerData);
      });
    });
  } else {
    // For returning users, continue normally
    playerData.lastLogin = Date.now();
    savePlayerIdentity(playerData);
    return playerData;
  }
}

// Verify client identity with server
async function verifyIdentityWithServer(playerData) {
  // This would typically make a request to the server to verify the token
  // For now, we'll just simulate this process
  return new Promise(resolve => {
    setTimeout(() => {
      // Assume the verification was successful
      resolve({
        verified: true,
        playerData: playerData
      });
    }, 300);
  });
}

export { 
  initPlayerIdentity,
  getPlayerIdentity, 
  savePlayerIdentity, 
  promptForUsername,
  verifyIdentityWithServer
}; 

================================================
File: /public/js/playerModel.js
================================================
// /public/js/playerModel.js

/**
 * The third-person model used to represent remote players
 * (and possibly the local player in others' view).
 */
export class ThirdPersonModel {
  constructor(scene, playerId) {
    this.scene = scene;
    this.playerId = playerId;
    this.group = new THREE.Group();

    this.collisionBox = new THREE.Box3();
    this.hitboxSize = { width: 1.02, height: 3.06, depth: 1.02 };
    
    // Hit zones for damage calculations
    this.headHitbox = new THREE.Box3();
    this.bodyHitbox = new THREE.Box3();
    this.limbsHitbox = new THREE.Box3();
    
    // Define hit zone relative sizes - adjusted for better accuracy
    this.headSize = { width: 0.45, height: 0.45, depth: 0.45 }; // Slightly smaller head hitbox
    this.bodySize = { width: 0.8, height: 0.95, depth: 0.55 }; // Narrower and much shorter body
    this.limbsSize = { width: 1.02, height: 3.06, depth: 1.02 }; // Full character size
    
    // Vertical offsets for positioning hitboxes more accurately
    this.headOffset = 0.45; // Further increased to move head lower
    this.bodyOffset = 0.25; // Adjusted to prevent overlap with head

    // Health
    this.health = 100;

    // Target position/rotation for smooth interpolation
    this.targetPosition = new THREE.Vector3(0, 0, 0);
    this.targetRotation = 0;
    
    // Initialize the group position to match target position
    this.group.position.copy(this.targetPosition);
    this.group.rotation.y = this.targetRotation;

    // Animation states
    this.animationMixer = null;
    this.animations = {};
    this.currentAction = null;
    this.previousAction = null;
    
    // Movement state tracking
    this.isWalking = false;
    this.isRunning = false;
    this.isJumping = false;
    this.lastPosition = new THREE.Vector3();
    this.movementSpeed = 0;
    
    // Gun state tracking
    this.isAiming = false;
    this.isShooting = false;
    
    // Animation timing - reduced for faster transitions
    this.walkBlendTime = 0.15;     // Blend between walking animations
    this.jumpBlendTime = 0.01;     // Almost immediate jump animation
    this.gunBlendTime = 0.1;       // Gun animation blend time
    
    // Animation state protection - reduced for faster responsiveness
    this.animationCooldown = 0;
    this.minAnimationCooldown = 0.2; // Reduced from 0.5 seconds
    
    // Position adjustment to prevent sinking
    this.groundOffset = -2.72; // Changed from 0 to make model feet touch the ground
    
    // Skin system
    this.activeSkin = null;
    this.availableSkins = {
      default: null, // Default texture will be stored here after loading
      bananaSkin: null // Will be loaded on demand
    };
    this.skinPermissions = {
      bananaSkin: false // By default, skin is locked until verified with NFT
    };
    
    // Load the player model
    this.loadPlayerModel();
    
    // Add to scene
    scene.add(this.group);

    // To track active hit feedback timeout
    this.hitFeedbackTimeout = null;
  }

  loadPlayerModel() {
    // Standard player model loading for all entities
    // Check if we have a preloaded player model
    if (window.preloadedModels && (window.preloadedModels.playermodel || window.preloadedModels.playermodel_clone)) {
      console.log("Using preloaded playermodel");
      try {
        // Use the clone version to avoid reference issues
        const preloadedModel = window.preloadedModels.playermodel_clone || window.preloadedModels.playermodel;
        const gltf = {
          scene: preloadedModel.scene.clone(),
          animations: preloadedModel.animations
        };
        
        this.playerModel = gltf.scene;
        
        // Position at origin with no offset to make feet touch the ground
        this.playerModel.position.set(0, 0, 0);
        
        // Set scale - increased by 70%
        this.playerModel.scale.set(1.445, 1.445, 1.445);
        
        // Rotate model to face the right direction (might need adjustment)
        this.playerModel.rotation.y = Math.PI; // Rotate 180 degrees
    
        // Add the model to the group
        this.group.add(this.playerModel);
        
        // Set up meshes correctly
        this.playerModel.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            child.userData.isPlayerMesh = true;
            
            // Ensure materials are set up correctly
            if (child.material) {
              child.material.side = THREE.DoubleSide;
              
              // If this is a skinned mesh, ensure skinning is enabled
              if (child.isSkinnedMesh) {
                child.material.skinning = true;
              }
              
              child.material.needsUpdate = true;
            }
          }
        });
        
        // Set up animations - do this after model is loaded
        if (gltf.animations && gltf.animations.length > 0) {
          // Initialize animations immediately
          this.setupAnimations(gltf.animations);
        }
        
        // Initialize hit zone visualizers
        this.createHitZoneVisualizers();
        return; // Exit early since we've handled the model
      } catch (e) {
        console.error('Error using preloaded player model:', e);
        // Fall through to regular loading method if preloaded model fails
      }
    }
    
    // Create loader instance
    const loader = new THREE.GLTFLoader();
    
    // Load the playermodel.glb model
    loader.load('models/playermodel.glb', 
      // Success callback
      (gltf) => {
        try {
          this.playerModel = gltf.scene;
          
          // Position at origin with no offset to make feet touch the ground
          this.playerModel.position.set(0, 0, 0);
          
          // Set scale - increased by 70%
          this.playerModel.scale.set(1.445, 1.445, 1.445);
          
          // Rotate model to face the right direction (might need adjustment)
          this.playerModel.rotation.y = Math.PI; // Rotate 180 degrees
      
          // Add the model to the group
          this.group.add(this.playerModel);
          
          // Set up meshes correctly
          this.playerModel.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              child.userData.isPlayerMesh = true;
              
              // Ensure materials are set up correctly
              if (child.material) {
                child.material.side = THREE.DoubleSide;
                
                // If this is a skinned mesh, ensure skinning is enabled
                if (child.isSkinnedMesh) {
                  child.material.skinning = true;
                }
                
                child.material.needsUpdate = true;
              }
            }
          });
          
          // Set up animations - do this after model is loaded
          if (gltf.animations && gltf.animations.length > 0) {
            // Initialize animations immediately
            this.setupAnimations(gltf.animations);
          }
          
          // Initialize hit zone visualizers
          this.createHitZoneVisualizers();
        } catch (e) {
          console.error('Error setting up player model:', e);
        }
      }, 
      // Progress callback - silent
      () => {},
      // Error callback
      (error) => {
        console.error('Error loading playermodel.glb model:', error);
        
        // If model fails to load, create a fallback cube
        const geometry = new THREE.BoxGeometry(0.5, 1.8, 0.5);
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(0, 0.9, 0);  // Position at center, accounting for height
        this.group.add(cube);
        
        // Add hit zone visualizers even for fallback model
        this.createHitZoneVisualizers();
      }
    );
  }

  setupAnimations(animations) {
    if (!animations || animations.length === 0) {
      return;
    }
    
    try {
      // Create animation mixer
      this.animationMixer = new THREE.AnimationMixer(this.playerModel);
      
      // Store all animations from the model
      animations.forEach(animation => {
        try {
          this.animations[animation.name] = this.animationMixer.clipAction(animation);
          
          // Configure animation properties
          this.animations[animation.name].setEffectiveTimeScale(1);
          this.animations[animation.name].setEffectiveWeight(1);
          
          // Set loop mode based on animation type
          if (animation.name === 'idle' || animation.name === 'walking' || animation.name === 'running') {
            this.animations[animation.name].setLoop(THREE.LoopRepeat);
          } else if (animation.name === 'jump' || animation.name === 'playerholstering' || 
                     animation.name === 'playershoot' || animation.name === 'death') {
            this.animations[animation.name].setLoop(THREE.LoopOnce);
            this.animations[animation.name].clampWhenFinished = true;
          } else if (animation.name === 'playeraim') {
            // Special handling for aim animation to ensure it freezes correctly
            this.animations[animation.name].setLoop(THREE.LoopOnce, 1);
            this.animations[animation.name].clampWhenFinished = true;
            
            // Pre-configure the animation to be easier to freeze at the end
            const aimAction = this.animations[animation.name];
            aimAction.zeroSlopeAtEnd = true; // Ensure smooth stop at end
            aimAction.zeroSlopeAtStart = true; // Better blending
          }
        } catch (e) {
          console.error(`Error setting up animation ${animation.name}:`, e);
        }
      });
      
      // Initialize with idle animation if available
      if (this.animations['idle']) {
        this.playAnimation('idle');
      }
    } catch (e) {
      console.error('Failed to set up animations:', e);
    }
  }

  // Cross-fade between animations with specific blend time
  fadeToAction(actionName, duration = 0.5) {
    // Don't proceed if animations aren't loaded yet
    if (!this.animations || !this.animations[actionName]) {
      return null;
    }
    
    // Don't interrupt if same animation already playing
    if (this.currentAction && this.currentAction._clip.name === actionName) {
      return this.currentAction;
    }
    
    // Get the requested animation
    const nextAction = this.animations[actionName];
    
    // Store previous action
    this.previousAction = this.currentAction;
    this.currentAction = nextAction;
    
    // If a previous action exists, cross-fade to the new action
    if (this.previousAction) {
      this.currentAction.reset();
      this.currentAction.setEffectiveWeight(1);
      this.currentAction.play();
      
      this.currentAction.crossFadeFrom(this.previousAction, duration, true);
    } else {
      // First animation - just play it
      this.currentAction.play();
    }
    
    return this.currentAction;
  }

  // Play animation with appropriate fade time
  playAnimation(animationName, customFadeTime = null) {
    let fadeTime = customFadeTime;
    
    // Set specific fade times based on animation if not explicitly provided
    if (fadeTime === null) {
      switch (animationName) {
        case 'jump':
          fadeTime = this.jumpBlendTime;
          break;
        default:
          fadeTime = this.walkBlendTime;
      }
    }
    
    // Special handling for aim animation to ensure it gets frozen properly
    if (animationName === 'playeraim') {
      const action = this.fadeToAction(animationName, fadeTime);
      
      if (action) {
        // Configure it for freezing at the end
        action.clampWhenFinished = true;
        action.setLoop(THREE.LoopOnce, 1);
        action.zeroSlopeAtEnd = true;
      }
      
      return action;
    }
    
    // Play the animation with the determined fade time
    return this.fadeToAction(animationName, fadeTime);
  }

  // Simpler directToWalking implementation
  directToWalking(isRunning = false) {
    // Prevent rapid animation changes by enforcing a cooldown
    if (this.animationCooldown > 0) {
      return;
    }
    
    // Set walking state
    this.isWalking = true;
    
    // Set animation based on speed
    if (isRunning) {
      this.isRunning = true;
      this.playAnimation('running', 0.1);
    } else {
      this.isRunning = false;
      this.playAnimation('walking', 0.1);
    }
    
    // Set cooldown to prevent immediate state changes
    this.animationCooldown = this.minAnimationCooldown;
  }

  // Simpler directToIdle implementation
  directToIdle() {
    // Prevent rapid animation changes
    if (this.animationCooldown > 0) {
      return;
    }
    
    // Only stop if we're actually walking
    if (!this.isWalking) {
      return;
    }
    
    // Mark as idle
    this.isWalking = false;
    this.isRunning = false;
    
    // Set cooldown to prevent immediate state changes
    this.animationCooldown = this.minAnimationCooldown;
    
    // Play idle animation
    this.playAnimation('idle', 0.1);
  }

  updateCollisionBox() {
    const halfWidth = this.hitboxSize.width / 2;
    const halfDepth = this.hitboxSize.depth / 2;

    this.collisionBox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - halfWidth,
        this.group.position.y,
        this.group.position.z - halfDepth
      ),
      new THREE.Vector3(
        this.group.position.x + halfWidth,
        this.group.position.y + this.hitboxSize.height,
        this.group.position.z + halfDepth
      )
    ]);
    
    // Update hit zones with exact positioning
    
    // Head hitbox (top of the model but offset downward)
    const headHalfWidth = this.headSize.width / 2;
    const headHalfDepth = this.headSize.depth / 2;
    const headHeight = this.headSize.height;
    // Position head at the top of the model with offset
    const headY = this.group.position.y + this.hitboxSize.height - headHeight - this.headOffset;
    
    this.headHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - headHalfWidth,
        headY,
        this.group.position.z - headHalfDepth
      ),
      new THREE.Vector3(
        this.group.position.x + headHalfWidth,
        headY + headHeight,
        this.group.position.z + headHalfDepth
      )
    ]);
    
    // Body hitbox (middle of the model)
    const bodyHalfWidth = this.bodySize.width / 2;
    const bodyHalfDepth = this.bodySize.depth / 2;
    const bodyHeight = this.bodySize.height;
    // Adjust body position to be just below the head with offset
    const topOfBody = headY; // Body starts where head ends
    const bodyBottom = topOfBody - bodyHeight - this.bodyOffset; // Apply the body offset
    
    this.bodyHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - bodyHalfWidth,
        bodyBottom,
        this.group.position.z - bodyHalfDepth
      ),
      new THREE.Vector3(
        this.group.position.x + bodyHalfWidth,
        topOfBody,
        this.group.position.z + bodyHalfDepth
      )
    ]);
    
    // Limbs hitbox is everything not covered by head and body
    // Create a specific limbs hitbox for arms and legs with precise sizes
    
    // Define precise limb dimensions
    const legWidth = this.bodySize.width * 0.4; // Legs are narrower than body
    const armWidth = this.bodySize.width * 0.15; // Make arms thinner
    const armExtension = 0.35; // Extend arms further out
    const armHeight = bodyHeight * 0.7; // Make arms taller (70% of body height)
    
    // Left leg hitbox
    const leftLegHitbox = new THREE.Box3();
    leftLegHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - bodyHalfWidth/2 - legWidth/2,
        this.group.position.y,
        this.group.position.z - bodyHalfDepth
      ),
      new THREE.Vector3(
        this.group.position.x - bodyHalfWidth/2 + legWidth/2,
        bodyBottom,
        this.group.position.z + bodyHalfDepth
      )
    ]);
    
    // Right leg hitbox
    const rightLegHitbox = new THREE.Box3();
    rightLegHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x + bodyHalfWidth/2 - legWidth/2,
        this.group.position.y,
        this.group.position.z - bodyHalfDepth
      ),
      new THREE.Vector3(
        this.group.position.x + bodyHalfWidth/2 + legWidth/2,
        bodyBottom,
        this.group.position.z + bodyHalfDepth
      )
    ]);
    
    // Left arm hitbox - positioned to not overlap with body
    const leftArmHitbox = new THREE.Box3();
    leftArmHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - bodyHalfWidth - armExtension, // Start outside body
        bodyBottom + bodyHeight * 0.15, // Start lower (15% up)
        this.group.position.z - bodyHalfDepth/1.5 // Narrower depth
      ),
      new THREE.Vector3(
        this.group.position.x - bodyHalfWidth, // End exactly at body edge
        bodyBottom + bodyHeight * 0.85, // End higher (85% up)
        this.group.position.z + bodyHalfDepth/1.5 // Narrower depth
      )
    ]);
    
    // Right arm hitbox - positioned to not overlap with body
    const rightArmHitbox = new THREE.Box3();
    rightArmHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x + bodyHalfWidth, // Start exactly at body edge
        bodyBottom + bodyHeight * 0.15, // Start lower
        this.group.position.z - bodyHalfDepth/1.5 // Narrower depth
      ),
      new THREE.Vector3(
        this.group.position.x + bodyHalfWidth + armExtension, // End outside body
        bodyBottom + bodyHeight * 0.85, // End higher
        this.group.position.z + bodyHalfDepth/1.5 // Narrower depth
      )
    ]);
    
    // Combine the leg and arm hitboxes for the limbs hitbox
    this.limbsHitbox.makeEmpty();
    this.limbsHitbox.union(leftLegHitbox);
    this.limbsHitbox.union(rightLegHitbox);
    this.limbsHitbox.union(leftArmHitbox);
    this.limbsHitbox.union(rightArmHitbox);
  }

  /**
   * Determines which hit zone a ray intersects with
   * @param {THREE.Ray} ray - The ray to test
   * @returns {string|null} - 'head', 'body', 'limbs', or null if no hit
   */
  getHitZone(ray) {
    // Temporary variables for intersection checks
    const invMatrix = new THREE.Matrix4();
    invMatrix.copy(this.group.matrixWorld).invert();
    
    // Transform ray to model local space
    const localRay = ray.clone();
    localRay.applyMatrix4(invMatrix);
    
    // Check for intersection with head
    if (localRay.intersectsBox(this.headHitbox)) {
      return 'head';
    }
    
    // Check for intersection with body
    if (localRay.intersectsBox(this.bodyHitbox)) {
      return 'body';
    }
    
    // Check for intersection with limbs
    if (localRay.intersectsBox(this.limbsHitbox)) {
      return 'limbs';
    }
    
    // No hit
    return null;
  }

  /**
   * Check if a bullet hit this player model and determine which zone was hit
   * @param {THREE.Vector3} bulletPos - Position of the bullet
   * @param {boolean} isShotgunPellet - Whether this is a shotgun pellet hit
   * @return {object} - Hit result with zone and damage information
   */
  checkBulletHit(bulletPos, isShotgunPellet = false) {
    // Add a small tolerance to prevent edge cases and near-miss detections
    const PRECISION_EPSILON = 0.01;
    
    // First check if bullet is clearly within the overall collision box with precision adjustment
    // This prevents false positives at the edge of the collision box
    const strictCollisionBox = this.collisionBox.clone();
    strictCollisionBox.min.add(new THREE.Vector3(PRECISION_EPSILON, PRECISION_EPSILON, PRECISION_EPSILON));
    strictCollisionBox.max.sub(new THREE.Vector3(PRECISION_EPSILON, PRECISION_EPSILON, PRECISION_EPSILON));
    
    if (!strictCollisionBox.containsPoint(bulletPos)) {
      return { hit: false, zone: null, damage: 0 };
    }
    
    // Test hitboxes in priority order (head > body > limbs)
    // A bullet can only count as hitting ONE hitbox to prevent double-counting
    
    // 1. Head check (highest damage) - most important, so check first
    const strictHeadBox = this.headHitbox.clone();
    strictHeadBox.min.add(new THREE.Vector3(PRECISION_EPSILON, PRECISION_EPSILON, PRECISION_EPSILON));
    strictHeadBox.max.sub(new THREE.Vector3(PRECISION_EPSILON, PRECISION_EPSILON, PRECISION_EPSILON));
    
    if (strictHeadBox.containsPoint(bulletPos)) {
      // Apply appropriate damage based on weapon type
      const damage = isShotgunPellet ? 10 : 100;
      return { hit: true, zone: 'head', damage: damage };
    }
    
    // 2. Body check (medium damage)
    const strictBodyBox = this.bodyHitbox.clone();
    strictBodyBox.min.add(new THREE.Vector3(PRECISION_EPSILON, PRECISION_EPSILON, PRECISION_EPSILON));
    strictBodyBox.max.sub(new THREE.Vector3(PRECISION_EPSILON, PRECISION_EPSILON, PRECISION_EPSILON));
    
    if (strictBodyBox.containsPoint(bulletPos)) {
      // Apply appropriate damage based on weapon type
      const damage = isShotgunPellet ? 5 : 40;
      return { hit: true, zone: 'body', damage: damage };
    }
    
    // 3. Limbs check - we need to check each limb individually to prevent overlap issues
    
    // Create strict boxes for each individual limb
    const leftLegHitbox = new THREE.Box3();
    leftLegHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - this.bodySize.width/4 - this.bodySize.width * 0.2,
        this.group.position.y + PRECISION_EPSILON,
        this.group.position.z - this.bodySize.depth/2 + PRECISION_EPSILON
      ),
      new THREE.Vector3(
        this.group.position.x - this.bodySize.width/4 + this.bodySize.width * 0.2,
        this.bodyHitbox.min.y - PRECISION_EPSILON,
        this.group.position.z + this.bodySize.depth/2 - PRECISION_EPSILON
      )
    ]);
    
    const rightLegHitbox = new THREE.Box3();
    rightLegHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x + this.bodySize.width/4 - this.bodySize.width * 0.2,
        this.group.position.y + PRECISION_EPSILON,
        this.group.position.z - this.bodySize.depth/2 + PRECISION_EPSILON
      ),
      new THREE.Vector3(
        this.group.position.x + this.bodySize.width/4 + this.bodySize.width * 0.2,
        this.bodyHitbox.min.y - PRECISION_EPSILON,
        this.group.position.z + this.bodySize.depth/2 - PRECISION_EPSILON
      )
    ]);
    
    const leftArmHitbox = new THREE.Box3();
    leftArmHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - this.bodySize.width/2 - this.bodySize.width * 0.175,
        this.bodyHitbox.min.y + this.bodySize.height * 0.15 + PRECISION_EPSILON,
        this.group.position.z - this.bodySize.depth/3 + PRECISION_EPSILON
      ),
      new THREE.Vector3(
        this.group.position.x - this.bodySize.width/2 + PRECISION_EPSILON,
        this.bodyHitbox.min.y + this.bodySize.height * 0.85 - PRECISION_EPSILON,
        this.group.position.z + this.bodySize.depth/3 - PRECISION_EPSILON
      )
    ]);
    
    const rightArmHitbox = new THREE.Box3();
    rightArmHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x + this.bodySize.width/2 - PRECISION_EPSILON,
        this.bodyHitbox.min.y + this.bodySize.height * 0.15 + PRECISION_EPSILON,
        this.group.position.z - this.bodySize.depth/3 + PRECISION_EPSILON
      ),
      new THREE.Vector3(
        this.group.position.x + this.bodySize.width/2 + this.bodySize.width * 0.175,
        this.bodyHitbox.min.y + this.bodySize.height * 0.85 - PRECISION_EPSILON,
        this.group.position.z + this.bodySize.depth/3 - PRECISION_EPSILON
      )
    ]);
    
    // Check each limb individually
    if (leftLegHitbox.containsPoint(bulletPos)) {
      const damage = isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    if (rightLegHitbox.containsPoint(bulletPos)) {
      const damage = isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    if (leftArmHitbox.containsPoint(bulletPos)) {
      const damage = isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    if (rightArmHitbox.containsPoint(bulletPos)) {
      const damage = isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    // If we're here, the bullet is inside the overall collision box but not in any specific zone
    // Instead of returning no hit, we'll count it as a partial body hit with reduced damage
    const damage = isShotgunPellet ? 5 : 30;
    return { hit: true, zone: 'body', damage: damage };
  }

  /**
   * Smoothly updates the model's position and rotation toward target values.
   * @param {number} deltaTime - Time elapsed since last frame.
   */
  animateMovement(deltaTime) {
    // Ensure the model is visible
    if (this.playerModel) {
      this.playerModel.visible = true;
    }
    
    // Store position before movement for walking detection
    this.lastPosition.copy(this.group.position);
    
    // Special handling for when we're in a frozen aim pose
    if (this.isAiming && !this.isShooting && !this.isJumping && this._aimPoseSnapshot) {
      // Skip the animation mixer update entirely and just apply the saved pose
      this.maintainAimPose();
    } 
    // Regular animation updates for all other states
    else if (this.animationMixer && deltaTime > 0 && deltaTime < 1) {
      try {
        this.animationMixer.update(deltaTime);
        
        // If we need to aim but don't have a snapshot yet, create one
        if (this.isAiming && !this.isShooting && !this.isJumping && !this._aimPoseSnapshot) {
          this.maintainAimPose();
        }
      } catch (e) {
        console.warn("Error updating animation mixer:", e);
      }
    }
    
    // Normal interpolation for network movement
    this.group.position.lerp(this.targetPosition, 0.1);
    
    // Rotate the model
    this.group.rotation.y = THREE.MathUtils.lerp(this.group.rotation.y, this.targetRotation, 0.1);
    
    // Update cooldown timer
    if (this.animationCooldown > 0) {
      this.animationCooldown -= deltaTime;
      if (this.animationCooldown < 0) {
        this.animationCooldown = 0;
      }
    }
    
    // Update collision box
    this.updateCollisionBox();
  }

  /**
   * Updates the third-person model using data received from the server.
   * @param {Object} playerData
   */
  update(playerData) {
    if (!playerData) return;
    
    // Skip animation updates if animations aren't loaded yet
    const animationsLoaded = this.animations && Object.keys(this.animations).length > 0;
    
    // Handle death animation if the player is dying
    if (animationsLoaded && playerData.isDying && !this.isDying) {
      console.log(`Playing death animation for remote player ${this.playerId}`);
      this.playDeathAnimation();
      // Don't process any other animation states after playing death animation
      return;
    }
    
    // Handle jump animation first to ensure immediacy
    if (animationsLoaded && playerData.velocity && playerData.velocity.y > 2.5 && !this.isJumping) {
      this.playJumpAnimation();
    }

    // Handle landing from jump
    if (this.isJumping && (!playerData.velocity || playerData.velocity.y <= 0.1)) {
      this.isJumping = false;
    }
    
    // Special handling for aim state - we only want to process animation transitions
    // when there is an actual change in the aiming state
    if (animationsLoaded && !this.isJumping) {
      // Track if the aiming state has changed
      const wasAiming = this.isAiming;
      const isAimingNow = playerData.isAiming;
      
      // We only need to handle aim animation transitions when the state actually changes
      // or when we need to handle shooting while already aiming
      
      // Handle shooting animation - prioritize shooting over aim changes
      if (isAimingNow && playerData.isShooting && !this.isShooting) {
        this.playShootAnimation();
      }
      // Handle aiming animation start - only when state changes from not aiming to aiming
      else if (isAimingNow && !wasAiming) {
        this.playAimAnimation();
      }
      // Handle holstering animation - only when state changes from aiming to not aiming
      else if (!isAimingNow && wasAiming) {
        this.playHolsterAnimation();
      }
      // Maintain aim state - but don't restart the animation if already aiming
      else if (isAimingNow && wasAiming) {
        // If we have a snapshot, make sure it's applied
        if (this._aimPoseSnapshot) {
          // No need to call maintainAimPose() here as it will be called in animateMovement
        }
        // If we don't have a snapshot yet but should be aiming, create one
        else if (!this._aimPoseSnapshot && isAimingNow) {
          this.maintainAimPose();
        }
      }
    }
    
    // Update target position from network data
    if (playerData.position) {
      // Position the model on the ground, with appropriate height adjustment
      const newPos = new THREE.Vector3(
        playerData.position.x,
        playerData.position.y + this.groundOffset,
        playerData.position.z
      );
      
      // Calculate distance before updating position
      const distance = newPos.distanceTo(this.targetPosition);
      
      // Only update if movement is significant (prevents jitter)
      if (distance > 0.01) {
        this.targetPosition.copy(newPos);
      }

      // Only process animation transitions if animations are loaded
      // and we're not in a special state (aiming/shooting/jumping)
      if (animationsLoaded && !this.isJumping && !this.isAiming && !this.isShooting) {
        // Check if moving based on position change or explicit walking flag
        const isMovingNow = distance > 0.03;
        
        const isRunningNow = distance > 0.2;
        
        // Handle animation state transitions
        if (isMovingNow) {
          if (!this.isWalking) {
            // Start walking or running based on speed
            this.directToWalking(isRunningNow);
          } else {
            // Switch between walking and running based on speed
            if (isRunningNow && !this.isRunning) {
              this.isRunning = true;
              this.playAnimation('running', 0.1); 
            } else if (!isRunningNow && this.isRunning) {
              this.isRunning = false;
              this.playAnimation('walking', 0.1);
            }
          }
        } else if (!isMovingNow && this.isWalking) {
          // Transition directly to idle if not moving
          this.directToIdle();
        }
      }
    }

    // Update target rotation (with default value if missing)
    if (playerData.rotation !== undefined) {
      // For network data, rotation is typically just a y rotation value
      if (typeof playerData.rotation === 'number') {
        this.targetRotation = playerData.rotation;
      } 
      // Handle case where rotation might be an object with a y property
      else if (playerData.rotation && playerData.rotation.y !== undefined) {
        this.targetRotation = playerData.rotation.y;
      }
    }
    
    // Handle skin updates - only when skin data changes
    if (playerData.skins && (!this._lastSkinUpdate || JSON.stringify(playerData.skins) !== JSON.stringify(this._lastSkinUpdate))) {
      // Store current skin data to prevent redundant updates
      this._lastSkinUpdate = JSON.stringify(playerData.skins);
      
      // Update permissions
      this.updateSkinPermissions(playerData.skins);
      
      // Apply banana skin automatically if permission granted and not already applied
      if (playerData.skins.bananaSkin && this.activeSkin !== 'bananaSkin') {
        this.updateSkin('bananaSkin');
      }
    }
    // Force skin application during first update if it hasn't been applied yet
    else if (playerData.skins && playerData.skins.bananaSkin && !this._initialSkinApplied && this.activeSkin !== 'bananaSkin') {
      this._initialSkinApplied = true;
      this.updateSkin('bananaSkin');
      console.log(`Applied initial skin to player ${this.playerId} during first update`);
    }
  }

  /**
   * Removes the model from the scene (e.g. on player disconnect).
   * Fully disposes geometry and material.
   */
  remove() {
    this.scene.remove(this.group);
    this.group.traverse(child => {
      if (child.isMesh) {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(mat => mat.dispose());
          } else {
            child.material.dispose();
          }
        }
      }
    });
  }

  /**
   * Provides visual feedback (temporary red flash) when the model is hit.
   */
  showHitFeedback() {
    // Clear any existing hit feedback timeout
    if (this.hitFeedbackTimeout) {
      clearTimeout(this.hitFeedbackTimeout);
    }
    
    // Traverse the model and replace each mesh's material with a red flash
    this.group.traverse(child => {
      if (child.isMesh && child.material) {
        // Store the original material in userData if not already stored
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        
        // Create a new material for the flash effect
        const flashMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        
        // If this is a skinned mesh, enable skinning on the material
        if (child.isSkinnedMesh) {
          flashMaterial.skinning = true;
        }
        
        // Apply the flash material
        child.material = flashMaterial;
        child.material.needsUpdate = true;
      }
    });
    
    // After 200ms, restore the original materials
    this.hitFeedbackTimeout = setTimeout(() => {
      this.group.traverse(child => {
        if (child.isMesh && child.userData.originalMaterial) {
          child.material.dispose();
          child.material = child.userData.originalMaterial;
          child.material.needsUpdate = true;
          delete child.userData.originalMaterial;
        }
      });
      this.hitFeedbackTimeout = null;
    }, 200);
  }

  /**
   * Reduces health when hit.
   * @param {number} amount - Damage amount.
   * @param {string} hitZone - The hit zone ('head', 'body', 'limbs')
   */
  takeDamage(amount, hitZone = 'body') {
    if (typeof amount !== 'number' || isNaN(amount)) {
      console.error(`Invalid damage amount: ${amount}`);
      amount = 20; // Default to 20 damage if invalid
    }

    // Ensure health is initialized before reducing
    if (typeof this.health !== 'number' || isNaN(this.health)) {
      this.health = 100;
    }
    
    // Apply damage
    this.health = Math.max(this.health - amount, 0);
    
    // Show hit feedback
    this.showHitFeedback();
    
    console.log(`Remote player ${this.playerId} took ${amount} damage to ${hitZone}. Health: ${this.health}`);
    
    // Check for death
    if (this.health <= 0 && !this.isDying) {
      console.log(`Remote player ${this.playerId} died from damage`);
      this.playDeathAnimation();
    }
  }

  /**
   * Creates visual helpers for the hit zones (for debugging)
   * Call this method to see the hit zones visually
   * @param {boolean} forceVisible - Override default visibility setting
   */
  createHitZoneVisualizers(forceVisible = null) {
    const hitZoneVisible = forceVisible !== null ? forceVisible : false;
    
    if (!hitZoneVisible) return;
    
    // Clean up any existing helpers
    if (this.headHelper) this.group.remove(this.headHelper);
    if (this.bodyHelper) this.group.remove(this.bodyHelper);
    if (this.leftLegHelper) this.group.remove(this.leftLegHelper);
    if (this.rightLegHelper) this.group.remove(this.rightLegHelper);
    
    // Remove arm helpers and limbs helper if they exist
    if (this.leftArmHelper) this.group.remove(this.leftArmHelper);
    if (this.rightArmHelper) this.group.remove(this.rightArmHelper);
    if (this.limbsHelper) this.group.remove(this.limbsHelper);
    
    // Materials for different hitboxes
    const headMaterial = new THREE.MeshBasicMaterial({
      color: 0xff0000, // Red for head
      wireframe: true,
      transparent: true,
      opacity: 0.8
    });
    
    const bodyMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ff00, // Green for body
      wireframe: true,
      transparent: true,
      opacity: 0.8
    });
    
    const legMaterial = new THREE.MeshBasicMaterial({
      color: 0x8800ff, // Purple for legs
      wireframe: true,
      transparent: true,
      opacity: 0.7
    });
    
    // Head helper - adjusted with offset
    const headGeometry = new THREE.BoxGeometry(
      this.headSize.width,
      this.headSize.height,
      this.headSize.depth
    );
    this.headHelper = new THREE.Mesh(headGeometry, headMaterial);
    this.headHelper.position.set(
      0,
      this.hitboxSize.height - this.headSize.height/2 - this.headOffset,
      0
    );
    this.group.add(this.headHelper);
    
    // Body helper with offset
    const bodyGeometry = new THREE.BoxGeometry(
      this.bodySize.width,
      this.bodySize.height,
      this.bodySize.depth
    );
    this.bodyHelper = new THREE.Mesh(bodyGeometry, bodyMaterial);
    
    // Position body below head with offset
    const headBottom = this.hitboxSize.height - this.headSize.height - this.headOffset;
    const bodyTop = headBottom;
    const bodyBottom = bodyTop - this.bodySize.height - this.bodyOffset;
    const bodyCenter = (bodyTop + bodyBottom) / 2;
    
    this.bodyHelper.position.set(
      0,
      bodyCenter,
      0
    );
    this.group.add(this.bodyHelper);
    
    // Create precise limb helpers matching our collision detection
    // Define precise limb dimensions - same as in updateCollisionBox
    const legWidth = this.bodySize.width * 0.4;
    
    // Left leg helper
    const leftLegGeometry = new THREE.BoxGeometry(
      legWidth,
      bodyBottom, // Height from ground to bottom of body
      this.bodySize.depth
    );
    this.leftLegHelper = new THREE.Mesh(leftLegGeometry, legMaterial);
    this.leftLegHelper.position.set(
      -this.bodySize.width/4, // Center of left leg
      bodyBottom/2, // Middle of leg
      0
    );
    this.group.add(this.leftLegHelper);
    
    // Right leg helper
    const rightLegGeometry = new THREE.BoxGeometry(
      legWidth,
      bodyBottom,
      this.bodySize.depth
    );
    this.rightLegHelper = new THREE.Mesh(rightLegGeometry, legMaterial);
    this.rightLegHelper.position.set(
      this.bodySize.width/4, // Center of right leg
      bodyBottom/2,
      0
    );
    this.group.add(this.rightLegHelper);
  }

  // Play the aiming animation when player draws their gun
  playAimAnimation() {
    // Prevent rapid animation changes
    if (this.animationCooldown > 0) {
      return null;
    }
    
    this.isAiming = true;
    this.animationCooldown = this.minAnimationCooldown;
    
    const aimAction = this.playAnimation('playeraim', this.gunBlendTime);
    
    // If we successfully got the animation, set up to stay on the last frame
    if (aimAction && aimAction._clip) {
      const duration = aimAction._clip.duration;
      
      // After the aiming animation completes, freeze on the last frame
      setTimeout(() => {
        // If still aiming, make sure we're showing the last frame
        if (this.isAiming && !this.isShooting) {
          // Manually set to the end frame to show the gun aimed
          if (this.animations['playeraim']) {
            const aimAction = this.animations['playeraim'];
            
            // Ensure set to the end frame and frozen
            aimAction.reset();
            aimAction.time = aimAction._clip.duration - 0.01;
            aimAction.timeScale = 0; // Completely stop time advancement
            aimAction.enabled = true;
            aimAction.setEffectiveWeight(1);
            aimAction.clampWhenFinished = true;
            aimAction.setLoop(THREE.LoopOnce, 1); // Ensure it's set to loop once
            aimAction.paused = true; // Pause the action to prevent any updates
            aimAction.play();
            
            this.currentAction = aimAction;
          }
        }
      }, duration * 1000);
    }
    
    return aimAction;
  }
  
  // Maintain the aim pose at the last frame of the animation
  maintainAimPose() {
    // Only proceed if we have loaded animations and the playeraim animation exists
    if (!this.animations || !this.animations['playeraim']) return;
    
    const aimAction = this.animations['playeraim'];
    
    // If we don't have a snapshot yet, create one
    if (!this._aimPoseSnapshot) {
      // Stop all current actions to prevent interference
      this.animationMixer.stopAllAction();
      
      // Reset and prepare the aim action to capture the final pose
      aimAction.reset();
      aimAction.clampWhenFinished = true;
      aimAction.setLoop(THREE.LoopOnce, 1);
      aimAction.timeScale = 1; // Normal speed for setup
      aimAction.time = 0; // Start from beginning
      aimAction.enabled = true;
      aimAction.setEffectiveWeight(1);
      aimAction.play();
      
      // Skip to the end of the animation to capture final pose
      aimAction.time = aimAction._clip.duration - 0.01;
      
      // Force an update to apply the pose to the bones
      this.animationMixer.update(0);
      
      // Save a snapshot of all bone matrices in the model
      this._aimPoseSnapshot = {};
      this.playerModel.traverse(child => {
        if (child.isBone) {
          // Save position, rotation, scale for more accurate restoration
          this._aimPoseSnapshot[child.uuid] = {
            position: child.position.clone(),
            quaternion: child.quaternion.clone(),
            scale: child.scale.clone(),
            matrix: child.matrix.clone(),
            matrixWorld: child.matrixWorld.clone()
          };
        }
      });
      
      // Stop the animation to prevent further updates
      aimAction.stop();
      
      console.log(`Created detailed aim pose snapshot for player ${this.playerId}`);
      
      // Set the current action to aim so we know what state we're in
      this.currentAction = aimAction;
      this.isAiming = true;
    }
    
    // Apply the saved pose each frame to ensure it stays frozen
    if (this._aimPoseSnapshot) {
      this.playerModel.traverse(child => {
        if (child.isBone && this._aimPoseSnapshot[child.uuid]) {
          const snapshot = this._aimPoseSnapshot[child.uuid];
          
          // Apply the saved transform data directly
          child.position.copy(snapshot.position);
          child.quaternion.copy(snapshot.quaternion);
          child.scale.copy(snapshot.scale);
          child.matrix.copy(snapshot.matrix);
          
          // Also set the matrixWorld to ensure correct global pose
          child.matrixWorld.copy(snapshot.matrixWorld);
          
          // Ensure matrices are updated
          child.updateMatrix();
          child.updateMatrixWorld(true);
        }
      });
    }
  }
  
  // Play the jump animation
  playJumpAnimation() {
    // Interrupt any current animation for immediate jump
    this.isJumping = true;
    this.isWalking = false;
    this.isRunning = false;
    
    // Force immediate transition to jump
    this.animationCooldown = 0;
    const jumpAction = this.playAnimation('jump', 0.01);
    
    // Only proceed with timing if we successfully got the animation
    if (jumpAction && jumpAction._clip) {
      // Reset to walking or idle after jump animation completes
      const duration = jumpAction._clip.duration;
      
      // Shorten the jump animation to match faster gravity
      const adjustedDuration = duration * 0.8; // 20% shorter for quicker landing
      
      // Set immediate state transition when landing
      setTimeout(() => {
        if (this.isJumping) {
          this.isJumping = false;
          // Check if the player was moving before jumping
          const wasMoving = this.group.position.distanceTo(this.targetPosition) > 0.03; // Reduced from 0.05
          if (wasMoving) {
            this.isWalking = true;
            this.playAnimation('walking', 0.05);
            // Check if should be running with higher threshold
            if (this.group.position.distanceTo(this.targetPosition) > 0.2) { // Reduced from 0.3
              this.isRunning = true;
              this.playAnimation('running', 0.05);
            }
          } else {
            this.playAnimation('idle', 0.05);
          }
        }
      }, adjustedDuration * 1000);
    } else {
      // Fallback if jump animation fails
      setTimeout(() => {
        this.isJumping = false;
      }, 700); // Reduced from 1000ms to match faster jump
    }
  }
  
  // Play the holstering animation when player stops aiming
  playHolsterAnimation() {
    // Prevent rapid animation changes
    if (this.animationCooldown > 0) {
      return null;
    }
    
    this.isAiming = false;
    this.isShooting = false;
    this.animationCooldown = this.minAnimationCooldown;
    
    // Clear any aim pose snapshot when transitioning to holstering
    this._aimPoseSnapshot = null;
    
    return this.playAnimation('playerholstering', this.gunBlendTime);
  }
  
  // Play the shooting animation
  playShootAnimation() {
    // Prevent rapid animation changes
    if (this.animationCooldown > 0) {
      return null;
    }
    
    this.isShooting = true;
    this.animationCooldown = this.minAnimationCooldown;
    
    // Clear aim pose snapshot during shooting
    this._aimPoseSnapshot = null;
    
    // IMPORTANT: NO SOUNDS are played here!
    // All gunshot sounds are centrally managed in main.js to prevent duplication
    // This is especially critical for mobile devices which can have audio sync issues
    
    const shootAction = this.playAnimation('playershoot', this.gunBlendTime);
    
    // If we successfully got the animation, set up the transition back to aim
    if (shootAction && shootAction._clip) {
      const duration = shootAction._clip.duration;
      
      // After the shooting animation completes, return to aim
      setTimeout(() => {
        this.isShooting = false;
        
        // If still aiming, create a new aim pose snapshot
        if (this.isAiming) {
          // Clear any existing snapshot so we can create a fresh one
          this._aimPoseSnapshot = null;
          this.maintainAimPose();
        }
      }, duration * 1000);
    }
    
    return shootAction;
  }
  
  // Play the death animation when player is killed
  playDeathAnimation() {
    // Set death state
    this.isDying = true;
    
    // Reset other animation states
    this.isAiming = false;
    this.isShooting = false;
    this.isWalking = false;
    this.isRunning = false;
    this.isJumping = false;
    
    // Play the death animation with fast transition
    const deathAction = this.playAnimation('death', 0.1);
    
    // Return the action and its duration if available
    if (deathAction && deathAction._clip) {
      return {
        action: deathAction,
        duration: deathAction._clip.duration * 1000 // Duration in milliseconds
      };
    }
    
    // Return a default duration if animation couldn't be played
    return {
      action: null,
      duration: 1500 // Default fallback duration in milliseconds
    };
  }

  /**
   * Resets all animation states - useful when respawning or between matches
   */
  resetAnimationState() {
    console.log(`Resetting animation state for player ${this.playerId}`);
    
    // Reset all animation state flags
    this.isDying = false;
    this.isAiming = false;
    this.isShooting = false;
    this.isWalking = false;
    this.isRunning = false;
    this.isJumping = false;
    
    // Clear aim pose snapshot
    this._aimPoseSnapshot = null;
    
    // Stop all active animations and reset mixer
    if (this.animationMixer) {
      this.animationMixer.stopAllAction();
    }
    
    // Reset all animations
    if (this.animations) {
      for (const name in this.animations) {
        const action = this.animations[name];
        if (action) {
          action.reset();
          if (action.isRunning()) {
            action.stop();
          }
        }
      }
    }
    
    // Reset current and previous actions
    this.currentAction = null;
    this.previousAction = null;
    
    // Play idle animation if available
    if (this.animations && this.animations['idle']) {
      this.playAnimation('idle', 0.1);
    }
  }

  /**
   * Disposes of all resources
   */
  dispose() {
    // First reset animation state
    this.resetAnimationState();
    
    // Remove all models
    if (this.playerModel) {
      this.group.remove(this.playerModel);
    }
    
    // Remove any helpers
    if (this.headHelper) this.group.remove(this.headHelper);
    if (this.bodyHelper) this.group.remove(this.bodyHelper);
    if (this.leftArmHelper) this.group.remove(this.leftArmHelper);
    if (this.rightArmHelper) this.group.remove(this.rightArmHelper);
    if (this.leftLegHelper) this.group.remove(this.leftLegHelper);
    if (this.rightLegHelper) this.group.remove(this.rightLegHelper);
    
    // Remove from scene
    if (this.group.parent) {
      this.group.parent.remove(this.group);
    }
  }

  /**
   * Updates the model's skin based on skin ID
   * @param {string} skinId - The skin ID to apply
   * @returns {boolean} - Whether the skin was successfully applied
   */
  updateSkin(skinId) {
    // Check if this is a valid skin
    if (!skinId || !this.availableSkins.hasOwnProperty(skinId)) {
      console.warn(`Invalid skin ID: ${skinId}`);
      return false;
    }
    
    // Check if player has permission for this skin
    if (skinId !== 'default' && !this.skinPermissions[skinId]) {
      console.warn(`Player ${this.playerId} does not have permission for skin: ${skinId}`);
      return false;
    }
    
    // Check if model is loaded before attempting to apply skins
    if (!this.playerModel) {
      console.warn(`Cannot apply skin - player model not loaded yet for player ${this.playerId}`);
      // Schedule another attempt after a short delay
      setTimeout(() => {
        if (this.playerModel) {
          console.log(`Retrying skin application for player ${this.playerId}`);
          this.updateSkin(skinId);
        }
      }, 500);
      return false;
    }
    
    // TEMPORARY: Debug the model structure to help identify meshes and materials
    this._debugModelStructure();
    
    // Check if the texture was already loaded for this skin
    if (!this.availableSkins[skinId]) {
      // Load the skin texture
      this.loadSkinTexture(skinId);
      return false; // Will be applied once loaded
    }
    
    // Apply the skin texture to the model
    this.applyTextureToModel(this.availableSkins[skinId]);
    this.activeSkin = skinId;
    
    console.log(`Applied skin '${skinId}' to player ${this.playerId}`);
    return true;
  }
  
  /**
   * TEMPORARY: Debug helper to print model hierarchy and materials
   * @private
   */
  _debugModelStructure() {
    if (!this.playerModel) return;
    
    console.log(`=== DEBUG: Model structure for player ${this.playerId} ===`);
    let meshCount = 0;
    let skinnedMeshCount = 0;
    let materialCount = 0;
    
    this.playerModel.traverse(child => {
      if (child.isMesh) {
        meshCount++;
        if (child.isSkinnedMesh) skinnedMeshCount++;
        
        console.log(`Mesh: ${child.name}`);
        
        if (child.material) {
          materialCount++;
          console.log(`  Material: ${child.material.name || 'unnamed'}`);
          console.log(`  Has map: ${child.material.map ? 'YES' : 'NO'}`);
          console.log(`  Side: ${child.material.side}`);
          if (child.isSkinnedMesh) {
            console.log(`  Skinning enabled: ${child.material.skinning ? 'YES' : 'NO'}`);
          }
        }
      }
    });
    
    console.log(`Total meshes: ${meshCount}, Skinned meshes: ${skinnedMeshCount}, Materials: ${materialCount}`);
    console.log(`=== END DEBUG ===`);
  }
  
  /**
   * Loads a skin texture by ID
   * @param {string} skinId - The skin ID to load
   */
  loadSkinTexture(skinId) {
    if (!skinId || skinId === 'default') return;
    
    const texturePath = `models/textures/${skinId}.png`;
    const textureLoader = new THREE.TextureLoader();
    
    // Store that we have permission before the async load starts
    const hasPermission = this.skinPermissions[skinId];
    
    console.log(`Loading skin texture for playermodel: ${texturePath}`);
    
    textureLoader.load(
      texturePath,
      (texture) => {
        console.log(`Successfully loaded texture: ${texturePath}`, texture);
        
        // Store the loaded texture
        this.availableSkins[skinId] = texture;
        
        // Use the stored permission value rather than checking again
        // This prevents race conditions where permissions might change during load
        if (hasPermission) {
          this.applyTextureToModel(texture);
          this.activeSkin = skinId;
          console.log(`Applied newly loaded skin '${skinId}' to player ${this.playerId}`);
        } else {
          console.log(`Texture loaded but not applied - no permission for skin: ${skinId}`);
        }
      },
      (progressEvent) => {
        console.log(`Texture loading progress: ${progressEvent.loaded} / ${progressEvent.total}`);
      },
      (error) => {
        console.error(`Error loading skin texture '${skinId}':`, error);
      }
    );
  }
  
  /**
   * Applies a texture to the player model
   * @param {THREE.Texture} texture - The texture to apply
   */
  applyTextureToModel(texture) {
    if (!this.playerModel || !texture) return;
    
    // List of revolver part names to look for (with different variations to match all cases)
    const revolverParts = ['barrel', 'drum', 'grip', 'revolver', 'gun', 'barrel.001', 'drum.001', 'grip.001'];
    
    // Count how many parts we modify for a single summary log instead of per-part logs
    let modifiedPartsCount = 0;
    
    // Debug mode to log all mesh names and material names to help identify parts
    const debugMode = false;
    
    // Apply the texture to all relevant meshes in the model
    this.playerModel.traverse(child => {
      if (child.isMesh && child.material) {
        if (debugMode) {
          console.log(`Found mesh: ${child.name} with material: ${child.material.name || 'unnamed'}`);
        }
        
        // Use Material.003 as primary check, but also check for revolver part names
        const isRevolverMaterial = child.material.name && child.material.name.includes('Material.003');
        const isRevolverPart = revolverParts.some(part => 
          child.name.toLowerCase().includes(part.toLowerCase())
        );
        
        // Also check for gun parts by looking at Pistol parts
        const isPistolPart = child.name.toLowerCase().includes('pistol');
        
        // Extra check for model materials that might be eligible for skins
        const isEligibleMaterial = child.material.name && 
          (child.material.name.includes('gun') || 
           child.material.name.includes('pistol') || 
           child.material.name.includes('revolver'));
        
        if (isRevolverMaterial || isRevolverPart || isPistolPart || isEligibleMaterial) {
          // Increment counter
          modifiedPartsCount++;
          
          // Store the original/default texture if not already stored
          if (!this.availableSkins.default && child.material.map) {
            this.availableSkins.default = child.material.map.clone();
          }
          
          // Clone the original material to preserve all properties
          if (child.material._originalMaterial === undefined) {
            child.material._originalMaterial = child.material.clone();
          }
          
          // Proper creation of new texture - maintaining UVs
          if (child.material._originalMaterial && child.material._originalMaterial.map) {
            const originalTexture = child.material._originalMaterial.map;
            
            // Copy ALL texture properties
            texture.wrapS = originalTexture.wrapS;
            texture.wrapT = originalTexture.wrapT;
            texture.repeat.copy(originalTexture.repeat);
            texture.offset.copy(originalTexture.offset);
            texture.center.copy(originalTexture.center);
            texture.rotation = originalTexture.rotation;
            
            // Copy any additional properties that might affect UV mapping
            texture.flipY = originalTexture.flipY;
            texture.encoding = originalTexture.encoding;
            
            // Handle mipmaps and filtering
            texture.generateMipmaps = originalTexture.generateMipmaps;
            texture.minFilter = originalTexture.minFilter;
            texture.magFilter = originalTexture.magFilter;
            
            // Also ensure texture is fully loaded before applying
            texture.needsUpdate = true;
          }
          
          // Apply the new texture
          child.material.map = texture;
          child.material.needsUpdate = true;
          
          if (debugMode) {
            console.log(`Applied texture to part: ${child.name}`);
          }
        }
      }
    });
    
    // Single summary log instead of multiple per-part logs
    if (modifiedPartsCount > 0) {
      console.log(`Applied texture to ${modifiedPartsCount} player model parts for player ${this.playerId}`);
    } else {
      console.warn(`No suitable parts found to apply texture for player ${this.playerId}`);
    }
  }
  
  /**
   * Updates skin permissions based on server data
   * @param {Object} skinData - Skin permission data from server
   */
  updateSkinPermissions(skinData) {
    if (!skinData) return;
    
    let skinChanged = false;
    
    // Update permissions for each skin
    Object.keys(skinData).forEach(skinId => {
      if (this.skinPermissions.hasOwnProperty(skinId)) {
        const oldPermission = this.skinPermissions[skinId];
        const newPermission = skinData[skinId];
        
        this.skinPermissions[skinId] = newPermission;
        
        // If permission was granted, preload the skin
        if (!oldPermission && newPermission) {
          this.loadSkinTexture(skinId);
          skinChanged = true;
        }
      }
    });
    
    // If permission changes might affect current skin, check if we need to reset
    if (skinChanged && this.activeSkin && !this.skinPermissions[this.activeSkin]) {
      // Reset to default skin if current skin is no longer permitted
      this.updateSkin('default');
    }
  }
}

================================================
File: /public/js/scene.js
================================================
// /public/js/scene.js
export let scene;
import { DesertTerrain } from './desertTerrain.js';
import { TumbleweedManager } from './tumbleweed.js';

// Adding skybox references for animation
let skyMesh;
let groundMesh;
const SKYBOX_ROTATION_SPEED = 0.00001; // Much slower rotation speed

// Add tumbleweed manager
let tumbleweedManager;

// Add train animation components
let train;
let trainPath;
let trainProgress = 0;
// Time-based train tracking
let trainStartTime = 0; // Global reference time when train started
let trainCycleTime = 0; // Time in ms for a full one-way trip
let trainSpeed = 0.0003; // Speed received from server
let trainTrackLength = 2000; // Track length (matching server)
let trainDirection = 1; // Current direction

// Position the track along Z axis
const TRAIN_TRACK_START = new THREE.Vector3(0, 0, -1000);
const TRAIN_TRACK_END = new THREE.Vector3(0, 0, 1000);

// Flag to control if train has been initialized from server
let trainInitialized = false;
let trainLogMessages = true; // Control train update logs

// Make train track endpoints globally available for terrain system
window.TRAIN_TRACK_START = TRAIN_TRACK_START;
window.TRAIN_TRACK_END = TRAIN_TRACK_END;

// Add texture state tracking
const texturesLoaded = {
  skyLoaded: false,
  groundLoaded: false,
  skyAttempts: 0,
  groundAttempts: 0
};

// Track FPS updates
let fpsUpdateCounter = 0;

/**
 * Initializes the Three.js scene, camera, and renderer.
 * @returns {Object} - Contains the camera and renderer.
 */
export function initScene() {
  scene = new THREE.Scene();
  
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  // Set output encoding for consistent lighting and color reproduction.
  renderer.outputEncoding = THREE.sRGBEncoding;

  const gameContainer = document.getElementById('game-container');
  if (!gameContainer) {
    throw new Error("Game container not found in HTML.");
  }
  gameContainer.appendChild(renderer.domElement);

  // Initialize with a desert sand color instead of blue
  scene.background = new THREE.Color(0xec9e5c);
  
  // Preload textures before creating skybox
  THREE.Cache.enabled = true;
  // Start loading skybox immediately
  preloadSkyboxTextures(() => {
    // Load the two skybox parts after preloading
    loadTwoPartSkybox();
  });
  
  // Change fog color to match desert colors instead of blue
  const desertFogColor = new THREE.Color(0xec9e5c); // Desert sand color
  scene.fog = new THREE.Fog(desertFogColor, 250, 900); // Increased fog distances

  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );

  // Increase ambient light intensity and warm it up to match desert environment
  const ambientLight = new THREE.AmbientLight(0xffebc8, 0.6);
  scene.add(ambientLight);

  // Adjust directional light to be softer and more diffused for desert environment
  const directionalLight = new THREE.DirectionalLight(0xffffb3, 1.0);
  directionalLight.position.set(1, 1.2, 0.5).normalize();
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  directionalLight.shadow.radius = 3; // Add shadow blur for softer shadows
  scene.add(directionalLight);

  // Create the western town instead of just a ground plane
  createWesternTown();
  
  // Create the desert terrain
  createDesertTerrain();
  
  // Create circular train track and load train
  createTrainSystem();

  return { camera, renderer };
}

/**
 * Preloads skybox textures to ensure they're in memory
 * @param {Function} callback - Function to call when preloading is complete
 */
function preloadSkyboxTextures(callback) {
  const textureLoader = new THREE.TextureLoader();
  let loadedCount = 0;
  const totalTextures = 2;
  
  // Add cache-busting query parameter
  const timestamp = Date.now();
  const skyUrl = `models/skypart.png?t=${timestamp}`;
  const groundUrl = `models/groundpart.png?t=${timestamp}`;
  
  function checkAllLoaded() {
    loadedCount++;
    if (loadedCount >= totalTextures) {
      callback();
    }
  }

  // Preload the sky texture
  textureLoader.load(
    skyUrl,
    () => {
      console.log("Sky texture preloaded successfully");
      checkAllLoaded();
    },
    undefined,
    () => {
      console.warn("Sky texture preload failed, continuing anyway");
      checkAllLoaded();
    }
  );
  
  // Preload the ground texture
  textureLoader.load(
    groundUrl,
    () => {
      console.log("Ground texture preloaded successfully");
      checkAllLoaded();
    },
    undefined,
    () => {
      console.warn("Ground texture preload failed, continuing anyway");
      checkAllLoaded();
    }
  );
}

/**
 * Loads the two-part skybox with separate ground and animated sky
 */
function loadTwoPartSkybox() {
  const textureLoader = new THREE.TextureLoader();
  const skyboxRadius = 900;
  
  // Function to create sky part with a texture
  function createSkyPart(skyTexture) {
    console.log("Creating sky part with texture");
    
    // Verify if texture is valid before proceeding
    if (!skyTexture.image || !skyTexture.image.width || !skyTexture.image.height) {
      console.error("Sky texture is invalid, using fallback instead");
      createFallbackSkyPart();
      return;
    }
    
    // Create sky mesh with LARGER radius (1.01x)
    const skyGeometry = new THREE.SphereGeometry(skyboxRadius * 1.01, 64, 32);
    skyGeometry.scale(-1, 1, 1);
    
    const skyMaterial = new THREE.MeshBasicMaterial({
      map: skyTexture,
      transparent: true,
      fog: false
    });
    
    // Cleanup previous mesh if exists
    if (skyMesh) {
      scene.remove(skyMesh);
      skyMesh.geometry.dispose();
      skyMesh.material.dispose();
    }
    
    skyMesh = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(skyMesh);
    texturesLoaded.skyLoaded = true;
    console.log("Sky part added to scene");
  }
  
  // Function to create fallback sky part
  function createFallbackSkyPart() {
    console.log("Creating fallback sky part");
    
    // Create fallback sky with solid color
    const skyGeometry = new THREE.SphereGeometry(skyboxRadius * 1.01, 64, 32);
    skyGeometry.scale(-1, 1, 1);
    
    const skyMaterial = new THREE.MeshBasicMaterial({
      color: 0x87CEEB, // Sky blue
      side: THREE.BackSide,
      fog: false
    });
    
    // Cleanup previous mesh if exists
    if (skyMesh) {
      scene.remove(skyMesh);
      skyMesh.geometry.dispose();
      skyMesh.material.dispose();
    }
    
    skyMesh = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(skyMesh);
    texturesLoaded.skyLoaded = true;
    console.log("Fallback sky part added to scene");
  }
  
  // Function to create ground part with a texture
  function createGroundPart(groundTexture) {
    console.log("Creating ground part with texture");
    
    // Verify if texture is valid before proceeding
    if (!groundTexture.image || !groundTexture.image.width || !groundTexture.image.height) {
      console.error("Ground texture is invalid, using fallback instead");
      createFallbackGroundPart();
      return;
    }
    
    // Create ground mesh with normal radius
    const groundGeometry = new THREE.SphereGeometry(skyboxRadius, 64, 32);
    groundGeometry.scale(-1, 1, 1);
    
    const groundMaterial = new THREE.MeshBasicMaterial({
      map: groundTexture,
      transparent: true,
      fog: false
    });
    
    // Cleanup previous mesh if exists
    if (groundMesh) {
      scene.remove(groundMesh);
      groundMesh.geometry.dispose();
      groundMesh.material.dispose();
    }
    
    groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
    scene.add(groundMesh);
    texturesLoaded.groundLoaded = true;
    console.log("Ground part added to scene");
  }
  
  // Function to create fallback ground part
  function createFallbackGroundPart() {
    console.log("Creating fallback ground part");
    
    // Create fallback ground with solid color
    const groundGeometry = new THREE.SphereGeometry(skyboxRadius, 64, 32);
    groundGeometry.scale(-1, 1, 1);
    
    const groundMaterial = new THREE.MeshBasicMaterial({
      color: 0xAA7755, // Desert sand color
      side: THREE.BackSide,
      fog: false
    });
    
    // Cleanup previous mesh if exists
    if (groundMesh) {
      scene.remove(groundMesh);
      groundMesh.geometry.dispose();
      groundMesh.material.dispose();
    }
    
    groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
    scene.add(groundMesh);
    texturesLoaded.groundLoaded = true;
    console.log("Fallback ground part added to scene");
  }
  
  // Function to load sky texture with retry capability and cache-busting
  function loadSkyTexture(retryCount = 0) {
    const maxRetries = 3;
    texturesLoaded.skyAttempts++;
    
    // Add cache-busting query param
    const timestamp = Date.now();
    const url = `models/skypart.png?t=${timestamp}`;
    
    textureLoader.load(
      url,
      function(skyTexture) {
        console.log("Sky texture loaded successfully");
        skyTexture.needsUpdate = true; // Ensure texture is updated
        createSkyPart(skyTexture);
      },
      // Progress callback
      function(xhr) {
        if (xhr.lengthComputable) {
          const percentage = Math.round((xhr.loaded / xhr.total) * 100);
          if (percentage === 25 || percentage === 50 || percentage === 75 || percentage === 100) {
            console.log(`Loading sky texture: ${percentage}%`);
          }
        }
      },
      // Error callback
      function(error) {
        console.error('Error loading sky texture:', error);
        
        // Retry logic with increasing delay
        if (retryCount < maxRetries) {
          const delay = 500 * Math.pow(2, retryCount); // Exponential backoff: 500ms, 1000ms, 2000ms
          console.log(`Retrying sky texture load (attempt ${retryCount + 1}/${maxRetries}) in ${delay}ms...`);
          setTimeout(() => {
            loadSkyTexture(retryCount + 1);
          }, delay);
        } else {
          console.error('Failed to load sky texture after multiple attempts');
          createFallbackSkyPart();
        }
      }
    );
  }
  
  // Function to load ground texture with retry capability and cache-busting
  function loadGroundTexture(retryCount = 0) {
    const maxRetries = 3;
    texturesLoaded.groundAttempts++;
    
    // Add cache-busting query param
    const timestamp = Date.now();
    const url = `models/groundpart.png?t=${timestamp}`;
    
    textureLoader.load(
      url,
      function(groundTexture) {
        console.log("Ground texture loaded successfully");
        groundTexture.needsUpdate = true; // Ensure texture is updated
        createGroundPart(groundTexture);
      },
      // Progress callback
      function(xhr) {
        if (xhr.lengthComputable) {
          const percentage = Math.round((xhr.loaded / xhr.total) * 100);
          if (percentage === 25 || percentage === 50 || percentage === 75 || percentage === 100) {
            console.log(`Loading ground texture: ${percentage}%`);
          }
        }
      },
      // Error callback
      function(error) {
        console.error('Error loading ground texture:', error);
        
        // Retry logic with increasing delay
        if (retryCount < maxRetries) {
          const delay = 500 * Math.pow(2, retryCount); // Exponential backoff: 500ms, 1000ms, 2000ms
          console.log(`Retrying ground texture load (attempt ${retryCount + 1}/${maxRetries}) in ${delay}ms...`);
          setTimeout(() => {
            loadGroundTexture(retryCount + 1);
          }, delay);
        } else {
          console.error('Failed to load ground texture after multiple attempts');
          createFallbackGroundPart();
        }
      }
    );
  }
  
  // Start the texture loading with retry capability
  loadSkyTexture();
  loadGroundTexture();
  
  // Safety check - if textures aren't loaded after 10 seconds, use fallbacks
  setTimeout(() => {
    if (!texturesLoaded.skyLoaded && texturesLoaded.skyAttempts < 4) {
      console.warn("Sky texture not loaded after timeout, using fallback");
      createFallbackSkyPart();
    }
    if (!texturesLoaded.groundLoaded && texturesLoaded.groundAttempts < 4) {
      console.warn("Ground texture not loaded after timeout, using fallback");
      createFallbackGroundPart();
    }
  }, 10000);
}

/**
 * Creates a western town by loading the town.glb model
 */
function createWesternTown() {
  // Town dimensions (kept the same for compatibility)
  const TOWN_WIDTH = 60;  // Width of the town (X-axis)
  const TOWN_LENGTH = 100; // Length of the town (Z-axis)
  const STREET_WIDTH = 15; // Width of the main street

  // Make town dimensions globally accessible
  window.townDimensions = {
    width: TOWN_WIDTH,
    length: TOWN_LENGTH,
    streetWidth: STREET_WIDTH
  };

  // Function to process the town model
  function processTownModel(gltf) {
    // Add the entire model to the scene
    scene.add(gltf.scene);
    console.log("Town model added to scene");
    
    // Log all objects in the model
    let objectCount = 0;
    let colliderCount = 0;
    
    // Create colliders for objects prefixed with "collider"
    const colliders = [];
    
    gltf.scene.traverse((node) => {
      if (node.isMesh) {
        objectCount++;
        
        // Make sure all meshes cast and receive shadows
        node.castShadow = true;
        node.receiveShadow = true;
        
        // Add collision boxes for objects with "collider" prefix
        if (node.name.toLowerCase().startsWith('collider')) {
          colliderCount++;
          
          // Make the collider semi-transparent for easier identification in debug mode
          if (node.material) {
            // Clone the material to avoid affecting other objects with the same material
            node.material = node.material.clone();
            node.material.transparent = true;
            node.material.opacity = 0.0;
            node.material.color.set(0xff0000); // Make colliders red
          }
          
          // Get world geometry
          const bbox = new THREE.Box3().setFromObject(node);
          const size = new THREE.Vector3();
          bbox.getSize(size);
          
          // Create a physics body for this collider
          if (window.physics) {
            const position = new THREE.Vector3();
            bbox.getCenter(position);
            
            const halfExtents = new CANNON.Vec3(size.x/2, size.y/2, size.z/2);
            const shape = new CANNON.Box(halfExtents);
            
            const body = new CANNON.Body({
              mass: 0, // Static body
              position: new CANNON.Vec3(position.x, position.y, position.z),
              shape: shape
            });
            
            // Add to physics world
            window.physics.world.addBody(body);
            window.physics.bodies.push(body);
            
            // Store the node and body together for debugging
            colliders.push({ node, body });
            
            // Hide collider mesh by default (will be toggled by debug mode)
            node.visible = false;
          }
        }
      }
    });
    
    // Store colliders for potential later use
    window.townColliders = colliders;
    
    console.log(`Town model loaded with ${objectCount} objects, including ${colliderCount} colliders`);
  }
  
  // Load the town model
  const loader = new THREE.GLTFLoader();
  console.log("Loading town.glb model...");
  loader.load('models/town.glb', 
    (gltf) => processTownModel(gltf), 
    // Progress callback
    (progress) => {
      if (progress.lengthComputable) {
        const percentage = Math.round((progress.loaded / progress.total) * 100);
        // Only log at 25%, 50%, 75%, and 100% to reduce spam
        if (percentage === 25 || percentage === 50 || percentage === 75 || percentage === 100) {
          console.log(`Loading town model: ${percentage}%`);
        }
      }
    },
    (error) => {
      console.error('Error loading town model:', error);
    }
  );
}

/**
 * Creates a simple western-style building
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {number} z - Z position
 */
function createWesternBuilding(x, y, z) {
  // Randomize building dimensions
  const width = 8 + Math.random() * 4;
  const height = 5 + Math.random() * 3;
  const depth = 6 + Math.random() * 4;
  
  const buildingGroup = new THREE.Group();
  
  // Building body
  const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
  const buildingMaterial = new THREE.MeshStandardMaterial({
    color: Math.random() > 0.5 ? 0x8B4513 : 0xA0522D, // Brown variations
    roughness: 0.8,
    metalness: 0.2
  });
  const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
  building.position.set(0, height / 2, 0);
  building.castShadow = true;
  building.receiveShadow = true;
  buildingGroup.add(building);
  
  // Roof (simple triangular prism)
  const roofHeight = 2;
  const roofGeometry = new THREE.BufferGeometry();
  
  const vertices = new Float32Array([
    // Front triangle
    -width/2, height, -depth/2,
    width/2, height, -depth/2,
    0, height + roofHeight, -depth/2,
    
    // Back triangle
    -width/2, height, depth/2,
    width/2, height, depth/2,
    0, height + roofHeight, depth/2,
    
    // Left side
    -width/2, height, -depth/2,
    -width/2, height, depth/2,
    0, height + roofHeight, -depth/2,
    0, height + roofHeight, depth/2,
    
    // Right side
    width/2, height, -depth/2,
    width/2, height, depth/2,
    0, height + roofHeight, -depth/2,
    0, height + roofHeight, depth/2
  ]);
  
  const indices = [
    // Front triangle
    0, 1, 2,
    
    // Back triangle
    3, 5, 4,
    
    // Left side
    6, 8, 7,
    7, 8, 9,
    
    // Right side
    10, 11, 12,
    11, 13, 12
  ];
  
  roofGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
  roofGeometry.setIndex(indices);
  roofGeometry.computeVertexNormals();
  
  const roofMaterial = new THREE.MeshStandardMaterial({
    color: 0x8B4513, // Dark brown
    roughness: 0.9,
    metalness: 0.1
  });
  
  const roof = new THREE.Mesh(roofGeometry, roofMaterial);
  roof.castShadow = true;
  buildingGroup.add(roof);
  
  // Door
  const doorWidth = 1.5;
  const doorHeight = 3;
  const doorGeometry = new THREE.PlaneGeometry(doorWidth, doorHeight);
  const doorMaterial = new THREE.MeshStandardMaterial({
    color: 0x4d2600, // Dark brown
    roughness: 0.8,
    metalness: 0.2
  });
  const door = new THREE.Mesh(doorGeometry, doorMaterial);
  door.position.set(0, doorHeight / 2, depth / 2 + 0.01);
  buildingGroup.add(door);
  
  // Windows (1-3 random windows)
  const windowCount = 1 + Math.floor(Math.random() * 3);
  for (let i = 0; i < windowCount; i++) {
    const windowWidth = 1;
    const windowHeight = 1;
    const windowGeometry = new THREE.PlaneGeometry(windowWidth, windowHeight);
    const windowMaterial = new THREE.MeshStandardMaterial({
      color: 0xECF0F1, // White-ish
      roughness: 0.4,
      metalness: 0.6
    });
    const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
    
    // Position windows randomly on the front face
    let wxPos = -width / 3 + i * width / 3;
    if (windowCount === 1) wxPos = 0;
    
    windowMesh.position.set(
      wxPos,
      height / 2 + 0.5,
      depth / 2 + 0.01
    );
    buildingGroup.add(windowMesh);
  }
  
  // Position the whole building
  buildingGroup.position.set(x, y, z);
  
  // Rotate the building to face the street
  if (x < 0) {
    buildingGroup.rotation.y = Math.PI / 2;
  } else {
    buildingGroup.rotation.y = -Math.PI / 2;
  }
  
  scene.add(buildingGroup);
}

/**
 * Creates a straight train track and loads the train model
 */
function createTrainSystem() {
  // Create a straight path for the train
  const numPoints = 2; // Just need two points for a straight line
  const points = [];
  const trackElevation = 0.5; // Slightly elevated above ground

  // Add track endpoints
  points.push(new THREE.Vector3(TRAIN_TRACK_START.x, TRAIN_TRACK_START.y + trackElevation, TRAIN_TRACK_START.z));
  points.push(new THREE.Vector3(TRAIN_TRACK_END.x, TRAIN_TRACK_END.y + trackElevation, TRAIN_TRACK_END.z));

  // Create spline from points
  trainPath = new THREE.CatmullRomCurve3(points);
  trainPath.closed = false; // Open path, not a loop

  // Visualize the path with a line - helps with debugging, can be removed later
  const pathGeometry = new THREE.BufferGeometry().setFromPoints(trainPath.getPoints(200));
  const pathMaterial = new THREE.LineBasicMaterial({ color: 0x888888 });
  const pathLine = new THREE.Line(pathGeometry, pathMaterial);
  scene.add(pathLine);
  
  // Load train model
  const loader = new THREE.GLTFLoader();
  loader.load(
    'models/train.glb',
    (gltf) => {
      train = gltf.scene;
      train.traverse((node) => {
        if (node.isMesh) {
          node.castShadow = true;
          node.receiveShadow = true;
        }
      });
      
      // Scale and position the train
      train.scale.set(2, 2, 2);
      
      // Initialize userData for direction tracking
      train.userData = { lastDirection: trainDirection };
      
      // Position based on current progress (either from server sync or default)
      if (trainInitialized) {
        // Calculate position using time-based approach if already initialized
        trainProgress = calculateTrainProgress();
        trainDirection = getCurrentTrainDirection();
        train.userData.lastDirection = trainDirection;
        
        console.log(`Train model loaded - positioning using time-based sync: progress=${trainProgress.toFixed(4)}, direction=${trainDirection}`);
      } else {
        // Initial position at the start of track as default
        trainProgress = 0;
        trainDirection = 1;
        console.log("Train model loaded - using default starting position");
      }
      
      // Position the train
      const position = trainPath.getPointAt(trainProgress);
      train.position.copy(position);
      
      // Set rotation based on direction
      if (trainDirection < 0) {
        // Should be facing TRAIN_TRACK_START from TRAIN_TRACK_END
        const dirVector = new THREE.Vector3().subVectors(TRAIN_TRACK_START, TRAIN_TRACK_END).normalize();
        const target = new THREE.Vector3().copy(train.position).add(dirVector);
        train.lookAt(target);
      } else {
        // Should be facing TRAIN_TRACK_END from TRAIN_TRACK_START
        const dirVector = new THREE.Vector3().subVectors(TRAIN_TRACK_END, TRAIN_TRACK_START).normalize();
        const target = new THREE.Vector3().copy(train.position).add(dirVector);
        train.lookAt(target);
      }
      
      // Add to scene
      scene.add(train);
      
      console.log('Train model loaded successfully');
    },
    (xhr) => {
      console.log(`Loading train: ${(xhr.loaded / xhr.total) * 100}% loaded`);
    },
    (error) => {
      console.error('Error loading train model:', error);
      
      // Fallback: create a simple train placeholder if model fails to load
      createSimpleTrainPlaceholder();
    }
  );
}

/**
 * Creates a simple placeholder train if the model fails to load
 */
function createSimpleTrainPlaceholder() {
  // Create a simple train placeholder using basic shapes
  const trainGroup = new THREE.Group();
  
  // Create main body
  const trainBody = new THREE.Mesh(
    new THREE.BoxGeometry(5, 2, 2),
    new THREE.MeshStandardMaterial({ color: 0x333333 })
  );
  trainGroup.add(trainBody);
  
  // Create locomotive top
  const trainTop = new THREE.Mesh(
    new THREE.BoxGeometry(2, 1, 1.8),
    new THREE.MeshStandardMaterial({ color: 0x222222 })
  );
  trainTop.position.set(-1.5, 1.5, 0);
  trainGroup.add(trainTop);
  
  // Create wheels
  const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16);
  const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
  
  // Front wheels
  const frontWheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
  frontWheel1.rotation.z = Math.PI / 2;
  frontWheel1.position.set(-1.5, -1, -1);
  trainGroup.add(frontWheel1);
  
  const frontWheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
  frontWheel2.rotation.z = Math.PI / 2;
  frontWheel2.position.set(-1.5, -1, 1);
  trainGroup.add(frontWheel2);
  
  // Back wheels
  const backWheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
  backWheel1.rotation.z = Math.PI / 2;
  backWheel1.position.set(1.5, -1, -1);
  trainGroup.add(backWheel1);
  
  const backWheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
  backWheel2.rotation.z = Math.PI / 2;
  backWheel2.position.set(1.5, -1, 1);
  trainGroup.add(backWheel2);
  
  // Add chimney
  const chimney = new THREE.Mesh(
    new THREE.CylinderGeometry(0.3, 0.3, 1, 8),
    new THREE.MeshStandardMaterial({ color: 0x222222 })
  );
  chimney.position.set(-2, 2, 0);
  trainGroup.add(chimney);
  
  // Set up train as the placeholder
  train = trainGroup;
  train.castShadow = true;
  
  // Initialize userData for direction tracking
  train.userData = { lastDirection: trainDirection };
  
  // Position based on current progress (either from server sync or default)
  if (trainInitialized) {
    // Calculate position using time-based approach if already initialized
    trainProgress = calculateTrainProgress();
    trainDirection = getCurrentTrainDirection();
    train.userData.lastDirection = trainDirection;
    
    console.log(`Train placeholder - positioning using time-based sync: progress=${trainProgress.toFixed(4)}, direction=${trainDirection}`);
  } else {
    // Initial position at the start of track as default
    trainProgress = 0;
    trainDirection = 1;
    console.log("Train placeholder - using default starting position");
  }
  
  // Position the train
  const position = trainPath.getPointAt(trainProgress);
  train.position.copy(position);
  
  // Set rotation based on direction
  if (trainDirection < 0) {
    // Should be facing TRAIN_TRACK_START from TRAIN_TRACK_END
    const dirVector = new THREE.Vector3().subVectors(TRAIN_TRACK_START, TRAIN_TRACK_END).normalize();
    const target = new THREE.Vector3().copy(train.position).add(dirVector);
    train.lookAt(target);
  } else {
    // Should be facing TRAIN_TRACK_END from TRAIN_TRACK_START
    const dirVector = new THREE.Vector3().subVectors(TRAIN_TRACK_END, TRAIN_TRACK_START).normalize();
    const target = new THREE.Vector3().copy(train.position).add(dirVector);
    train.lookAt(target);
  }
  
  scene.add(train);
  
  console.log('Using simple train placeholder');
}

/**
 * Calculate train progress (0-1) based on elapsed time since train system started
 * @returns {number} Progress value between 0-1
 */
function calculateTrainProgress() {
  if (!trainInitialized || !trainStartTime || !trainCycleTime) {
    // Fall back to default
    return trainProgress;
  }
  
  const elapsedTime = Date.now() - trainStartTime;
  const cycleCount = Math.floor(elapsedTime / trainCycleTime);
  const timeInCurrentCycle = elapsedTime % trainCycleTime;
  
  // Calculate progress within current cycle (0-1)
  const cycleProgress = timeInCurrentCycle / trainCycleTime;
  
  // If even cycle, progress from 0 to 1 (forward)
  // If odd cycle, progress from 1 to 0 (backward)
  return cycleCount % 2 === 0 ? cycleProgress : 1 - cycleProgress;
}

/**
 * Get current train direction based on elapsed time
 * @returns {number} 1 for forward, -1 for backward
 */
function getCurrentTrainDirection() {
  if (!trainInitialized || !trainStartTime || !trainCycleTime) {
    // Fall back to default
    return trainDirection;
  }
  
  const elapsedTime = Date.now() - trainStartTime;
  const cycleCount = Math.floor(elapsedTime / trainCycleTime);
  // Direction changes every cycle
  return cycleCount % 2 === 0 ? 1 : -1;
}

/**
 * Updates the train position along the straight track
 * @param {number} deltaTime - Time since last frame in seconds
 */
export function updateTrain(deltaTime) {
  if (!train) return;
  
  if (trainInitialized) {
    // Time-based train movement - calculate position based on global timer
    trainProgress = calculateTrainProgress();
    trainDirection = getCurrentTrainDirection();
    
    // Get position on the path
    const position = trainPath.getPointAt(trainProgress);
    train.position.copy(position);
    
    // Check if we need to update train rotation when changing direction
    const expectedDirection = getCurrentTrainDirection();
    if (train.userData.lastDirection !== expectedDirection) {
      // Direction changed, rotate 180 degrees
      const currentRotation = train.rotation.y;
      train.rotation.y = currentRotation + Math.PI;
      train.userData.lastDirection = expectedDirection;
      
      if (trainLogMessages) {
        console.log(`Train changed direction to ${expectedDirection > 0 ? 'forwards' : 'backwards'}`);
      }
    }
  } else {
    // Original client-side train movement (fallback before server sync)
    trainProgress += 0.0003 * trainDirection * deltaTime * 60;
    
    // Change direction when reaching either end
    if (trainProgress >= 1) {
      // Reached the end, turn around
      trainDirection = -1;
      trainProgress = 1;
      
      // Rotate 180 degrees
      const currentRotation = train.rotation.y;
      train.rotation.y = currentRotation + Math.PI;
      
    } else if (trainProgress <= 0) {
      // Reached the start, turn around
      trainDirection = 1;
      trainProgress = 0;
      
      // Rotate 180 degrees
      const currentRotation = train.rotation.y;
      train.rotation.y = currentRotation + Math.PI;
    }
    
    // Get position on the path
    const position = trainPath.getPointAt(trainProgress);
    train.position.copy(position);
  }
}

/**
 * Sets train state from server's initial data
 * @param {Object} data - Train initialization data from server
 */
export function setTrainInitialState(data) {
  console.log('Received initial train state:', data);
  
  if (!data || typeof data.startTime !== 'number' || typeof data.cycleTime !== 'number') {
    console.error("Invalid train initialization data:", data);
    return;
  }
  
  // Store time-based tracking values
  trainStartTime = data.startTime;
  trainCycleTime = data.cycleTime;
  trainSpeed = data.speed || 0.0003;
  trainTrackLength = data.trackLength || 2000;
  
  // Calculate current position
  trainProgress = calculateTrainProgress();
  trainDirection = getCurrentTrainDirection();
  
  console.log(`Train synchronized: startTime=${trainStartTime}, progress=${trainProgress.toFixed(4)}, direction=${trainDirection}`);
  
  // Update train position if it exists
  if (train) {
    // Store the direction in the train object for rotation tracking
    if (!train.userData) train.userData = {};
    train.userData.lastDirection = trainDirection;
    
    // Update train position
    const position = trainPath.getPointAt(trainProgress);
    train.position.copy(position);
    
    // Set initial rotation
    if (trainDirection < 0) {
      // Should be facing TRAIN_TRACK_START from TRAIN_TRACK_END
      const dirVector = new THREE.Vector3().subVectors(TRAIN_TRACK_START, TRAIN_TRACK_END).normalize();
      const target = new THREE.Vector3().copy(train.position).add(dirVector);
      train.lookAt(target);
    } else {
      // Should be facing TRAIN_TRACK_END from TRAIN_TRACK_START
      const dirVector = new THREE.Vector3().subVectors(TRAIN_TRACK_END, TRAIN_TRACK_START).normalize();
      const target = new THREE.Vector3().copy(train.position).add(dirVector);
      train.lookAt(target);
    }
    
    console.log(`Train positioned at progress=${trainProgress.toFixed(4)}`);
  } else {
    console.log("Train model not loaded yet, will position when available");
  }
  
  trainInitialized = true;
  
  // Disable verbose logging after 5 seconds
  setTimeout(() => {
    trainLogMessages = false;
    console.log("Train logging reduced");
  }, 5000);
}

/**
 * Updates train state from server updates
 * @param {Object} data - Train state update from server
 */
export function updateTrainState(data) {
  // Process if we haven't initialized yet
  if (!trainInitialized) {
    console.log("Processing train state as initial");
    setTrainInitialState(data);
  } else if (trainLogMessages) {
    // Only log if verbose logging is enabled
    console.log("Received train update (already initialized)");
  }
}

/**
 * Updates the FPS counter and handles animation
 * @param {THREE.WebGLRenderer} renderer - The renderer.
 * @param {THREE.Camera} camera - The camera.
 * @param {number} deltaTime - Time since last frame in seconds.
 */
export function updateFPS(renderer, camera, deltaTime) {
  // Safely rotate the sky part of the skybox if it exists
  if (skyMesh && skyMesh.rotation) {
    skyMesh.rotation.y += SKYBOX_ROTATION_SPEED * deltaTime * 1000; // Convert to milliseconds
  } else if (!skyMesh && !texturesLoaded.skyLoaded) {
    // If skyMesh doesn't exist but should be loaded, attempt recovery
    if (texturesLoaded.skyAttempts < 4) {
      console.warn("Sky mesh missing in animation loop, attempting recovery");
      loadTwoPartSkybox();
    }
  }
  
  // Update FPS counter if enabled
  if (window.fpsCounterEnabled) {
    fpsUpdateCounter++;
    if (fpsUpdateCounter >= 10) { // Update every 10 frames
      const fps = Math.round(1 / deltaTime);
      const fpsElement = document.getElementById('fps-counter');
      if (fpsElement) {
        fpsElement.textContent = `FPS: ${fps}`;
      }
      fpsUpdateCounter = 0;
    }
  }
  
  // Update tumbleweed positions if manager exists
  if (tumbleweedManager) {
    tumbleweedManager.update(deltaTime);
  }
  
  // Update train position
  updateTrain(deltaTime);
  
  // Render the final scene
  renderer.render(scene, camera);
}

/**
 * Creates desert terrain around the town
 */
function createDesertTerrain() {
  // Create desert terrain after town dimensions are set
  if (window.townDimensions) {
    console.log("Creating desert terrain around town...");
    const desertTerrain = new DesertTerrain(scene, window.townDimensions);
    desertTerrain.generate();
    
    // Store terrain instance for potential access later
    window.desertTerrain = desertTerrain;
    
    // Initialize tumbleweed manager after terrain is created
    initializeTumbleweedManager();
  } else {
    // If town dimensions aren't available yet, wait for them
    console.log("Waiting for town dimensions before creating desert terrain...");
    const checkInterval = setInterval(() => {
      if (window.townDimensions) {
        console.log("Town dimensions available, creating desert terrain...");
        const desertTerrain = new DesertTerrain(scene, window.townDimensions);
        desertTerrain.generate();
        
        // Store terrain instance for potential access later
        window.desertTerrain = desertTerrain;
        
        // Initialize tumbleweed manager after terrain is created
        initializeTumbleweedManager();
        
        clearInterval(checkInterval);
      }
    }, 100);
  }
}

/**
 * Initializes the tumbleweed manager
 */
function initializeTumbleweedManager() {
  if (window.townDimensions) {
    console.log("Initializing tumbleweed manager...");
    
    // Dispose of the previous manager if it exists
    if (tumbleweedManager) {
      tumbleweedManager.dispose();
    }
    
    tumbleweedManager = new TumbleweedManager(scene, window.townDimensions);
    
    // Store manager instance for potential access later
    window.tumbleweedManager = tumbleweedManager;
  }
}

/**
 * Cleans up resources when switching scene or closing
 */
export function cleanupScene() {
  console.log("Cleaning up scene resources...");
  
  // Dispose of tumbleweed manager
  if (tumbleweedManager) {
    tumbleweedManager.dispose();
    tumbleweedManager = null;
  }
  
  // Clean up other resources as needed
}

================================================
File: /public/js/smokeRingEffect.js
================================================
/**
 * Smoke Ring Effect implementation for the Western Shooter game
 * Creates a stylized low-poly smoke ring when firing
 * Optimized for performance to reduce frame drops
 */
export class SmokeRingEffect {
    constructor(scene) {
        this.scene = scene;
        this.group = new THREE.Group();
        this.scene.add(this.group);
        
        this.puffs = [];
        this.active = false;
        
        // Use an object pool for particles to reduce GC
        this.particlePool = [];
        this.materialsPool = [];
        
        // Create shared geometries that will be reused - MUCH LARGER BASE GEOMETRY
        this.puffGeometry = new THREE.IcosahedronGeometry(0.2, 0); // Increased from 0.05
        this.muzzleGeometry = new THREE.IcosahedronGeometry(0.25, 0); // Increased from 0.06
    }
    
    /**
     * Preload all resources needed for the smoke ring effect
     * Call this during initialization to avoid FPS drops on first use
     */
    preload() {
        // Create and cache particles
        const numToPreload = 25; // Slightly more than used in a single effect
        
        for (let i = 0; i < numToPreload; i++) {
            // Create standard particles
            this._getParticle(false);
            
            // Create a few muzzle particles too
            if (i < 5) {
                this._getParticle(true);
            }
        }
        
        // Make them all invisible and return to pool
        for (let i = 0; i < this.group.children.length; i++) {
            const mesh = this.group.children[i];
            mesh.visible = false;
            this.particlePool.push(mesh);
        }
        
        // Store original position of the group
        const originalPosition = this.group.position.clone();
        
        // Move group far below scene to hide preload animations
        this.group.position.set(0, -1000, 0);
        
        // Create a dummy direction for the effect
        const dummyDirection = new THREE.Vector3(0, 0, 1);
        
        // Create a full smoke ring effect in the hidden location
        this._createSmokeRing();
        this.active = true;
        
        // Simulate animation frames manually for each effect
        // This forces shader compilation and resource allocation before the user sees it
        const timesteps = [0, 16, 32, 48, 64, 80, 96, 112, 128];
        
        // Manually advance animation by simulating update calls
        for (const timestep of timesteps) {
            this.update(timestep / 1000); // Convert ms to seconds for the update method
        }
        
        // Reset everything after preloading
        this.puffs = [];
        this.active = false;
        
        // Return group to original position
        this.group.position.copy(originalPosition);
        
        // Clear all used particles back to pool
        for (let i = 0; i < this.group.children.length; i++) {
            const mesh = this.group.children[i];
            mesh.visible = false;
            this.particlePool.push(mesh);
        }
        
        return this; // For chaining
    }
    
    /**
     * Create a smoke ring effect at the specified position and direction
     * @param {THREE.Vector3} position - The position to create the smoke ring
     * @param {THREE.Vector3} direction - The direction the weapon is firing
     * @param {Object} options - Optional positioning overrides
     */
    create(position, direction, options = null) {
        // Reuse particles instead of removing them
        for (let i = 0; i < this.group.children.length; i++) {
            const mesh = this.group.children[i];
            mesh.visible = false;
            this.particlePool.push(mesh);
        }
        this.puffs = [];
        
        // Get effect configuration - either from options or from default constants
        let forwardOffset = 0.05;
        let xOffset = 0;
        let yOffset = 0;
        let scale = 1.0;
        
        // If we have options from the viewmodel, use those for positioning
        if (options) {
            forwardOffset = options.forward_offset || forwardOffset;
            xOffset = options.x_offset || xOffset;
            yOffset = options.y_offset || yOffset;
            scale = options.scale || scale;
        }
        
        // Position the smoke ring with the appropriate offsets
        const adjustedPosition = position.clone();
        
        // Apply direction-based forward offset
        const forwardDir = direction.clone().normalize().multiplyScalar(forwardOffset);
        adjustedPosition.add(forwardDir);
        
        // Apply lateral offsets if specified
        if (xOffset !== 0 || yOffset !== 0) {
            // We need to calculate the right and up vectors relative to the firing direction
            // to apply the x/y offsets correctly
            const right = new THREE.Vector3();
            const up = new THREE.Vector3(0, 1, 0);
            right.crossVectors(direction, up).normalize();
            
            // Recalculate up to ensure it's perpendicular
            up.crossVectors(right, direction).normalize();
            
            // Apply offsets
            if (xOffset !== 0) {
                adjustedPosition.add(right.multiplyScalar(xOffset));
            }
            
            if (yOffset !== 0) {
                adjustedPosition.add(up.multiplyScalar(yOffset));
            }
        }
        
        // Position the smoke ring at the adjusted position
        this.group.position.copy(adjustedPosition);
        this.group.lookAt(adjustedPosition.clone().add(direction));
        
        // Apply scale if different from default
        if (scale !== 1.0) {
            this.group.scale.set(scale, scale, scale);
        } else {
            this.group.scale.set(1, 1, 1);
        }
        
        // Create the smoke ring effect
        this._createSmokeRing();
        
        this.active = true;
    }
    
    /**
     * Get a particle mesh from the pool or create a new one
     * @param {boolean} isMuzzle - Whether this is a muzzle blast particle
     * @returns {THREE.Mesh} - The particle mesh
     * @private
     */
    _getParticle(isMuzzle = false) {
        if (this.particlePool.length > 0) {
            const mesh = this.particlePool.pop();
            mesh.visible = true;
            return mesh;
        }
        
        // Create new material with proper settings
        const material = new THREE.MeshPhongMaterial({
            color: 0xCCCCCC,
            flatShading: true,
            shininess: 0,
            transparent: true,
            depthWrite: false
        });
        
        this.materialsPool.push(material);
        
        // Create new mesh with the proper geometry
        const geometry = isMuzzle ? this.muzzleGeometry : this.puffGeometry;
        const mesh = new THREE.Mesh(geometry, material);
        
        // Set renderOrder on the mesh itself where it belongs
        mesh.renderOrder = 1000;
        
        this.group.add(mesh);
        return mesh;
    }
    
    /**
     * Create a smoke ring with proper radial particles
     * @private
     */
    _createSmokeRing() {
        // Keep just a handful of puffs with better size distribution
        const numRingParticles = 5; // 5 total puffs for outer ring
        const initialRingRadius = 0.35; // Reduced from 0.5 for less spread
        
        // Number of small inner puffs
        const numInnerPuffs = 3; // Add small puffs in the inner area
        const innerRingRadius = 0.18; // Reduced from 0.25 for less spread
        
        // Pre-determine which particles will be the large ones (1 or 2 max)
        const largeParticleIndices = [];
        const numLargeParticles = Math.random() < 0.5 ? 1 : 2; // Either 1 or 2 large particles
        
        while (largeParticleIndices.length < numLargeParticles) {
            const idx = Math.floor(Math.random() * numRingParticles);
            if (!largeParticleIndices.includes(idx)) {
                largeParticleIndices.push(idx);
            }
        }
        
        // Create outer ring puffs (larger ones)
        for (let i = 0; i < numRingParticles; i++) {
            // Much wider distribution around the circle
            // More randomness in angle placement for less uniform pattern
            const angle = (i / numRingParticles) * Math.PI * 2 + (Math.random() - 0.5) * 0.7;
            
            // Less radius spread for tighter dispersion
            const radiusVariation = initialRingRadius * (0.8 + Math.random() * 0.8); // Reduced from 1.0 + random * 1.2
            
            // Get a particle from the pool or create a new one
            const puffMesh = this._getParticle(false);
            
            // Compute normals for flat shading
            if (puffMesh.geometry.attributes.normal) {
                puffMesh.geometry.computeVertexNormals();
            }
            
            // All particles initially start near the origin (gun position)
            // They'll move to their final positions quickly during the first frames
            puffMesh.position.x = Math.cos(angle) * 0.05; // Start close to center
            puffMesh.position.y = Math.sin(angle) * 0.05; // Start close to center
            puffMesh.position.z = 0.01; // Start very close to gun
            
            // Target positions for quick interpolation - closer to gun
            const targetX = Math.cos(angle) * radiusVariation;
            const targetY = Math.sin(angle) * radiusVariation;
            const targetZ = 0.05 + Math.random() * 0.2; // Reduced from 0.3 for less z-spread
            
            // Fixed random rotation for initial appearance - don't animate rotation later
            puffMesh.rotation.x = Math.random() * Math.PI * 2;
            puffMesh.rotation.y = Math.random() * Math.PI * 2;
            puffMesh.rotation.z = Math.random() * Math.PI * 2;
            
            // Determine size based on whether this is one of the pre-selected large particles
            let baseSize;
            if (largeParticleIndices.includes(i)) {
                // This is one of the 1-2 large particles
                baseSize = 1.4 + Math.random() * 0.8; // 1.4-2.2 size
            } else {
                // Regular smaller particles
                baseSize = 0.6 + Math.random() * 0.4; // 0.6-1.0 size
            }
            
            // Start with a very small scale (originating from gun)
            puffMesh.scale.set(0.05, 0.05, 0.05);
            
            // Slower outward speed for less spread
            const outwardSpeed = largeParticleIndices.includes(i) ? 
                1.0 + Math.random() * 0.6 : // Reduced from 1.5 + random * 0.8 
                0.9 + Math.random() * 0.7;  // Reduced from 1.4 + random * 1.0
            
            this.puffs.push({
                mesh: puffMesh,
                age: 0,
                lifespan: largeParticleIndices.includes(i) ?
                    1.0 + Math.random() * 1.2 : // Longer lifespan for larger clouds
                    0.7 + Math.random() * 0.5,  // Shorter for smaller clouds
                velocity: new THREE.Vector3(
                    Math.cos(angle) * outwardSpeed,
                    Math.sin(angle) * outwardSpeed,
                    largeParticleIndices.includes(i) ?
                        0.01 + Math.random() * 0.1 : // Less vertical for big clouds
                        0.05 + Math.random() * 0.2   // Reduced from 0.25 for less upward movement
                ),
                rotationSpeed: new THREE.Vector3(0, 0, 0), // No rotation
                initialSize: baseSize, // Store the initial size for reference
                // Add target position data for fast initial interpolation
                targetPos: new THREE.Vector3(targetX, targetY, targetZ),
                initialExpansionDone: false, // Track if initial expansion is complete
                initialExpansionSpeed: largeParticleIndices.includes(i) ?
                    30 + Math.random() * 15 : // Much faster expansion for large particles
                    20 + Math.random() * 10   // Fast expansion for other particles
            });
        }
        
        // Create inner core small puffs
        for (let i = 0; i < numInnerPuffs; i++) {
            // Distribute small puffs randomly in the inner area
            const angle = Math.random() * Math.PI * 2;
            
            // Use smaller radius for inner puffs with less spread
            const radiusVariation = innerRingRadius * (0.5 + Math.random() * 0.7); // Reduced from 0.6 + random * 1.0
            
            // Get a particle from the pool or create a new one
            const puffMesh = this._getParticle(false);
            
            // Compute normals for flat shading
            if (puffMesh.geometry.attributes.normal) {
                puffMesh.geometry.computeVertexNormals();
            }
            
            // Start at the origin (gun position)
            puffMesh.position.x = Math.cos(angle) * 0.03;
            puffMesh.position.y = Math.sin(angle) * 0.03;
            puffMesh.position.z = 0.01;
            
            // Target positions for quick interpolation - closer to gun
            const targetX = Math.cos(angle) * radiusVariation;
            const targetY = Math.sin(angle) * radiusVariation;
            const targetZ = 0.02 + Math.random() * 0.1; // Reduced from 0.15 for less z-spread
            
            // Fixed random rotation
            puffMesh.rotation.x = Math.random() * Math.PI * 2;
            puffMesh.rotation.y = Math.random() * Math.PI * 2;
            puffMesh.rotation.z = Math.random() * Math.PI * 2;
            
            // Small size for inner puffs
            const baseSize = 0.2 + Math.random() * 0.2; // 0.2-0.4 size
            
            // Start very small
            puffMesh.scale.set(0.03, 0.03, 0.03);
            
            // Slower outward speed for less spread
            const outwardSpeed = 0.6 + Math.random() * 0.6; // Reduced from 0.9 + random * 0.8
            
            this.puffs.push({
                mesh: puffMesh,
                age: 0,
                lifespan: 0.5 + Math.random() * 0.4, // Shorter lifespan for small inner puffs
                velocity: new THREE.Vector3(
                    Math.cos(angle) * outwardSpeed,
                    Math.sin(angle) * outwardSpeed,
                    0.03 + Math.random() * 0.09 // Reduced from 0.12 for less upward movement
                ),
                rotationSpeed: new THREE.Vector3(0, 0, 0), // No rotation
                initialSize: baseSize,
                // Add target position data for fast initial interpolation
                targetPos: new THREE.Vector3(targetX, targetY, targetZ),
                initialExpansionDone: false, // Track if initial expansion is complete
                initialExpansionSpeed: 25 + Math.random() * 10 // Fast expansion speed
            });
        }
        
        // Original muzzle blast particles for visual fidelity
        for (let i = 0; i < 1; i++) {
            const puffMesh = this._getParticle(true);
            
            // Position very close to origin with minimal spread
            const smallOffset = 0.03; // Start even closer to gun
            puffMesh.position.set(
                (Math.random() - 0.5) * smallOffset,
                (Math.random() - 0.5) * smallOffset,
                0
            );
            
            // Target positions - muzzle particles expand in place - closer to gun
            const targetX = (Math.random() - 0.5) * 0.08; // Reduced from 0.12
            const targetY = (Math.random() - 0.5) * 0.08; // Reduced from 0.12
            const targetZ = 0.02 + Math.random() * 0.02; // Reduced from 0.03
            
            // Fixed random rotation
            puffMesh.rotation.x = Math.random() * Math.PI * 2;
            puffMesh.rotation.y = Math.random() * Math.PI * 2;
            puffMesh.rotation.z = Math.random() * Math.PI * 2;
            
            // Moderate muzzle particles
            const baseSize = 0.6 + Math.random() * 0.2; // 0.6-0.8 size
            
            // Start extremely small
            puffMesh.scale.set(0.01, 0.01, 0.01);
            
            // Random outward direction with slower speed
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.9 + Math.random() * 0.6; // Reduced from 1.3 + random * 0.8
            
            this.puffs.push({
                mesh: puffMesh,
                age: 0,
                lifespan: 0.6 + Math.random() * 0.3,
                velocity: new THREE.Vector3(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    0.15 + Math.random() * 0.2 // Reduced from 0.2 + random * 0.3
                ),
                rotationSpeed: new THREE.Vector3(0, 0, 0), // No rotation
                initialSize: baseSize,
                // Add target position data for fast initial interpolation
                targetPos: new THREE.Vector3(targetX, targetY, targetZ),
                initialExpansionDone: false, // Track if initial expansion is complete  
                initialExpansionSpeed: 20 + Math.random() * 10 // Very fast expansion for muzzle flash
            });
        }
    }
    
    /**
     * Update the smoke ring effect
     * @param {number} deltaTime - Time elapsed since last frame
     * @returns {boolean} - Whether the effect is still active
     */
    update(deltaTime) {
        if (!this.active) return false;
        
        let allExpired = true;
        
        // Limit delta time to avoid large jumps that cause performance issues
        const clampedDelta = Math.min(deltaTime, 0.05);
        
        for (let i = 0; i < this.puffs.length; i++) {
            const puff = this.puffs[i];
            puff.age += clampedDelta;
            
            // If puff still alive, update it
            if (puff.age < puff.lifespan) {
                allExpired = false;
                
                // Calculate life ratio
                const lifeRatio = puff.age / puff.lifespan;
                
                // Fast initial position interpolation (first ~50ms - even faster)
                if (!puff.initialExpansionDone) {
                    // Check if we're still in the initial fast expansion phase (now only 50ms)
                    const initialPhaseComplete = puff.age > 0.05; // Reduced from 100ms to 50ms
                    
                    if (initialPhaseComplete) {
                        // Mark initial expansion as done
                        puff.initialExpansionDone = true;
                        
                        // Set position to target to ensure we reached it
                        puff.mesh.position.copy(puff.targetPos);
                    } else {
                        // Very fast interpolation toward target position
                        const lerpFactor = clampedDelta * puff.initialExpansionSpeed;
                        
                        puff.mesh.position.x += (puff.targetPos.x - puff.mesh.position.x) * lerpFactor;
                        puff.mesh.position.y += (puff.targetPos.y - puff.mesh.position.y) * lerpFactor;
                        puff.mesh.position.z += (puff.targetPos.z - puff.mesh.position.z) * lerpFactor;
                        
                        // Quickly scale up to initial size
                        const targetScale = puff.initialSize * 0.9; // Target 90% of final size initially
                        const currentScale = puff.mesh.scale.x;
                        const newScale = currentScale + (targetScale - currentScale) * lerpFactor;
                        puff.mesh.scale.set(newScale, newScale, newScale);
                    }
                } else {
                    // Normal movement after initial expansion
                    const positionX = puff.mesh.position.x + puff.velocity.x * clampedDelta;
                    const positionY = puff.mesh.position.y + puff.velocity.y * clampedDelta;
                    const positionZ = puff.mesh.position.z + puff.velocity.z * clampedDelta;
                    puff.mesh.position.set(positionX, positionY, positionZ);
                
                    // Scale curve for visual fidelity after initial expansion - REDUCE MAX SCALE
                    let scaleFactor;
                    
                    if (lifeRatio < 0.2) {
                        // Quick growth phase - 0 to 0.2 - REDUCE PEAK
                        scaleFactor = 0.9 + (lifeRatio / 0.2) * 0.2; // Start from 90% to 110% (down from 130%)
                    } else if (lifeRatio < 0.7) {
                        // Maintain size with slight growth - 0.2 to 0.7 - REDUCE PEAK
                        scaleFactor = 1.1 + (lifeRatio - 0.2) * 0.1; // 110% to 120% (down from 130% to 150%)
                    } else {
                        // Shrink phase - 0.7 to 1.0
                        scaleFactor = 1.2 - (lifeRatio - 0.7) * (1.2 / 0.3); // Shrink from 120% to 0%
                    }
                    
                    // Apply scale based on the initial size to maintain relative proportions
                    const scale = puff.initialSize * scaleFactor;
                    puff.mesh.scale.set(scale, scale, scale);
                }
                
                // Handle transparency in final phase
                if (lifeRatio > 0.7) {
                    const opacity = 1 - ((lifeRatio - 0.7) / 0.3);
                    puff.mesh.material.opacity = opacity;
                } else {
                    // Reset opacity for particles not in final phase
                    puff.mesh.material.opacity = 1.0;
                }
                
                // Almost no drag to allow particles to travel much further
                const dragFactor = lifeRatio < 0.5 ? 0.995 : 0.99;
                puff.velocity.multiplyScalar(dragFactor);
            } else {
                // Add expired puffs back to the pool instead of making them invisible
                puff.mesh.visible = false;
                this.particlePool.push(puff.mesh);
            }
        }
        
        // If all puffs have expired, clean up and set active to false
        if (allExpired) {
            this.puffs = [];
            this.active = false;
            return false;
        }
        
        return true;
    }
    
    /**
     * Clean up resources
     */
    dispose() {
        // Clean up all meshes and properly dispose materials
        while(this.group.children.length > 0) {
            const mesh = this.group.children[0];
            this.group.remove(mesh);
        }
        
        // Clear the particle pool
        this.particlePool = [];
        this.puffs = [];
        
        // Dispose of all materials in the pool
        for (let i = 0; i < this.materialsPool.length; i++) {
            if (this.materialsPool[i]) {
                this.materialsPool[i].dispose();
            }
        }
        this.materialsPool = [];
        
        // Dispose of shared geometries
        if (this.puffGeometry) this.puffGeometry.dispose();
        if (this.muzzleGeometry) this.muzzleGeometry.dispose();
        
        // Remove group from scene
        if (this.group.parent) {
            this.group.parent.remove(this.group);
        }
    }
}

================================================
File: /public/js/soundManager.js
================================================
export class SoundManager {
  constructor() {
    // Initialize Web Audio API context
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Sound buffers and pools
    this.buffers = {};
    this.soundPools = {};
    this.soundCategories = {
      'weapon': { maxInstances: 3, volume: 1.0 },  // Limit weapon sounds like gunshots
      'impact': { maxInstances: 5, volume: 0.8 },  // Hit sounds
      'footstep': { maxInstances: 6, volume: 0.7 }, // Footstep sounds
      'ui': { maxInstances: 3, volume: 0.6 },      // UI sounds
      'ambient': { maxInstances: 5, volume: 0.5 }, // Background sounds
      'voice': { maxInstances: 2, volume: 1.0 }    // Voice sounds
    };
    
    // Default category mapping for common sounds
    this.soundCategoryMap = {
      'shot': 'weapon',
      'shotgunshot': 'weapon',  // Explicitly add shotgunshot to ensure it's properly categorized
      'revolverdraw': 'ui',
      'shotgundraw': 'ui',
      'reloading': 'weapon',
      'woodimpact': 'impact',
      'fleshimpact': 'impact',
      'leftstep': 'footstep',
      'rightstep': 'footstep',
      'jumpup': 'ui',         // Change from footstep to ui for higher priority
      'jumpland': 'footstep',
      'recoiljump': 'footstep',
      'headshotmarker': 'ui',
      'dramatic': 'ui',
      'eaglescream': 'ui',
      'playerfall': 'impact',
      'revolverholstering': 'weapon',  // Add the new sound name
      'shotgunholstering': 'weapon',   // Add the new sound name
      'shotgunempty': 'weapon',        // Add shotgun empty sound
      'eagledeath': 'ui',              // Keep only eagledeath
      'ambience': 'ambient'
    };
    
    // Main mixer channels
    this.masterGain = this.audioContext.createGain();
    
    // Create audio processing for better sound quality
    this.setupAudioProcessing();
    
    this.categoryGains = {};
    for (const category in this.soundCategories) {
      this.categoryGains[category] = this.audioContext.createGain();
      this.categoryGains[category].gain.value = this.soundCategories[category].volume;
      this.categoryGains[category].connect(this.masterGain);
    }
    
    // For sound cooldowns (prevent sound spam)
    this.soundCooldowns = {};
    
    // Track currently playing sounds by category
    this.activeSounds = {};
    for (const category in this.soundCategories) {
      this.activeSounds[category] = [];
    }
    
    // Set initial master volume
    this.setMasterVolume(0.8);
  }
  
  /**
   * Sets up audio processing chain for better sound
   */
  setupAudioProcessing() {
    // Create a compressor to prevent audio clipping and make overall sound fuller
    this.compressor = this.audioContext.createDynamicsCompressor();
    this.compressor.threshold.value = -24;    // Start compressing at -24dB
    this.compressor.knee.value = 10;          // Smooth knee for more natural sound
    this.compressor.ratio.value = 4;          // 4:1 compression ratio
    this.compressor.attack.value = 0.005;     // Fast attack (5ms)
    this.compressor.release.value = 0.1;      // Medium release (100ms)
    
    // Optional: Add a subtle reverb for weapon sounds
    if (this.audioContext.createConvolver) {
      try {
        // Setup convolver for reverb
        this.convolver = this.audioContext.createConvolver();
        
        // Create a simple impulse response for a small reverb
        const sampleRate = this.audioContext.sampleRate;
        const length = Math.floor(sampleRate * 0.5); // 500ms impulse response
        const impulseBuffer = this.audioContext.createBuffer(2, length, sampleRate);
        
        // Fill both channels with an exponentially decaying noise
        for (let channel = 0; channel < 2; channel++) {
          const impulseData = impulseBuffer.getChannelData(channel);
          for (let i = 0; i < length; i++) {
            // Create exponentially decaying noise
            impulseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3);
          }
        }
        
        // Set the impulse response
        this.convolver.buffer = impulseBuffer;
        
        // Create a send gain for the reverb
        this.reverbSend = this.audioContext.createGain();
        this.reverbSend.gain.value = 0.1; // Very subtle reverb
        
        // Connect reverb to the chain
        this.reverbSend.connect(this.convolver);
        this.convolver.connect(this.compressor);
        console.log("Reverb effect initialized");
      } catch (e) {
        console.warn("Failed to initialize reverb", e);
        // Fallback: No reverb
        this.reverbSend = null;
        this.convolver = null;
      }
    }
    
    // Connect the audio chain
    this.masterGain.connect(this.compressor);
    this.compressor.connect(this.audioContext.destination);
    
    console.log("Audio processing chain configured");
  }
  
  /**
   * Sets the master volume for all sounds
   * @param {number} value - Volume from 0 to 1
   */
  setMasterVolume(value) {
    this.masterGain.gain.value = Math.max(0, Math.min(1, value));
  }
  
  /**
   * Sets the volume for a specific sound category
   * @param {string} category - Category name
   * @param {number} value - Volume from 0 to 1
   */
  setCategoryVolume(category, value) {
    if (this.categoryGains[category]) {
      this.categoryGains[category].gain.value = Math.max(0, Math.min(1, value));
    }
  }
  
  /**
   * Gets the appropriate category for a sound
   * @param {string} name - Sound name
   * @returns {string} Category name
   */
  _getSoundCategory(name) {
    return this.soundCategoryMap[name] || 'ambient';
  }
  
  /**
   * Loads an audio file and caches it.
   * @param {string} name - Sound key.
   * @param {string} url - Audio file URL.
   * @param {string} category - Optional override for the sound category
   */
  loadSound(name, url, category = null) {
    // If category is provided, map this sound to that category
    if (category && this.soundCategories[category]) {
      this.soundCategoryMap[name] = category;
    }
    
    // Load sound using fetch for Web Audio API
    fetch(url)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Network response failed for sound ${name}: ${response.status} ${response.statusText}`);
        }
        return response.arrayBuffer();
      })
      .then(arrayBuffer => this.audioContext.decodeAudioData(arrayBuffer))
      .then(audioBuffer => {
        this.buffers[name] = audioBuffer;
        console.log(`Loaded sound "${name}" as AudioBuffer from ${url}`);
        
        // Initialize sound pool for this sound
        const soundCategory = this._getSoundCategory(name);
        const poolSize = this.soundCategories[soundCategory].maxInstances;
        
        // Create pool for this sound
        this.soundPools[name] = Array(poolSize).fill().map(() => ({
          source: null,
          gainNode: null,
          panner: null,
          active: false,
          startTime: 0
        }));
      })
      .catch(error => {
        console.error(`Error loading sound buffer "${name}" from ${url}:`, error);
      });
  }
  
  /**
   * Registers a sound as preloaded - used when sounds were preloaded during the name entry
   * @param {string} name - Sound key to register
   * @param {string} category - Optional override for the sound category
   */
  registerPreloadedSound(name, category = null) {
    // If category is provided, map this sound to that category
    if (category && this.soundCategories[category]) {
      this.soundCategoryMap[name] = category;
    }
    
    // Detect URL based on name
    const url = `sounds/${name}.mp3`;
    
    // When a sound is played, it will be lazy-loaded on first play
    console.log(`Registered preloaded sound "${name}" (will be loaded on first play)`);
    
    // Initialize sound pool for this sound
    const soundCategory = this._getSoundCategory(name);
    const poolSize = this.soundCategories[soundCategory].maxInstances;
    
    // Create pool for this sound
    this.soundPools[name] = Array(poolSize).fill().map(() => ({
      source: null,
      gainNode: null,
      panner: null,
      active: false,
      startTime: 0
    }));
  }
  
  /**
   * Adds a preloaded audio buffer directly to the SoundManager
   * @param {string} name - Sound name
   * @param {AudioBuffer} buffer - Preloaded audio buffer
   * @param {string} category - Optional category override 
   */
  addPreloadedBuffer(name, buffer, category = null) {
    // If category is provided, map this sound to that category
    if (category && this.soundCategories[category]) {
      this.soundCategoryMap[name] = category;
    }
    
    // Store the buffer directly
    this.buffers[name] = buffer;
    console.log(`Added preloaded audio buffer for "${name}"`);
    
    // Initialize sound pool for this sound
    const soundCategory = this._getSoundCategory(name);
    const poolSize = this.soundCategories[soundCategory].maxInstances;
    
    // Create pool for this sound
    this.soundPools[name] = Array(poolSize).fill().map(() => ({
      source: null,
      gainNode: null,
      panner: null,
      active: false,
      startTime: 0
    }));
  }
  
  /**
   * Cleanups and returns an available sound object from the pool
   * @param {string} name - Sound name
   * @returns {Object|null} Sound object from pool or null if none available
   */
  _getAvailableSoundFromPool(name) {
    if (!this.soundPools[name]) return null;
    
    const now = this.audioContext.currentTime;
    let oldestSoundIndex = -1;
    let oldestStartTime = Infinity;
    
    // First try to find an inactive sound
    for (let i = 0; i < this.soundPools[name].length; i++) {
      const sound = this.soundPools[name][i];
      
      // If sound is not active, use it
      if (!sound.active) {
        return sound;
      }
      
      // Keep track of the oldest sound in case we need to override it
      if (sound.startTime < oldestStartTime) {
        oldestStartTime = sound.startTime;
        oldestSoundIndex = i;
      }
    }
    
    // If we get here, all sounds are active, so use the oldest one
    if (oldestSoundIndex >= 0) {
      const sound = this.soundPools[name][oldestSoundIndex];
      
      // Stop the current sound if it's playing
      if (sound.source) {
        try {
          sound.source.stop();
        } catch (e) {
          // Ignore errors if already stopped
        }
      }
      
      return sound;
    }
    
    return null;
  }
  
  /**
   * Manage active sounds for a category, stopping older sounds if needed
   * @param {string} category - Sound category
   * @param {Object} soundObj - Sound object from pool
   */
  _manageActiveSoundsForCategory(category, soundObj) {
    const maxInstances = this.soundCategories[category].maxInstances;
    
    // Add this sound to the active sounds for this category
    this.activeSounds[category].push(soundObj);
    
    // If we have too many active sounds in this category, stop the oldest ones
    if (this.activeSounds[category].length > maxInstances) {
      // Sort by start time (oldest first)
      this.activeSounds[category].sort((a, b) => a.startTime - b.startTime);
      
      // Stop the oldest sounds to get back to the max
      while (this.activeSounds[category].length > maxInstances) {
        const oldestSound = this.activeSounds[category].shift();
        
        if (oldestSound && oldestSound.source) {
          try {
            oldestSound.source.stop();
          } catch (e) {
            // Ignore errors if already stopped
          }
          oldestSound.active = false;
        }
      }
    }
  }
  
  /**
   * Plays a sound with optional volume control
   * @param {string} name - The name of the sound to play
   * @param {number} cooldown - Minimum time between sound plays (ms)
   * @param {number} volume - Volume multiplier for this sound (0-1)
   * @param {boolean} loop - Whether the sound should loop
   * @returns {Object|null} Sound object for further control or null if not played
   */
  playSound(name, cooldown = 0, volume = 1.0, loop = false) {
    // Stronger duplicate protection for all sounds, especially gunshots
    const now = Date.now();
    
    // Group similar sounds together for cooldown purposes
    let soundGroup = name;
    
    // Special handling for shot sounds - treat them as the same group
    if (name === "shot" || name === "shotgunshot") {
      soundGroup = "gunshotSounds";
      cooldown = Math.max(cooldown, 50); // Use at least 50ms cooldown for shots
      
      // Check if any shot sound is in cooldown
      if (this.soundCooldowns[soundGroup] && (now - this.soundCooldowns[soundGroup] < cooldown)) {
        console.log(`Skipping ${name} sound (gunshot cooldown still active)`);
        return null;
      }
      
      // Record the time for the entire group
      this.soundCooldowns[soundGroup] = now;
      
      // Record time for the specific sound name too to track which one played
      this.soundCooldowns[name] = now;
      
      // Record the last shot time for other effects
      this.lastShotTime = now;
    }
    // For other sounds, use normal cooldown behavior
    else if (cooldown > 0) {
      if (this.soundCooldowns[name] && now - this.soundCooldowns[name] < cooldown) {
        return null;
      }
      this.soundCooldowns[name] = now;
    }
    
    // Special handling for gunshot sounds on mobile to prevent duplication issues
    if ((name === "shot" || name === "shotgunshot") && window.isMobile) {
      // On mobile, always use a compact sound buffer for gunshots to prevent issues
      // This helps with memory and performance on mobile devices
      if (window.isMobile && !this._mobileOptimized) {
        this._mobileOptimized = true;
        console.log("Optimizing audio for mobile device");
      }
    }
    
    if (!this.buffers[name]) {
      console.warn(`Sound "${name}" not loaded`);
      return null;
    }

    // Get category info
    const category = this._getSoundCategory(name);
    const maxInstances = this.soundCategories[category].maxInstances;

    // Find a free sound in the pool or create a new one
    let soundObj = this._getAvailableSoundFromPool(name);
    if (!soundObj) {
      return null; // No available sound in pool
    }

    // Get buffer
    const buffer = this.buffers[name];

    // Setup audio source
    soundObj.source = this.audioContext.createBufferSource();
    soundObj.source.buffer = buffer;
    soundObj.source.loop = loop;

    // Create a gain node for volume control
    soundObj.gainNode = this.audioContext.createGain();
    soundObj.gainNode.gain.value = volume;

    // Connect the source to gain, then gain to the category gain
    soundObj.source.connect(soundObj.gainNode);
    soundObj.gainNode.connect(this.categoryGains[category]);

    // Add reverb if available for certain categories
    if (category === 'weapon' && this.reverbSend && this.convolver) {
      // Create a gain node for reverb send amount
      soundObj.reverbAmount = this.audioContext.createGain();
      soundObj.reverbAmount.gain.value = 0.1; // 10% reverb
      
      // Send from gainNode to reverb
      soundObj.gainNode.connect(soundObj.reverbAmount);
      soundObj.reverbAmount.connect(this.reverbSend);
    }

    // Mark as active
    soundObj.active = true;
    soundObj.startTime = this.audioContext.currentTime;
    soundObj.source.onended = () => {
      soundObj.active = false;
      
      // Remove from active sounds list
      const index = this.activeSounds[category].indexOf(soundObj);
      if (index !== -1) {
        this.activeSounds[category].splice(index, 1);
      }
    };

    // Start playback
    try {
      soundObj.source.start(0);
      
      // Add to active sounds for this category
      this.activeSounds[category].push(soundObj);
      
      return soundObj;
    } catch (e) {
      console.error(`Error playing sound "${name}":`, e);
      return null;
    }
  }
  
  /**
   * Plays a sound at a given 3D position using the Web Audio API.
   * @param {string} name - Sound key.
   * @param {THREE.Vector3} position - 3D position for the sound.
   * @param {number} cooldown - Optional cooldown in milliseconds.
   * @param {number} volume - Optional volume multiplier.
   * @param {boolean} loop - Whether the sound should loop
   * @param {boolean} spatialize - Whether to apply 3D audio positioning (default: true)
   * @returns {Object} - Sound object for reference
   */
  playSoundAt(name, position, cooldown = 0, volume = 1.0, loop = false, spatialize = true) {
    if (!this.buffers[name]) {
      // Only log this error once per sound name to reduce log spam
      if (!this._reportedMissingSounds) {
        this._reportedMissingSounds = new Set();
      }
      
      if (!this._reportedMissingSounds.has(name)) {
        console.error(`Sound "${name}" not loaded.`);
        this._reportedMissingSounds.add(name);
      }
      return;
    }
    
    // Check cooldown if specified
    if (cooldown > 0) {
      const now = Date.now();
      if (this.soundCooldowns[name] && now - this.soundCooldowns[name] < cooldown) {
        // Still in cooldown period
        return;
      }
      this.soundCooldowns[name] = now;
    }
    
    // Get sound category
    const category = this._getSoundCategory(name);
    
    // Get an available sound from the pool
    const soundObj = this._getAvailableSoundFromPool(name);
    if (!soundObj) {
      console.warn(`No available sound objects for ${name}`);
      return;
    }
    
    try {
      // Clean up previous nodes if they exist
      if (soundObj.gainNode) {
        soundObj.gainNode.disconnect();
      }
      if (soundObj.panner) {
        soundObj.panner.disconnect();
      }
      
      // Create new audio nodes
      soundObj.source = this.audioContext.createBufferSource();
      soundObj.source.buffer = this.buffers[name];
      soundObj.source.loop = loop;
      
      // Create gain node for individual volume control
      soundObj.gainNode = this.audioContext.createGain();
      soundObj.gainNode.gain.value = volume;
      
      // For spatialized audio, create and configure a panner node
      if (spatialize) {
        // Create 3D panner node with improved settings
        soundObj.panner = this.audioContext.createPanner();
        soundObj.panner.panningModel = 'HRTF';
        soundObj.panner.distanceModel = 'inverse';
        
        // Adjust reference distance based on sound type for better perception
        if (category === 'weapon') {
          // For weapon sounds, add a subtle highpass filter to make them sharper
          soundObj.filter = this.audioContext.createBiquadFilter();
          soundObj.filter.type = 'highpass';
          soundObj.filter.frequency.value = 80; // Cut very low frequencies
          
          // Gunshots should sound closer and louder
          soundObj.panner.refDistance = 2;
          soundObj.panner.maxDistance = 10000;
          soundObj.panner.rolloffFactor = 0.8; // Reduced rolloff for weapons
          
          // Connect source -> filter -> panner -> gain
          soundObj.source.connect(soundObj.filter);
          soundObj.filter.connect(soundObj.panner);
          
          // If reverb is available, send a portion of the sound to reverb
          if (this.reverbSend && this.convolver) {
            // Create a gain node for reverb send amount
            soundObj.reverbAmount = this.audioContext.createGain();
            soundObj.reverbAmount.gain.value = 0.15; // 15% reverb
            
            // Send from filter to reverb
            soundObj.filter.connect(soundObj.reverbAmount);
            soundObj.reverbAmount.connect(this.reverbSend);
          }
        } else if (category === 'impact') {
          // Impact sounds should be distinct
          soundObj.panner.refDistance = 1.5;
          soundObj.panner.maxDistance = 5000;
          soundObj.panner.rolloffFactor = 1;
          
          // Connect source -> panner
          soundObj.source.connect(soundObj.panner);
        } else {
          // Default settings for other sounds
          soundObj.panner.refDistance = 1;
          soundObj.panner.maxDistance = 10000;
          soundObj.panner.rolloffFactor = 1;
          
          // Connect source -> panner
          soundObj.source.connect(soundObj.panner);
        }
        
        // Omnidirectional cone settings
        soundObj.panner.coneInnerAngle = 360;
        soundObj.panner.coneOuterAngle = 0;
        soundObj.panner.coneOuterGain = 0;
        soundObj.panner.setPosition(position.x, position.y, position.z);
        
        // Connect panner -> gain
        soundObj.panner.connect(soundObj.gainNode);
      } else {
        // Add similar processing for non-spatialized sounds
        if (category === 'weapon') {
          // For weapon sounds, add a subtle highpass filter
          soundObj.filter = this.audioContext.createBiquadFilter();
          soundObj.filter.type = 'highpass';
          soundObj.filter.frequency.value = 80;
          
          // Connect source -> filter -> gain
          soundObj.source.connect(soundObj.filter);
          soundObj.filter.connect(soundObj.gainNode);
          
          // If reverb is available, send a portion of the sound to reverb
          if (this.reverbSend && this.convolver) {
            // Create a gain node for reverb send amount
            soundObj.reverbAmount = this.audioContext.createGain();
            soundObj.reverbAmount.gain.value = 0.15; // 15% reverb
            
            // Send from filter to reverb
            soundObj.filter.connect(soundObj.reverbAmount);
            soundObj.reverbAmount.connect(this.reverbSend);
          }
        } else {
          // Non-spatialized audio connects directly to gain
          soundObj.source.connect(soundObj.gainNode);
        }
      }
      
      // Final connection to category gain
      soundObj.gainNode.connect(this.categoryGains[category]);
      
      // Mark as active and track start time
      soundObj.active = true;
      soundObj.startTime = this.audioContext.currentTime;
      
      // Start playing
      soundObj.source.start(0);
      
      // When the sound ends, mark it as inactive
      soundObj.source.onended = () => {
        soundObj.active = false;
        // Remove from active sounds list
        const index = this.activeSounds[category].indexOf(soundObj);
        if (index !== -1) {
          this.activeSounds[category].splice(index, 1);
        }
      };
      
      // Manage active sounds for this category
      this._manageActiveSoundsForCategory(category, soundObj);
      
      // Return the sound object for reference
      return soundObj;
    } catch (error) {
      console.error(`Error playing positional sound "${name}":`, error);
      soundObj.active = false;
      return null;
    }
  }
  
  /**
   * Updates the position of the listener in 3D space
   * @param {THREE.Vector3} position - Position of the listener
   * @param {THREE.Vector3} front - Front direction vector
   * @param {THREE.Vector3} up - Up direction vector
   */
  updateListenerPosition(position, front, up) {
    if (!position || !front || !up) return;
    
    try {
      const listener = this.audioContext.listener;
      
      // Set position
      if (listener.positionX) {
        // Modern browsers with AudioListener object
        listener.positionX.setValueAtTime(position.x, this.audioContext.currentTime);
        listener.positionY.setValueAtTime(position.y, this.audioContext.currentTime);
        listener.positionZ.setValueAtTime(position.z, this.audioContext.currentTime);
        
        // Set orientation (forward and up vectors)
        listener.forwardX.setValueAtTime(front.x, this.audioContext.currentTime);
        listener.forwardY.setValueAtTime(front.y, this.audioContext.currentTime);
        listener.forwardZ.setValueAtTime(front.z, this.audioContext.currentTime);
        listener.upX.setValueAtTime(up.x, this.audioContext.currentTime);
        listener.upY.setValueAtTime(up.y, this.audioContext.currentTime);
        listener.upZ.setValueAtTime(up.z, this.audioContext.currentTime);
      } else {
        // Older browsers with deprecated methods
        listener.setPosition(position.x, position.y, position.z);
        listener.setOrientation(front.x, front.y, front.z, up.x, up.y, up.z);
      }
    } catch (error) {
      console.error('Error updating listener position:', error);
    }
  }
  
  /**
   * Stops all currently playing sounds in a category
   * @param {string} category - Sound category to stop
   */
  stopCategorySounds(category) {
    if (!this.activeSounds[category]) return;
    
    for (const sound of this.activeSounds[category]) {
      if (sound.source) {
        try {
          sound.source.stop();
        } catch (e) {
          // Ignore errors if already stopped
        }
        sound.active = false;
      }
    }
    
    // Clear the active sounds array for this category
    this.activeSounds[category] = [];
  }
  
  /**
   * Stops all currently playing sounds
   */
  stopAllSounds() {
    for (const category in this.activeSounds) {
      this.stopCategorySounds(category);
    }
  }
  
  /**
   * Optimized method for footstep sounds
   * @param {string} foot - 'left' or 'right'
   * @param {THREE.Vector3} position - 3D position
   * @param {number} volume - Volume
   */
  playFootstep(foot, position, volume = 1.0) {
    const soundName = foot === 'left' ? 'leftstep' : 'rightstep';
    
    // Footsteps use a mix of non-spatial and spatial audio for better perception
    // Play a direct sound at lower volume
    this.playSound(soundName, 50, volume * 0.4);
    
    // And a spatial sound at the foot position
    this.playSoundAt(soundName, position, 50, volume * 0.7);
  }
}

================================================
File: /public/js/train-animation.js
================================================
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb); // Sky blue background

// Camera setup
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 50, 100);

// Renderer setup
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

// Lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 5, 5);
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.width = 2048;
directionalLight.shadow.mapSize.height = 2048;
scene.add(directionalLight);

// Ground
const groundGeometry = new THREE.PlaneGeometry(200, 200);
const groundMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x228B22,  // Forest green
    side: THREE.DoubleSide 
});
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// Create a circular path
const radius = 50; // 100m diameter means 50m radius
const numPoints = 100;
const points = [];

for (let i = 0; i < numPoints; i++) {
    const angle = (i / numPoints) * Math.PI * 2;
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;
    points.push(new THREE.Vector3(x, 0, z));
}

// Create closed loop
points.push(points[0].clone());

// Create spline from points
const spline = new THREE.CatmullRomCurve3(points);
spline.closed = true;

// Visualize the path with a line
const pathGeometry = new THREE.BufferGeometry().setFromPoints(spline.getPoints(200));
const pathMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
const pathLine = new THREE.Line(pathGeometry, pathMaterial);
scene.add(pathLine);

// Variables for animation
let train;
let trainLoaded = false;
let progress = 0;

// Load train model
const loader = new GLTFLoader();
loader.load(
    '../models/train.glb',
    (gltf) => {
        train = gltf.scene;
        train.traverse((node) => {
            if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
            }
        });
        
        // Scale and position the train
        train.scale.set(2, 2, 2);
        train.position.y = 0; // Adjust as needed based on the model
        
        // Add to scene
        scene.add(train);
        trainLoaded = true;
        
        console.log('Train model loaded successfully');
    },
    (xhr) => {
        console.log(`Loading: ${(xhr.loaded / xhr.total) * 100}% loaded`);
    },
    (error) => {
        console.error('Error loading train model:', error);
    }
);

// Handle window resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Animation loop
function animate() {
    requestAnimationFrame(animate);
    
    // Update controls
    controls.update();
    
    // Move the train along the path
    if (trainLoaded) {
        // Increment progress
        progress += 0.0005; // Adjust speed here
        if (progress > 1) progress = 0;
        
        // Get position on the path
        const position = spline.getPointAt(progress);
        train.position.copy(position);
        
        // Orient the train to follow the path
        const tangent = spline.getTangentAt(progress).normalize();
        
        // Make the train rotate to face the direction of motion
        // We're assuming the train's forward axis is along the z-axis
        const up = new THREE.Vector3(0, 1, 0);
        const axis = new THREE.Vector3().crossVectors(up, tangent).normalize();
        
        // Calculate the rotation angle
        const radians = Math.acos(up.dot(tangent));
        
        // Apply the rotation - use quaternion to avoid gimbal lock
        train.quaternion.setFromAxisAngle(axis, radians);
        
        // Rotate 90 degrees on Y to align with track
        train.rotateY(Math.PI / 2);
    }
    
    // Render
    renderer.render(scene, camera);
}

animate(); 

================================================
File: /public/js/tumbleweed.js
================================================
/**
 * Handles tumbleweeds that spawn around the town and travel across the desert.
 */

/**
 * Represents a single tumbleweed in the world.
 */
export class Tumbleweed {
    constructor(scene, position, direction) {
      this.scene = scene;
      this.position = position || new THREE.Vector3(0, 0, 0);
      this.direction = direction || new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
      
      // Initialize properties
      this.initProperties();
      
      // Create group and add to scene
      this.group = new THREE.Group();
      this.group.position.copy(this.position);
      this.isLoaded = false;
      scene.add(this.group);
      
      // Load the model
      this.loadTumbleweedModel();
    }
  
    initProperties() {
      // Speed variables
      this.baseSpeed = 0.05 + Math.random() * 0.03;
      this.currentSpeed = this.baseSpeed;
      this.targetSpeed = this.currentSpeed;
      this.minSpeedMultiplier = 0.5;
      this.maxSpeedMultiplier = 1.8;
      this.speedChangeTimer = 0;
      this.speedChangeInterval = 2 + Math.random() * 3;
      
      // Bounce variables
      this.baseHeight = 0.2;
      this.bounceHeight = 0.5 + Math.random() * 0.8;
      this.currentBounceHeight = 0;
      this.isBouncing = Math.random() < 0.7;
      this.targetBounceHeight = this.isBouncing ? this.bounceHeight : 0;
      this.bounceFrequency = 0.3 + Math.random() * 0.3;
      this.bounceTime = Math.random() * Math.PI * 2;
      this.bouncePhaseTimer = 0;
      this.bouncePhaseInterval = 3 + Math.random() * 5;
      
      // Transition rates
      this.speedTransitionRate = 0.5;
      this.bounceTransitionRate = 0.2;
      
      // Animation properties
      this.animationMixer = null;
      this.animations = {};
      this.rotationAxis = new THREE.Vector3(0, 1, 0);
      this.rotationSpeed = 0.5 + Math.random() * 0.5;
      this.lastBounceHeight = 0;
      
      // Distance properties
      this.maxDistance = 800;
      this.distanceTraveled = 0;
      
      // Collision properties
      this.hitbox = new THREE.Sphere(this.position.clone(), 2.0);
      this.isExploding = false;
      this.explosionStartTime = 0;
      this.explosionDuration = 3.0;
      this.fragmentMeshes = [];
      this.fragmentVelocities = [];
      this.fragmentRotations = [];
      this.fragmentGroundTime = [];
      this.dustParticles = null;
    }
  
    /**
     * Loads the tumbleweed model and animations
     */
    loadTumbleweedModel() {
      // Try to use preloaded model first
      if (window.preloadedModels && (window.preloadedModels.tumbleweed || window.preloadedModels.tumbleweed_clone)) {
        try {
          const preloadedModel = window.preloadedModels.tumbleweed_clone || window.preloadedModels.tumbleweed;
          const gltf = {
            scene: preloadedModel.scene.clone(),
            animations: preloadedModel.animations
          };
          
          this.setupModel(gltf);
          return;
        } catch (e) {
          console.error('Error using preloaded tumbleweed model:', e);
        }
      }
      
      // Fall back to loading model from file
      new THREE.GLTFLoader().load(
        'models/tumbleweed.glb', 
        gltf => this.setupModel(gltf),
        undefined,
        error => console.error('Error loading tumbleweed.glb model:', error)
      );
    }
    
    setupModel(gltf) {
      this.model = gltf.scene;
      this.model.position.set(0, 0, 0);
      
      // Scale model
      const scale = 1.5 + Math.random() * 1.0;
      this.model.scale.set(scale, scale, scale);
      
      this.group.add(this.model);
      
      // Setup materials and shadows
      this.model.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
          
          if (child.material) {
            if (child.isSkinnedMesh) child.material.skinning = true;
            child.material.needsUpdate = true;
          }
        }
      });
      
      // Set up animations
      if (gltf.animations && gltf.animations.length > 0) {
        this.setupAnimations(gltf.animations);
      }
      
      this.storeFragmentMeshes();
      this.isLoaded = true;
    }
    
    /**
     * Store references to fragment meshes
     */
    storeFragmentMeshes() {
      this.fragmentMeshes = [];
      
      this.model.traverse(child => {
        if (child.isMesh && child.name && child.name.match(/fragment[1-8]/i)) {
          this.fragmentMeshes.push(child);
          
          // Store original transform data
          child.userData = {
            originalPosition: child.position.clone(),
            originalRotation: child.rotation.clone(),
            originalQuaternion: child.quaternion.clone(),
            originalScale: child.scale.clone(),
            originalVisibility: child.visible
          };
        }
      });
    }
  
    /**
     * Sets up animations from the loaded model
     * @param {Array} animations - The animations from the GLB file
     */
    setupAnimations(animations) {
      if (!animations || animations.length === 0) return;
      
      this.animationMixer = new THREE.AnimationMixer(this.model);
      
      animations.forEach(animation => {
        this.animations[animation.name] = this.animationMixer.clipAction(animation);
        
        if (animation.name === 'tumble') {
          const anim = this.animations[animation.name];
          anim.setLoop(THREE.LoopRepeat);
          anim.clampWhenFinished = false;
          anim.fadeIn(0.5);
          anim.zeroSlopeAtEnd = true;
          anim.zeroSlopeAtStart = true;
          anim.play();
        }
      });
    }
    
    /**
     * Handles collision with a bullet
     * @returns {boolean} True if hit was successful
     */
    hit() {
      if (!this.isLoaded || this.isExploding) return false;
      this.explode();
      return true;
    }
    
    /**
     * Start the explosion/shattering effect
     */
    explode() {
      if (!this.isLoaded || this.isExploding) return;
      
      this.isExploding = true;
      this.explosionStartTime = performance.now() / 1000.0;
      
      if (this.animations['tumble']) {
        this.animations['tumble'].stop();
      }
      
      this.playExplosionSound();
      this.setupFragmentPhysics();
      this.createDustEffect();
    }
    
    playExplosionSound() {
      const soundSources = [
        window.soundManager,
        window.localPlayer?.soundManager
      ];
      
      const soundSource = soundSources.find(s => s);
      if (!soundSource) return;
      
      if (!soundSource.buffers['tumbleweedexplode']) {
        soundSource.loadSound('tumbleweedexplode', 'sounds/tumbleweedexplode.mp3', 'impact');
      }
      
      soundSource.playSound('tumbleweedexplode', 0, 0.8 + Math.random() * 0.4, false);
    }
    
    setupFragmentPhysics() {
      this.fragmentVelocities = [];
      this.fragmentRotations = [];
      this.fragmentGroundTime = [];
      
      for (let i = 0; i < this.fragmentMeshes.length; i++) {
        const angle = Math.random() * Math.PI * 2;
        const upwardBias = 0.3 + Math.random() * 0.5;
        
        const velocity = new THREE.Vector3(
          Math.cos(angle) * (0.15 + Math.random() * 0.25),
          upwardBias,
          Math.sin(angle) * (0.15 + Math.random() * 0.25)
        );
        
        const rotation = new THREE.Vector3(
          (Math.random() - 0.5) * 5,
          (Math.random() - 0.5) * 5,
          (Math.random() - 0.5) * 5
        );
        
        this.fragmentVelocities.push(velocity);
        this.fragmentRotations.push(rotation);
        this.fragmentGroundTime.push(0);
      }
    }
    
    /**
     * Creates a dust particle effect for the tumbleweed explosion
     */
    createDustEffect() {
      if (window.effects && window.effects.createSmokeEffect) {
        this.dustParticles = window.effects.createSmokeEffect(
          this.group.position.clone(),
          new THREE.Vector3(0, 1, 0),
          this.scene
        );
        return;
      }
      
      // Create custom particle system
      const numParticles = 25;
      const dustGroup = new THREE.Group();
      dustGroup.position.copy(this.group.position);
      this.scene.add(dustGroup);
      
      const particles = [];
      
      for (let i = 0; i < numParticles; i++) {
        const size = 0.08 + Math.random() * 0.25;
        const geometry = i % 5 === 0 ? 
          new THREE.IcosahedronGeometry(size, 1) : 
          new THREE.IcosahedronGeometry(size, 0);
        
        const colorVariation = Math.random();
        const dustColor = new THREE.Color(
          0.6 + colorVariation * 0.2,
          0.5 + colorVariation * 0.2,
          0.4 + colorVariation * 0.15
        );
        
        const material = new THREE.MeshBasicMaterial({
          color: dustColor,
          transparent: true,
          opacity: 0.15 + Math.random() * 0.2,
          depthWrite: false
        });
        
        const particle = new THREE.Mesh(geometry, material);
        
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 0.5;
        const isGroundDust = Math.random() < 0.4;
        
        particle.position.set(
          Math.cos(angle) * radius,
          isGroundDust ? 0.05 + Math.random() * 0.1 : 0.1 + Math.random() * 0.4,
          Math.sin(angle) * radius
        );
        
        particle.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );
        
        dustGroup.add(particle);
        
        const vel = new THREE.Vector3(
          (Math.random() - 0.5) * 0.5,
          isGroundDust ? 0.05 + Math.random() * 0.15 : 0.2 + Math.random() * 0.4,
          (Math.random() - 0.5) * 0.5
        );
        
        particles.push({
          mesh: particle,
          velocity: vel,
          rotationSpeed: new THREE.Vector3(
            (Math.random() - 0.5) * 1.5,
            (Math.random() - 0.5) * 1.5,
            (Math.random() - 0.5) * 1.5
          ),
          life: 0,
          maxLife: isGroundDust ? 1.5 + Math.random() * 1.0 : 1.0 + Math.random() * 1.5,
          isGroundDust
        });
      }
      
      this.dustParticles = { dustGroup, particles };
    }
  
    /**
     * Updates the tumbleweed's position and animation
     * @param {number} deltaTime - Time elapsed since last frame
     */
    update(deltaTime) {
      if (!this.isLoaded) return false;
      
      const cappedDelta = Math.min(deltaTime, 0.1);
      this.hitbox.center.copy(this.group.position);
      
      return this.isExploding ? 
        this.updateExploding(cappedDelta) : 
        this.updateNormal(cappedDelta);
    }
    
    updateNormal(deltaTime) {
      // Update speed
      this.updateSpeed(deltaTime);
      
      // Update bounce
      this.updateBounce(deltaTime);
      
      // Update animation
      if (this.animationMixer) {
        this.animationMixer.update(deltaTime);
      }
      
      // Calculate movement
      const movement = this.direction.clone().multiplyScalar(this.currentSpeed);
      
      // Update position
      this.group.position.x += movement.x;
      this.group.position.z += movement.z;
      
      // Calculate bounce offset
      const bounceWave = Math.abs(Math.sin(this.bounceTime));
      const smoothBounceOffset = bounceWave * this.currentBounceHeight;
      this.lastBounceHeight = smoothBounceOffset;
      
      // Apply vertical position
      this.group.position.y = this.baseHeight + smoothBounceOffset;
      
      // Update distance traveled
      this.distanceTraveled += movement.length();
      
      // Update orientation
      this.group.lookAt(this.group.position.clone().add(this.direction));
      
      return this.distanceTraveled > this.maxDistance;
    }
    
    updateSpeed(deltaTime) {
      // Update speed change timer
      this.speedChangeTimer += deltaTime;
      if (this.speedChangeTimer >= this.speedChangeInterval) {
        this.speedChangeTimer = 0;
        this.targetSpeed = this.baseSpeed * (this.minSpeedMultiplier + Math.random() * (this.maxSpeedMultiplier - this.minSpeedMultiplier));
        this.speedChangeInterval = 2 + Math.random() * 3;
      }
      
      // Smooth transition to target speed
      const speedDiff = this.targetSpeed - this.currentSpeed;
      if (Math.abs(speedDiff) > 0.0001) {
        const step = Math.min(Math.abs(speedDiff), this.speedTransitionRate * deltaTime);
        this.currentSpeed += Math.sign(speedDiff) * step;
      }
    }
    
    updateBounce(deltaTime) {
      // Update bounce phase timer
      this.bouncePhaseTimer += deltaTime;
      if (this.bouncePhaseTimer >= this.bouncePhaseInterval) {
        this.bouncePhaseTimer = 0;
        this.isBouncing = Math.random() < 0.7;
        this.targetBounceHeight = this.isBouncing ? this.bounceHeight : 0;
        this.bouncePhaseInterval = 3 + Math.random() * 5;
      }
      
      // Smooth transition to target bounce height
      const bounceDiff = this.targetBounceHeight - this.currentBounceHeight;
      if (Math.abs(bounceDiff) > 0.0001) {
        const step = Math.min(Math.abs(bounceDiff), this.bounceTransitionRate * deltaTime);
        this.currentBounceHeight += Math.sign(bounceDiff) * step;
      }
      
      // Update bounce time
      this.bounceTime += deltaTime * this.bounceFrequency * Math.PI * 2;
    }
    
    updateExploding(deltaTime) {
      const currentTime = performance.now() / 1000.0;
      const explosionTime = currentTime - this.explosionStartTime;
      const explosionProgress = Math.min(explosionTime / this.explosionDuration, 1.0);
      
      // Update fragments
      this.updateFragments(deltaTime);
      
      // Update dust particles
      this.updateDustEffect(deltaTime, explosionProgress);
      
      // Return true when explosion is complete
      return explosionTime > this.explosionDuration;
    }
    
    updateFragments(deltaTime) {
      for (let i = 0; i < this.fragmentMeshes.length; i++) {
        const fragment = this.fragmentMeshes[i];
        const velocity = this.fragmentVelocities[i];
        const rotation = this.fragmentRotations[i];
        
        const isOnGround = fragment.position.y <= 0.05;
        
        if (isOnGround) {
          // Ground logic
          this.fragmentGroundTime[i] += deltaTime;
          fragment.position.y = 0.05;
          
          velocity.y = 0;
          velocity.x *= 0.7;
          velocity.z *= 0.7;
          
          if (this.fragmentGroundTime[i] > 0.2) {
            rotation.set(0, 0, 0);
          } else {
            rotation.x *= 0.7;
            rotation.z *= 0.7;
          }
          
          if (this.fragmentGroundTime[i] > 1.5) {
            const sinkProgress = Math.min((this.fragmentGroundTime[i] - 1.5) / 0.8, 1.0);
            fragment.position.y = 0.05 * (1.0 - sinkProgress);
            
            if (fragment.material && fragment.material.opacity !== undefined) {
              fragment.material.opacity = 1.0 - sinkProgress;
              fragment.material.transparent = true;
            }
          }
        } else {
          // Air logic
          velocity.y -= deltaTime * 0.9;
          
          fragment.position.x += velocity.x * deltaTime * 8;
          fragment.position.y += velocity.y * deltaTime * 8;
          fragment.position.z += velocity.z * deltaTime * 8;
          
          fragment.rotation.x += rotation.x * deltaTime;
          fragment.rotation.y += rotation.y * deltaTime;
          fragment.rotation.z += rotation.z * deltaTime;
          
          velocity.x *= 0.95;
          velocity.z *= 0.95;
          
          this.fragmentGroundTime[i] = 0;
        }
      }
    }
    
    updateDustEffect(deltaTime, explosionProgress) {
      if (!this.dustParticles) return;
      if (!this.dustParticles.particles) return;
      
      let anyAlive = false;
      
      for (const particle of this.dustParticles.particles) {
        particle.life += deltaTime;
        
        if (particle.life >= particle.maxLife) {
          particle.mesh.visible = false;
          continue;
        }
        
        anyAlive = true;
        const lifeProgress = particle.life / particle.maxLife;
        
        if (particle.isGroundDust) {
          this.updateGroundDustParticle(particle, deltaTime, lifeProgress);
        } else {
          this.updateAirborneDustParticle(particle, deltaTime, lifeProgress);
        }
      }
      
      if (!anyAlive && explosionProgress > 0.5) {
        this.cleanupDustEffect();
      }
    }
    
    updateGroundDustParticle(particle, deltaTime, lifeProgress) {
      particle.velocity.y -= deltaTime * 0.1;
      
      if (particle.mesh.position.y < 0.02) {
        particle.mesh.position.y = 0.02;
        particle.velocity.y = Math.max(0, particle.velocity.y);
      }
      
      const groundDampening = 1.0 - lifeProgress * 0.7;
      
      particle.mesh.position.x += particle.velocity.x * deltaTime * groundDampening * 1.5;
      particle.mesh.position.y += particle.velocity.y * deltaTime * groundDampening;
      particle.mesh.position.z += particle.velocity.z * deltaTime * groundDampening * 1.5;
      
      particle.mesh.rotation.x += particle.rotationSpeed.x * deltaTime * 0.5;
      particle.mesh.rotation.y += particle.rotationSpeed.y * deltaTime * 0.5;
      particle.mesh.rotation.z += particle.rotationSpeed.z * deltaTime * 0.5;
      
      const opacityFactor = lifeProgress < 0.6 ? 0.5 : 0.5 - (lifeProgress - 0.6) * 2.5;
      particle.mesh.material.opacity = 0.25 * opacityFactor;
      
      const scale = 1.0 + lifeProgress * 2.5;
      particle.mesh.scale.set(scale, scale * 0.6, scale);
    }
    
    updateAirborneDustParticle(particle, deltaTime, lifeProgress) {
      particle.velocity.y -= deltaTime * 0.2;
      
      const dampening = 1.0 - lifeProgress * 0.5;
      
      particle.mesh.position.x += particle.velocity.x * deltaTime * dampening;
      particle.mesh.position.y += particle.velocity.y * deltaTime * dampening;
      particle.mesh.position.z += particle.velocity.z * deltaTime * dampening;
      
      particle.mesh.rotation.x += particle.rotationSpeed.x * deltaTime * dampening;
      particle.mesh.rotation.y += particle.rotationSpeed.y * deltaTime * dampening;
      particle.mesh.rotation.z += particle.rotationSpeed.z * deltaTime * dampening;
      
      const opacityFactor = Math.pow(1.0 - lifeProgress, 1.5);
      particle.mesh.material.opacity = 0.2 * opacityFactor;
      
      const scale = 1.0 + lifeProgress * 2.0;
      particle.mesh.scale.set(scale, scale, scale);
    }
    
    cleanupDustEffect() {
      if (!this.dustParticles || !this.dustParticles.particles) return;
      
      this.scene.remove(this.dustParticles.dustGroup);
      
      for (const particle of this.dustParticles.particles) {
        if (particle.mesh) {
          if (particle.mesh.geometry) particle.mesh.geometry.dispose();
          if (particle.mesh.material) particle.mesh.material.dispose();
        }
      }
      
      this.dustParticles = null;
    }
  
    /**
     * Removes the tumbleweed from the scene
     */
    remove() {
      this.scene.remove(this.group);
      
      if (this.dustParticles) {
        this.cleanupDustEffect();
      }
      
      if (this.model) {
        this.model.traverse(child => {
          if (child.isMesh) {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
              if (Array.isArray(child.material)) {
                child.material.forEach(material => material.dispose());
              } else {
                child.material.dispose();
              }
            }
          }
        });
      }
    }
    
    /**
     * Resets the tumbleweed for reuse
     */
    reset() {
      this.isExploding = false;
      
      if (this.fragmentMeshes && this.fragmentMeshes.length > 0) {
        for (const fragment of this.fragmentMeshes) {
          // Restore original transform
          if (fragment.userData.originalPosition) {
            fragment.position.copy(fragment.userData.originalPosition);
          }
          
          if (fragment.userData.originalRotation) {
            fragment.rotation.copy(fragment.userData.originalRotation);
          }
          
          if (fragment.userData.originalQuaternion) {
            fragment.quaternion.copy(fragment.userData.originalQuaternion);
          }
          
          if (fragment.userData.originalScale) {
            fragment.scale.copy(fragment.userData.originalScale);
          }
          
          fragment.visible = fragment.userData.originalVisibility !== undefined ? 
            fragment.userData.originalVisibility : true;
        }
      }
      
      if (this.dustParticles) {
        this.cleanupDustEffect();
      }
      
      if (this.animations['tumble']) {
        this.animations['tumble'].reset();
        this.animations['tumble'].play();
      }
    }
  }
  
  /**
   * Manages multiple tumbleweeds in the scene
   */
  export class TumbleweedManager {
    constructor(scene, townDimensions) {
      this.scene = scene;
      this.townDimensions = townDimensions;
      this.tumbleweeds = [];
      this.tumbleweedPool = [];
      
      this.maxTumbleweeds = 5;
      this.spawnTimer = 0;
      this.spawnInterval = 5 + Math.random() * 3;
      
      this.preloadExplosionSound();
      this.initialSpawn();
    }
  
    preloadExplosionSound() {
      const tryLoadSound = (soundManager) => {
        if (soundManager) {
          soundManager.loadSound('tumbleweedexplode', 'sounds/tumbleweedexplode.mp3', 'impact');
        }
      };
      
      tryLoadSound(window.soundManager);
      tryLoadSound(window.localPlayer?.soundManager);
      
      // Retry a few times in case sound manager isn't loaded yet
      let retryCount = 0;
      const maxRetries = 5;
      
      const retryLoad = () => {
        if (retryCount >= maxRetries) return;
        
        tryLoadSound(window.soundManager);
        tryLoadSound(window.localPlayer?.soundManager);
        
        if ((window.soundManager?.buffers?.tumbleweedexplode) || 
            (window.localPlayer?.soundManager?.buffers?.tumbleweedexplode)) {
          return;
        }
        
        retryCount++;
        setTimeout(retryLoad, 1000);
      };
      
      setTimeout(retryLoad, 1000);
    }
  
    initialSpawn() {
      const initialCount = 2 + Math.floor(Math.random() * 2);
      for (let i = 0; i < initialCount; i++) {
        this.spawnTumbleweed();
      }
    }
  
    getTumbleweed(position, direction) {
      let tumbleweed;
      
      if (this.tumbleweedPool.length > 0) {
        tumbleweed = this.tumbleweedPool.pop();
        
        // Reset tumbleweed
        tumbleweed.position.copy(position);
        tumbleweed.direction.copy(direction);
        tumbleweed.group.position.copy(position);
        tumbleweed.distanceTraveled = 0;
        tumbleweed.currentSpeed = tumbleweed.baseSpeed;
        tumbleweed.targetSpeed = tumbleweed.currentSpeed;
        tumbleweed.currentBounceHeight = 0;
        tumbleweed.targetBounceHeight = tumbleweed.isBouncing ? tumbleweed.bounceHeight : 0;
        tumbleweed.rotationSpeed = 0.5 + Math.random() * 0.5;
        
        tumbleweed.reset();
        this.scene.add(tumbleweed.group);
      } else {
        tumbleweed = new Tumbleweed(this.scene, position, direction);
      }
      
      return tumbleweed;
    }
  
    spawnTumbleweed() {
      if (this.tumbleweeds.length >= this.maxTumbleweeds) return;
      
      // Calculate spawn position
      const angle = Math.random() * Math.PI * 2;
      const townSize = Math.max(this.townDimensions.width, this.townDimensions.length);
      const distance = townSize * (0.8 + Math.random() * 0.5);
      
      const position = new THREE.Vector3(
        Math.cos(angle) * distance,
        0.5,
        Math.sin(angle) * distance
      );
      
      // Calculate direction
      let directionAngle;
      
      if (Math.random() < 0.8) {
        // 80% chance to cross through town
        directionAngle = angle + Math.PI + (Math.random() - 0.5) * Math.PI / 3;
      } else {
        // 20% chance for random direction
        directionAngle = angle + Math.PI + (Math.random() - 0.5) * Math.PI;
      }
      
      const direction = new THREE.Vector3(
        Math.cos(directionAngle),
        0,
        Math.sin(directionAngle)
      ).normalize();
      
      // Create and add tumbleweed
      const tumbleweed = this.getTumbleweed(position, direction);
      this.tumbleweeds.push(tumbleweed);
    }
  
    recycleTumbleweed(tumbleweed, index) {
      this.tumbleweeds.splice(index, 1);
      this.scene.remove(tumbleweed.group);
      this.tumbleweedPool.push(tumbleweed);
    }
    
    checkRayIntersection(raycaster) {
      for (let i = 0; i < this.tumbleweeds.length; i++) {
        const tumbleweed = this.tumbleweeds[i];
        
        if (!tumbleweed.isLoaded || tumbleweed.isExploding) continue;
        
        const intersection = raycaster.ray.intersectSphere(tumbleweed.hitbox, new THREE.Vector3());
        
        if (intersection) {
          tumbleweed.hit();
          
          return {
            tumbleweed,
            point: intersection,
            distance: intersection.distanceTo(raycaster.ray.origin)
          };
        }
      }
      
      return null;
    }
  
    update(deltaTime) {
      // Update spawn timer
      this.spawnTimer += deltaTime;
      if (this.spawnTimer >= this.spawnInterval) {
        this.spawnTimer = 0;
        this.spawnTumbleweed();
        this.spawnInterval = 5 + Math.random() * 3;
      }
      
      // Update all tumbleweeds
      for (let i = this.tumbleweeds.length - 1; i >= 0; i--) {
        const shouldRemove = this.tumbleweeds[i].update(deltaTime);
        
        if (shouldRemove) {
          this.recycleTumbleweed(this.tumbleweeds[i], i);
        }
      }
    }
    
    dispose() {
      // Remove all tumbleweeds
      this.tumbleweeds.forEach(tumbleweed => tumbleweed.remove());
      this.tumbleweeds = [];
      
      // Remove all pooled tumbleweeds
      this.tumbleweedPool.forEach(tumbleweed => tumbleweed.remove());
      this.tumbleweedPool = [];
    }
  } 

================================================
File: /public/js/ui.js
================================================
/**
 * Updates the ammo counter in the UI.
 * @param {Player} player - The player instance.
 */
export function updateAmmoUI(player) {
  const ammoCounter = document.getElementById('ammo-counter');
  if (ammoCounter && player) {
    ammoCounter.textContent = `Bullets: ${player.bullets}/${player.maxBullets}`;
  }
}

/**
* Updates the health counter in the UI.
* @param {Player|ThirdPersonModel} player - The player instance.
*/
export function updateHealthUI(player) {
  const healthCounter = document.getElementById('health-counter');
  if (healthCounter && player) {
    const healthText = `Health: ${player.health}`;
    healthCounter.textContent = healthText;
    
    // Add visual indication of health level
    if (player.health > 75) {
      healthCounter.style.color = '#4CAF50'; // Green for good health
    } else if (player.health > 30) {
      healthCounter.style.color = '#FFC107'; // Yellow/amber for medium health
    } else {
      healthCounter.style.color = '#F44336'; // Red for low health
    }
  }
}

/**
* Shows a damage indicator when the player takes damage.
* @param {number} damage - The amount of damage taken.
* @param {string} hitZone - The hit zone ('head', 'body', 'limbs').
*/
export function showDamageIndicator(damage, hitZone) {
  // Use static variables to track combined damage
  if (!showDamageIndicator.lastTime) {
    showDamageIndicator.lastTime = 0;
    showDamageIndicator.combinedDamage = 0;
    showDamageIndicator.lastHitZone = null;
    showDamageIndicator.pendingTimeoutId = null;
  }
  
  const now = performance.now();
  const timeSinceLastHit = now - showDamageIndicator.lastTime;
  
  // If this hit is within 50ms of the previous one (shotgun pellets typically arrive together),
  // or it's the same hit zone, combine the damage
  if (timeSinceLastHit < 50 || (hitZone === showDamageIndicator.lastHitZone && timeSinceLastHit < 150)) {
    // Add to the combined damage
    showDamageIndicator.combinedDamage += damage;
    showDamageIndicator.lastTime = now;
    showDamageIndicator.lastHitZone = hitZone;
    
    // Clear any pending timeout
    if (showDamageIndicator.pendingTimeoutId) {
      clearTimeout(showDamageIndicator.pendingTimeoutId);
    }
    
    // Set a new timeout to show the combined damage
    showDamageIndicator.pendingTimeoutId = setTimeout(() => {
      displayDamageIndicator(showDamageIndicator.combinedDamage, showDamageIndicator.lastHitZone);
      // Reset the tracking variables
      showDamageIndicator.combinedDamage = 0;
      showDamageIndicator.pendingTimeoutId = null;
    }, 50);
  } else {
    // This is a new hit, not part of a shotgun blast, show it immediately
    showDamageIndicator.lastTime = now;
    showDamageIndicator.lastHitZone = hitZone;
    showDamageIndicator.combinedDamage = damage;
    
    displayDamageIndicator(damage, hitZone);
  }
}

/**
* Helper function to display the damage indicator UI element
* @param {number} damage - The amount of damage to display
* @param {string} hitZone - The hit zone ('head', 'body', 'limbs')
*/
function displayDamageIndicator(damage, hitZone) {
  // Create damage indicator element if it doesn't exist
  let damageIndicator = document.getElementById('damage-indicator');
  if (!damageIndicator) {
      damageIndicator = document.createElement('div');
      damageIndicator.id = 'damage-indicator';
      damageIndicator.style.position = 'absolute';
      damageIndicator.style.top = '40%';
      damageIndicator.style.left = '50%';
      damageIndicator.style.transform = 'translate(-50%, -50%)';
      damageIndicator.style.color = 'red';
      damageIndicator.style.fontSize = '48px';
      damageIndicator.style.fontWeight = 'bold';
      damageIndicator.style.opacity = '0';
      damageIndicator.style.textShadow = '2px 2px 4px #000000';
      damageIndicator.style.transition = 'opacity 0.3s ease-in, opacity 0.5s ease-out';
      damageIndicator.style.zIndex = '1000';
      damageIndicator.style.pointerEvents = 'none';
      document.getElementById('game-container').appendChild(damageIndicator);
  }
  
  // Set text based on hit zone
  let hitText = `-${damage}`;
  if (hitZone) {
      switch (hitZone) {
          case 'head':
              hitText += ' HEADSHOT!';
              break;
          case 'body':
              hitText += ' (Body Shot)';
              break;
          case 'limbs':
              hitText += ' (Limb Shot)';
              break;
      }
  }
  
  // Display damage indicator
  damageIndicator.textContent = hitText;
  damageIndicator.style.opacity = '1';
  
  // Set color based on damage
  if (damage >= 100) {
      damageIndicator.style.color = '#FF0000'; // Bright red for headshots
      damageIndicator.style.fontSize = '64px';
  } else if (damage >= 40) {
      damageIndicator.style.color = '#FF4500'; // Orange-red for body shots
  } else {
      damageIndicator.style.color = '#FFA500'; // Orange for limb shots
  }
  
  // Fade out after a delay
  setTimeout(() => {
      damageIndicator.style.opacity = '0';
  }, 800);
}

/**
* Updates all UI elements related to player status.
* @param {Player} player - The player instance.
*/
export function updatePlayerUI(player) {
  updateAmmoUI(player);
  updateHealthUI(player);
}

================================================
File: /public/js/viewmodel-config.js
================================================
/**
 * Viewmodel Configuration Helper
 * Allows runtime adjustment of viewmodel position and scale
 */

// Disable debug mode for production
window.debugMode = false;

// Initialize viewmodel configuration when window loads
window.addEventListener('load', () => {
  // Check if we're in debug mode
  if (!window.debugMode) return;
  
  createViewmodelConfigUI();
});

/**
 * Creates a UI panel for configuring the viewmodel
 */
function createViewmodelConfigUI() {
  // Create container
  const container = document.createElement('div');
  container.id = 'viewmodel-config';
  container.style.position = 'fixed';
  container.style.top = '10px';
  container.style.right = '10px';
  container.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
  container.style.color = 'white';
  container.style.padding = '10px';
  container.style.borderRadius = '5px';
  container.style.zIndex = '1000';
  container.style.fontFamily = 'monospace';
  container.style.fontSize = '12px';
  container.style.width = '200px';
  
  // Create title
  const title = document.createElement('div');
  title.textContent = 'Viewmodel Config';
  title.style.fontWeight = 'bold';
  title.style.marginBottom = '10px';
  title.style.textAlign = 'center';
  container.appendChild(title);
  
  // Minimize button
  const minimizeBtn = document.createElement('button');
  minimizeBtn.textContent = '-';
  minimizeBtn.style.position = 'absolute';
  minimizeBtn.style.top = '5px';
  minimizeBtn.style.right = '5px';
  minimizeBtn.style.width = '20px';
  minimizeBtn.style.height = '20px';
  minimizeBtn.style.padding = '0';
  minimizeBtn.style.border = 'none';
  minimizeBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
  minimizeBtn.style.cursor = 'pointer';
  container.appendChild(minimizeBtn);
  
  // Controls content
  const content = document.createElement('div');
  content.id = 'viewmodel-config-content';
  container.appendChild(content);
  
  // Add controls
  addFOVControl(content);
  addScaleControl(content);
  addPositionControls(content);
  addRotationControls(content);
  addEffectControls(content);
  
  // Apply/Reset buttons
  const buttonContainer = document.createElement('div');
  buttonContainer.style.display = 'flex';
  buttonContainer.style.justifyContent = 'space-between';
  buttonContainer.style.marginTop = '10px';
  
  const resetBtn = document.createElement('button');
  resetBtn.textContent = 'Reset';
  resetBtn.style.padding = '5px 10px';
  resetBtn.addEventListener('click', resetViewmodelConfig);
  
  const copyBtn = document.createElement('button');
  copyBtn.textContent = 'Copy JSON';
  copyBtn.style.padding = '5px 10px';
  copyBtn.addEventListener('click', copyConfigAsJSON);
  
  buttonContainer.appendChild(resetBtn);
  buttonContainer.appendChild(copyBtn);
  content.appendChild(buttonContainer);
  
  // Add to document
  document.body.appendChild(container);
  
  // Add minimize functionality
  let isMinimized = false;
  minimizeBtn.addEventListener('click', () => {
    isMinimized = !isMinimized;
    content.style.display = isMinimized ? 'none' : 'block';
    minimizeBtn.textContent = isMinimized ? '+' : '-';
    container.style.width = isMinimized ? 'auto' : '200px';
  });
}

/**
 * Adds FOV control to the config panel
 */
function addFOVControl(parent) {
  const container = document.createElement('div');
  container.style.marginBottom = '10px';
  
  const label = document.createElement('div');
  label.textContent = 'FOV';
  container.appendChild(label);
  
  const input = document.createElement('input');
  input.type = 'range';
  input.min = '60';
  input.max = '120';
  input.step = '1';
  input.style.width = '100%';
  input.id = 'camera-fov';
  
  // Set initial value if player exists
  if (window.localPlayer && window.localPlayer.camera) {
    input.value = window.localPlayer.camera.fov;
  } else {
    input.value = 90;
  }
  
  input.addEventListener('input', () => {
    if (window.localPlayer && window.localPlayer.camera) {
      const fov = parseFloat(input.value);
      window.localPlayer.camera.fov = fov;
      window.localPlayer.camera.updateProjectionMatrix();
      updateValueDisplay('fov-value', fov.toFixed(0));
    }
  });
  
  container.appendChild(input);
  
  // Value display
  const valueDisplay = document.createElement('div');
  valueDisplay.id = 'fov-value';
  valueDisplay.textContent = input.value;
  valueDisplay.style.textAlign = 'right';
  valueDisplay.style.fontSize = '10px';
  container.appendChild(valueDisplay);
  
  parent.appendChild(container);
}

/**
 * Adds scale control to the config panel
 */
function addScaleControl(parent) {
  const container = document.createElement('div');
  container.style.marginBottom = '10px';
  
  const label = document.createElement('div');
  label.textContent = 'Scale';
  container.appendChild(label);
  
  const input = document.createElement('input');
  input.type = 'range';
  input.min = '0.01';
  input.max = '1.0';
  input.step = '0.01';
  input.style.width = '100%';
  input.id = 'viewmodel-scale';
  
  // Set initial value if player exists
  if (window.localPlayer && window.localPlayer.viewmodel) {
    input.value = window.localPlayer.viewmodel.SCALE;
  } else {
    input.value = 0.05;
  }
  
  input.addEventListener('input', () => {
    if (window.localPlayer && window.localPlayer.viewmodel) {
      const scale = parseFloat(input.value);
      window.localPlayer.viewmodel.SCALE = scale;
      window.localPlayer.viewmodel.group.scale.set(scale, scale, scale);
      updateValueDisplay('scale-value', scale.toFixed(3));
    }
  });
  
  container.appendChild(input);
  
  // Value display
  const valueDisplay = document.createElement('div');
  valueDisplay.id = 'scale-value';
  valueDisplay.textContent = input.value;
  valueDisplay.style.textAlign = 'right';
  valueDisplay.style.fontSize = '10px';
  container.appendChild(valueDisplay);
  
  parent.appendChild(container);
}

/**
 * Adds position controls to the config panel
 */
function addPositionControls(parent) {
  const container = document.createElement('div');
  container.style.marginBottom = '10px';
  
  const label = document.createElement('div');
  label.textContent = 'Position';
  container.appendChild(label);
  
  // X, Y, Z controls
  const axes = ['x', 'y', 'z'];
  axes.forEach(axis => {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.marginBottom = '5px';
    
    const axisLabel = document.createElement('div');
    axisLabel.textContent = axis.toUpperCase();
    axisLabel.style.width = '20px';
    row.appendChild(axisLabel);
    
    const input = document.createElement('input');
    input.type = 'range';
    input.min = '-3';
    input.max = '3';
    input.step = '0.05';
    input.style.flexGrow = '1';
    input.id = `viewmodel-pos-${axis}`;
    
    // Set initial value if player exists
    if (window.localPlayer && window.localPlayer.viewmodel) {
      if (axis === 'z') {
        // Z position includes forward clip
        input.value = window.localPlayer.viewmodel.group.position[axis] - 
                      window.localPlayer.viewmodel.FORWARD_CLIP;
      } else {
        input.value = window.localPlayer.viewmodel.group.position[axis];
      }
    } else {
      input.value = 0;
    }
    
    input.addEventListener('input', () => {
      if (window.localPlayer && window.localPlayer.viewmodel) {
        const position = parseFloat(input.value);
        
        // Update viewmodel object
        window.localPlayer.viewmodel.POSITION[axis] = position;
        
        // Update actual position in scene
        if (axis === 'z') {
          // Add forward clip for z-axis
          window.localPlayer.viewmodel.group.position[axis] = 
            position + window.localPlayer.viewmodel.FORWARD_CLIP;
        } else {
          window.localPlayer.viewmodel.group.position[axis] = position;
        }
        
        updateValueDisplay(`pos-${axis}-value`, position.toFixed(2));
      }
    });
    
    row.appendChild(input);
    
    // Value display
    const valueDisplay = document.createElement('div');
    valueDisplay.id = `pos-${axis}-value`;
    valueDisplay.textContent = input.value;
    valueDisplay.style.width = '40px';
    valueDisplay.style.textAlign = 'right';
    valueDisplay.style.fontSize = '10px';
    row.appendChild(valueDisplay);
    
    container.appendChild(row);
  });
  
  parent.appendChild(container);
}

/**
 * Adds rotation controls to the config panel
 */
function addRotationControls(parent) {
  const container = document.createElement('div');
  container.style.marginBottom = '10px';
  
  const label = document.createElement('div');
  label.textContent = 'Rotation';
  container.appendChild(label);
  
  // X, Y, Z controls
  const axes = ['x', 'y', 'z'];
  axes.forEach(axis => {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.marginBottom = '5px';
    
    const axisLabel = document.createElement('div');
    axisLabel.textContent = axis.toUpperCase();
    axisLabel.style.width = '20px';
    row.appendChild(axisLabel);
    
    const input = document.createElement('input');
    input.type = 'range';
    input.min = '-3.14';
    input.max = '3.14';
    input.step = '0.05';
    input.style.flexGrow = '1';
    input.id = `viewmodel-rot-${axis}`;
    
    // Set initial value if player exists
    if (window.localPlayer && window.localPlayer.viewmodel) {
      input.value = window.localPlayer.viewmodel.group.rotation[axis];
    } else {
      input.value = 0;
    }
    
    input.addEventListener('input', () => {
      if (window.localPlayer && window.localPlayer.viewmodel) {
        const rotation = parseFloat(input.value);
        
        // Update viewmodel object
        window.localPlayer.viewmodel.ROTATION[axis] = rotation;
        window.localPlayer.viewmodel.group.rotation[axis] = rotation;
        
        updateValueDisplay(`rot-${axis}-value`, rotation.toFixed(2));
      }
    });
    
    row.appendChild(input);
    
    // Value display
    const valueDisplay = document.createElement('div');
    valueDisplay.id = `rot-${axis}-value`;
    valueDisplay.textContent = input.value;
    valueDisplay.style.width = '40px';
    valueDisplay.style.textAlign = 'right';
    valueDisplay.style.fontSize = '10px';
    row.appendChild(valueDisplay);
    
    container.appendChild(row);
  });
  
  parent.appendChild(container);
}

/**
 * Adds effect position controls
 */
function addEffectControls(parent) {
  const container = document.createElement('div');
  
  const label = document.createElement('div');
  label.textContent = 'Muzzle Flash';
  container.appendChild(label);
  
  // X, Y, Z controls for muzzle flash
  const axes = ['x', 'y', 'z'];
  axes.forEach(axis => {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.marginBottom = '5px';
    
    const axisLabel = document.createElement('div');
    axisLabel.textContent = axis.toUpperCase();
    axisLabel.style.width = '20px';
    row.appendChild(axisLabel);
    
    const input = document.createElement('input');
    input.type = 'range';
    input.min = '-10';
    input.max = '10';
    input.step = '0.1';
    input.style.flexGrow = '1';
    input.id = `muzzle-${axis}`;
    
    // Set initial value if player exists
    if (window.localPlayer && window.localPlayer.viewmodel) {
      input.value = window.localPlayer.viewmodel.EFFECTS.MUZZLE_FLASH[axis];
    } else {
      input.value = axis === 'z' ? -1.67 : (axis === 'x' ? 0.33 : -0.17);
    }
    
    input.addEventListener('input', () => {
      if (window.localPlayer && window.localPlayer.viewmodel) {
        const position = parseFloat(input.value);
        
        // Update viewmodel object
        window.localPlayer.viewmodel.EFFECTS.MUZZLE_FLASH[axis] = position;
        
        // Update actual position if muzzle anchor exists
        if (window.localPlayer.viewmodel.muzzleFlashAnchor) {
          window.localPlayer.viewmodel.muzzleFlashAnchor.position[axis] = position;
        }
        
        updateValueDisplay(`muzzle-${axis}-value`, position.toFixed(2));
      }
    });
    
    row.appendChild(input);
    
    // Value display
    const valueDisplay = document.createElement('div');
    valueDisplay.id = `muzzle-${axis}-value`;
    valueDisplay.textContent = input.value;
    valueDisplay.style.width = '40px';
    valueDisplay.style.textAlign = 'right';
    valueDisplay.style.fontSize = '10px';
    row.appendChild(valueDisplay);
    
    container.appendChild(row);
  });
  
  parent.appendChild(container);
}

/**
 * Updates a value display element
 */
function updateValueDisplay(id, value) {
  const element = document.getElementById(id);
  if (element) {
    element.textContent = value;
  }
}

/**
 * Resets all viewmodel configuration to defaults
 */
function resetViewmodelConfig() {
  if (!window.localPlayer || !window.localPlayer.viewmodel) return;
  
  const viewmodel = window.localPlayer.viewmodel;
  
  // Reset FOV
  if (window.localPlayer.camera) {
    window.localPlayer.camera.fov = 90;
    window.localPlayer.camera.updateProjectionMatrix();
  }
  
  // Reset scale
  viewmodel.SCALE = 1.0;
  viewmodel.group.scale.set(1.0, 1.0, 1.0);
  
  // Reset position
  viewmodel.POSITION = { x: 0, y: 0, z: -0.5 };
  viewmodel.group.position.set(0, 0, -0.5 + viewmodel.FORWARD_CLIP);
  
  // Reset rotation
  viewmodel.ROTATION = { x: 0, y: 0, z: 0 };
  viewmodel.group.rotation.set(0, 0, 0);
  
  // Reset muzzle flash position
  viewmodel.EFFECTS.MUZZLE_FLASH = {
    x: 0.33,
    y: -0.17,
    z: -1.67,
    scale: 0.1
  };
  
  if (viewmodel.muzzleFlashAnchor) {
    viewmodel.muzzleFlashAnchor.position.set(0.33, -0.17, -1.67);
  }
  
  // Update all input fields to match the reset values
  updateConfigInputs();
}

/**
 * Updates all input fields to match current values
 */
function updateConfigInputs() {
  if (!window.localPlayer || !window.localPlayer.viewmodel) return;
  
  const viewmodel = window.localPlayer.viewmodel;
  
  // Update FOV input
  const fovInput = document.getElementById('camera-fov');
  if (fovInput && window.localPlayer.camera) {
    fovInput.value = window.localPlayer.camera.fov;
    updateValueDisplay('fov-value', window.localPlayer.camera.fov.toFixed(0));
  }
  
  // Update scale input
  const scaleInput = document.getElementById('viewmodel-scale');
  if (scaleInput) {
    scaleInput.value = viewmodel.SCALE;
    updateValueDisplay('scale-value', viewmodel.SCALE.toFixed(3));
  }
  
  // Update position inputs
  ['x', 'y', 'z'].forEach(axis => {
    const input = document.getElementById(`viewmodel-pos-${axis}`);
    if (input) {
      const value = axis === 'z' ? 
        viewmodel.group.position[axis] - viewmodel.FORWARD_CLIP : 
        viewmodel.group.position[axis];
      
      input.value = value;
      updateValueDisplay(`pos-${axis}-value`, value.toFixed(2));
    }
  });
  
  // Update rotation inputs
  ['x', 'y', 'z'].forEach(axis => {
    const input = document.getElementById(`viewmodel-rot-${axis}`);
    if (input) {
      input.value = viewmodel.group.rotation[axis];
      updateValueDisplay(`rot-${axis}-value`, viewmodel.group.rotation[axis].toFixed(2));
    }
  });
  
  // Update muzzle flash inputs
  ['x', 'y', 'z'].forEach(axis => {
    const input = document.getElementById(`muzzle-${axis}`);
    if (input) {
      input.value = viewmodel.EFFECTS.MUZZLE_FLASH[axis];
      updateValueDisplay(`muzzle-${axis}-value`, viewmodel.EFFECTS.MUZZLE_FLASH[axis].toFixed(2));
    }
  });
}

/**
 * Copies the current viewmodel configuration as JSON
 */
function copyConfigAsJSON() {
  if (!window.localPlayer || !window.localPlayer.viewmodel) return;
  
  const viewmodel = window.localPlayer.viewmodel;
  
  const config = {
    FOV: window.localPlayer.camera ? window.localPlayer.camera.fov : 90,
    SCALE: viewmodel.SCALE,
    POSITION: {
      x: viewmodel.POSITION.x,
      y: viewmodel.POSITION.y,
      z: viewmodel.POSITION.z
    },
    ROTATION: {
      x: viewmodel.ROTATION.x,
      y: viewmodel.ROTATION.y,
      z: viewmodel.ROTATION.z
    },
    FORWARD_CLIP: viewmodel.FORWARD_CLIP,
    EFFECTS: {
      MUZZLE_FLASH: {
        x: viewmodel.EFFECTS.MUZZLE_FLASH.x,
        y: viewmodel.EFFECTS.MUZZLE_FLASH.y,
        z: viewmodel.EFFECTS.MUZZLE_FLASH.z,
        scale: viewmodel.EFFECTS.MUZZLE_FLASH.scale
      },
      SMOKE_RING: viewmodel.EFFECTS.SMOKE_RING,
      BULLET_SPAWN: viewmodel.EFFECTS.BULLET_SPAWN
    }
  };
  
  const json = JSON.stringify(config, null, 2);
  navigator.clipboard.writeText(json).then(() => {
    console.log('Viewmodel config copied to clipboard');
    
    // Flash the copy button to indicate success
    const copyBtn = document.querySelector('#viewmodel-config button:nth-child(2)');
    if (copyBtn) {
      copyBtn.textContent = 'Copied!';
      setTimeout(() => {
        copyBtn.textContent = 'Copy JSON';
      }, 1000);
    }
  });
} 

================================================
File: /public/js/viewmodel.js
================================================
/**
 * A proper FPS viewmodel implementation with animation support
 * Handles animations for aim, fakeshoot, holster, idle, reload, and shoot actions
 */
export class Viewmodel {
  constructor() {
    // Adjustable constants for positioning the viewmodel
    this.SCALE = 1.0;  // Updated based on user preference
    this.POSITION = {
      x: 0,   // positive moves right
      y: 0,   // negative moves down 
      z: -0.5 // negative moves closer to camera, updated based on user preference
    };
    
    // Rotation adjustment (in radians)
    this.ROTATION = {
      x: 0,     // pitch
      y: 0,     // yaw
      z: 0      // roll
    };
    
    // Forward clipping offset - how far forward to position model
    this.FORWARD_CLIP = 0.18; // Increased from 0.16 to push model further from camera
    
    // Effect positioning constants
    this.EFFECTS = {
      // Muzzle flash anchor position (relative to model)
      MUZZLE_FLASH: {
        x: -0.05,       // Left/right offset of muzzle flash
        y: 0.1,      // Up/down offset of muzzle flash
        z: -0.1,      // Forward/backward offset of muzzle flash (negative = forward)
        scale: 0.1     // Scale of muzzle flash effect
      },
      
      // Smoke ring effect positioning
      SMOKE_RING: {
        forward_offset: 0.05,  // Forward offset from barrel
        x_offset: 0,           // Left/right offset from barrel
        y_offset: 0,           // Up/down offset from barrel
        scale: 1.0             // Scale of smoke ring effect
      },
      
      // Bullet spawn position (forward offset from muzzle)
      BULLET_SPAWN: {
        forward_offset: 0.1   // Forward distance from muzzle to spawn bullets
      }
    };
    
    this.group = new THREE.Group();
    this.animations = {};
    this.mixer = null;
    this.actions = {}; // Named references to configured actions
    this.currentAction = null;
    this.primaryAction = null; // The main active action
    this.secondaryAction = null; // Secondary blended action
    this.model = null;
    this.muzzleFlashAnchor = null;
    this.isLoaded = false;
    this.animationsConfigured = false;
    
    // Animation states and transitions
    this.animationState = 'none';
    this.transitionInProgress = false;
    this.queue = []; // Queue for animations to play in sequence
    this.pendingAimTransition = false; // Flag to track pending transition to aim from draw
    
    // Timeout tracking for animation callbacks
    this._actionTimeoutId = null;
    this._holsterTimeoutId = null;
    
    // Flags to prevent holstering and keep viewmodel visible
    this.blockHolster = false;
    this.pendingHolster = false;
    this.forceVisible = false; // New flag to keep viewmodel visible
    
    // Skin system
    this.activeSkin = null;
    this.availableSkins = {
      default: null, // Default texture will be stored here after loading
      bananaSkin: null // Will be loaded on demand
    };
    this.skinPermissions = {
      bananaSkin: false // By default, skin is locked until verified with NFT
    };
    
    // Set up with proper scale and position
    this.group.scale.set(this.SCALE, this.SCALE, this.SCALE);
    this.group.position.set(
      this.POSITION.x, 
      this.POSITION.y, 
      this.POSITION.z + this.FORWARD_CLIP
    );
    this.group.rotation.set(
      this.ROTATION.x,
      this.ROTATION.y,
      this.ROTATION.z
    );
    
    // Load the viewmodel with its animations
    this._loadModel();
    
    // Initially hidden until the player aims
    this.group.visible = false;
  }
  
  /**
   * Loads the viewmodel and its animations
   * @private
   */
  _loadModel() {
    // Check if we have a preloaded viewmodel
    if (window.preloadedModels && (window.preloadedModels.viewmodel || window.preloadedModels.viewmodel_clone)) {
      console.log("Using preloaded viewmodel");
      try {
        // Use the clone version to avoid reference issues
        const preloadedModel = window.preloadedModels.viewmodel_clone || window.preloadedModels.viewmodel;
        const gltf = {
          scene: preloadedModel.scene.clone(),
          animations: preloadedModel.animations
        };
        
        this.model = gltf.scene;
        this.group.add(this.model);
        
        // Setup animations
        this.mixer = new THREE.AnimationMixer(this.model);
        
        // Remove verbose animation logging
        if (gltf.animations && gltf.animations.length) {
          this._setupActions(gltf.animations);
        } else {
          console.warn('No animations found in preloaded viewmodel!');
        }
        
        // Keep this single log to confirm successful loading
        console.log('Viewmodel loaded successfully from preload');
        this.isLoaded = true;
        
        // Create a muzzle flash anchor
        this._createMuzzleFlashAnchor();
        return; // Exit early since we've handled the model
      } catch (e) {
        console.error('Error using preloaded viewmodel:', e);
        // Fall through to regular loading method if preloaded model fails
      }
    }
    
    const loader = new THREE.GLTFLoader();
    loader.load(
      'models/viewmodel.glb',
      (gltf) => {
        this.model = gltf.scene;
        this.group.add(this.model);
        
        // Setup animations
        this.mixer = new THREE.AnimationMixer(this.model);
        
        // Remove verbose animation logging
        if (gltf.animations && gltf.animations.length) {
          this._setupActions(gltf.animations);
        } else {
          console.warn('No animations found in viewmodel.glb!');
        }
        
        // Keep this single log to confirm successful loading
        console.log('Viewmodel loaded successfully');
        this.isLoaded = true;
        
        // Create a muzzle flash anchor
        this._createMuzzleFlashAnchor();
      },
      undefined,
      (error) => {
        console.error('Error loading viewmodel:', error);
      }
    );
  }
  
  /**
   * Set up all animation actions with proper configuration
   * @param {Array} animations - Array of AnimationClips from the loaded model
   * @private
   */
  _setupActions(animations) {
    // Index all animations by name
    animations.forEach(clip => {
      // Create action but don't play it yet
      const action = this.mixer.clipAction(clip);
      this.animations[clip.name] = action;
      
      // Default configuration
      action.enabled = false;
      action.setEffectiveWeight(0);
      action.loop = THREE.LoopOnce;
      action.clampWhenFinished = true;
      action.reset();
    });

    // Configure the new animation names
    this._findAndConfigureAction('idle', {
      loop: THREE.LoopRepeat, // This should loop continuously
      clampWhenFinished: false,
      alternatives: ['Idle']
    });
    
    this._findAndConfigureAction('revolverdraw', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['DrawAim', 'Draw', 'draw', 'drawaim']
    });
    
    this._findAndConfigureAction('revolveraim', {
      loop: THREE.LoopRepeat, // Should loop as long as player is aiming
      clampWhenFinished: false,
      alternatives: ['Aim', 'aim', 'AimLoop', 'aimloop']
    });
    
    this._findAndConfigureAction('revolverholster', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['Holster', 'holstering', 'holster']
    });
    
    this._findAndConfigureAction('revolvershot', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['Shoot', 'shoot', 'Fire', 'fire', 'shooting']
    });
    
    this._findAndConfigureAction('revolverreload', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['Reload', 'reload_gun', 'reload']
    });
    
    this._findAndConfigureAction('revolverempty', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['fakeshoot', 'empty', 'dryfire', 'no_ammo']
    });
    
    // Configure shotgun animation actions
    this._findAndConfigureAction('shotgundraw', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['shotgunDraw', 'ShotgunDraw']
    });
    
    this._findAndConfigureAction('shotgunaim', {
      loop: THREE.LoopRepeat,
      clampWhenFinished: false,
      alternatives: ['shotgunAim', 'ShotgunAim', 'shotgunaimloop', 'ShotgunAimLoop']
    });
    
    this._findAndConfigureAction('shotgunholster', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['shotgunHolster', 'ShotgunHolster', 'shotgunholstering']
    });
    
    this._findAndConfigureAction('shotgunshot', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['shotgunShoot', 'ShotgunShoot', 'shotgunfire', 'ShotgunFire']
    });
    
    this._findAndConfigureAction('shotgunreload', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['shotgunReload', 'ShotgunReload']
    });
    
    this._findAndConfigureAction('shotgunempty', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['shotgunEmpty', 'ShotgunEmpty', 'shotgundryfire', 'ShotgunDryFire']
    });
    
    // Initialize with the idle animation
    if (this.actions.idle) {
      const idleAction = this.actions.idle;
      idleAction.enabled = true;
      idleAction.setEffectiveWeight(1);
      idleAction.play();
      
      this.primaryAction = idleAction;
      this.animationState = 'idle';
    }

    this.animationsConfigured = true;
  }
  
  /**
   * Find and configure an action, storing it in the actions object
   * @param {string} name - The action name to use as key
   * @param {Object} options - Configuration options for the action
   * @private
   * @returns {THREE.AnimationAction|null} - The configured action
   */
  _findAndConfigureAction(name, options) {
    const action = this._findAnimation(name, options.alternatives || []);
    if (!action) return null;
    
    // Apply configuration
    action.loop = options.loop || THREE.LoopOnce;
    action.clampWhenFinished = options.clampWhenFinished !== undefined ? options.clampWhenFinished : true;
    if (options.timeScale) action.timeScale = options.timeScale;
    
    // Store in actions map
    this.actions[name] = action;
    return action;
  }
  
  /**
   * Create and position the muzzle flash anchor
   * @private
   */
  _createMuzzleFlashAnchor() {
    // Create an anchor point for muzzle flash effects
    this.muzzleFlashAnchor = new THREE.Group();
    
    // Try to find the barrel / muzzle in the model
    const muzzle = this.model.getObjectByName('barrel') || 
                   this.model.getObjectByName('muzzle') ||
                   this.model.getObjectByName('barrelEnd') ||
                   this.model.getObjectByName('barrel_end');
    
    if (muzzle) {
      // If found, attach to the muzzle
      muzzle.add(this.muzzleFlashAnchor);
      // Adjust forward position using the constants
      this.muzzleFlashAnchor.position.set(
        this.EFFECTS.MUZZLE_FLASH.x,
        this.EFFECTS.MUZZLE_FLASH.y,
        this.EFFECTS.MUZZLE_FLASH.z
      );
      // Only log in debug mode
      if (window.debugMode) {
        console.log("Muzzle flash anchor attached to barrel");
      }
    } else {
      // If not found, attach to model root with an estimated position
      this.model.add(this.muzzleFlashAnchor);
      
      // Position the muzzle flash anchor using the constants
      this.muzzleFlashAnchor.position.set(
        this.EFFECTS.MUZZLE_FLASH.x,
        this.EFFECTS.MUZZLE_FLASH.y,
        this.EFFECTS.MUZZLE_FLASH.z
      );
      // Only log in debug mode
      if (window.debugMode) {
        console.log("Muzzle flash anchor attached to model root - no barrel found");
      }
    }
  }
  
  /**
   * Find an animation by name with various fallbacks
   * @param {string} baseName - The base animation name to find
   * @param {string[]} alternatives - Alternative names to try
   * @returns {THREE.AnimationAction|null} - The found animation action or null
   * @private
   */
  _findAnimation(baseName, alternatives = []) {
    // First try the exact name
    if (this.animations[baseName]) {
      return this.animations[baseName];
    }
    
    // Try alternatives
    for (const name of alternatives) {
      if (this.animations[name]) {
        return this.animations[name];
      }
    }
    
    // Try matching case-insensitively with all animations
    const lowerName = baseName.toLowerCase();
    for (const key of Object.keys(this.animations)) {
      if (key.toLowerCase() === lowerName || key.toLowerCase().includes(lowerName)) {
        return this.animations[key];
      }
    }
    
    // If nothing found, log error and return null
    console.warn(`Animation "${baseName}" not found! Available:`, Object.keys(this.animations));
    return null;
  }
  
  /**
   * Helper method to check if an animation can interrupt the current one
   * @param {string} newActionName - The action name that wants to play
   * @returns {boolean} - Whether interruption is allowed
   * @private
   */
  _canInterruptCurrentAnimation(newActionName) {
    const state = this.animationState;
    
    // Reload can interrupt any animation
    if (newActionName.includes('reload')) return true;
    
    // Empty can only be interrupted by reload
    if (state.includes('empty') && !newActionName.includes('reload')) return false;
    
    // Holster animation with blockHolster flag set has limited interruptions
    if (state.includes('holster') && this.blockHolster && 
        !newActionName.includes('idle') && 
        !newActionName.includes('empty') && 
        !newActionName.includes('reload')) {
      return false;
    }
    
    // Always allow draw to interrupt holster (re-aiming)
    if ((newActionName === 'revolverdraw' && state === 'revolverholster') ||
        (newActionName === 'shotgundraw' && state === 'shotgunholster')) {
      return true;
    }
    
    // Always allow holster to interrupt aim
    if ((newActionName === 'revolverholster' && state === 'revolveraim') ||
        (newActionName === 'shotgunholster' && state === 'shotgunaim')) {
      return true;
    }
    
    return true;
  }
  
  /**
   * Transition to a new animation state with abrupt stitching instead of blending
   * @param {string} actionName - The action name to transition to
   * @param {Object} options - Transition options
   * @private
   */
  _transitionTo(actionName, options = {}) {
    if (!this.isLoaded || !this.mixer || !this.animationsConfigured) return;
    
    // Handle aim transitions with pending holster
    if ((actionName === 'revolveraim' || actionName === 'shotgunaim') && this.pendingHolster) {
      this.pendingHolster = false;
      this.pendingAimTransition = false;
      this.playHolsterAnim();
      return;
    }
    
    // Handle cancelled aim transitions
    if ((actionName === 'revolveraim' && !this.pendingAimTransition && this.animationState === 'revolverdraw') ||
        (actionName === 'shotgunaim' && !this.pendingAimTransition && this.animationState === 'shotgundraw')) {
      this._transitionTo('idle', { resetTimeOnPlay: true });
      return;
    }
    
    // Check if the current animation can be interrupted
    if (!this._canInterruptCurrentAnimation(actionName)) {
      // Queue critical animations for later
      if (actionName.includes('empty') || actionName.includes('reload')) {
        this._queueAnimation(actionName, options);
      }
      return;
    }
    
    // Handle specific transition cases
    if (actionName.includes('draw') && this.animationState.includes('holster')) {
      // Interrupting holster to draw - allow it
      this.blockHolster = false;
      this._clearTimeouts();
    } 
    else if (actionName.includes('holster') && this.animationState.includes('aim')) {
      // Always allow holstering from aim state
      this.blockHolster = false;
    }
    else if (actionName.includes('reload')) {
      // Clear flags for reload
      this.pendingAimTransition = false;
      this.blockHolster = false;
      this._clearTimeouts();
    }
    else if ((this.animationState === 'revolverempty' || this.animationState === 'shotgunempty') && 
             (actionName === 'idle' || actionName.includes('aim'))) {
      // Reset flags when transitioning from empty animation
      this.blockHolster = false;
      this.pendingHolster = false;
      this.pendingAimTransition = false;
    }
    
    const action = this.actions[actionName];
    if (!action) {
      console.warn(`Action "${actionName}" not found for transition`);
      return;
    }
    
    // Default options
    const settings = {
      resetAction: true,
      resetTimeOnPlay: true,
      stopPrevious: true,
      onComplete: null,
      ...options
    };
    
    this.transitionInProgress = true;
    
    // Reset and prepare action
    if (settings.resetAction) action.reset();
    if (settings.resetTimeOnPlay) action.time = 0;
    action.enabled = true;
    
    // Stop previous action
    if (this.primaryAction && settings.stopPrevious && this.primaryAction !== action) {
      if (this._actionTimeoutId) {
        clearTimeout(this._actionTimeoutId);
        this._actionTimeoutId = null;
      }
      
      this.primaryAction.enabled = false;
      this.primaryAction.setEffectiveWeight(0);
    }
    
    // Set new action
    this.primaryAction = action;
    this.currentAction = action;
    action.setEffectiveWeight(1);
    action.play();
    
    // Update animation state
    this.animationState = actionName;
    
    // Set up completion callback
    if (settings.onComplete && action.loop !== THREE.LoopRepeat) {
      const clipDuration = action._clip.duration;
      const timeoutDuration = actionName.includes('holster') 
        ? clipDuration * 1000 
        : clipDuration * 1000 - 50;
      
      const timeoutId = setTimeout(() => {
        if (this.primaryAction === action) {
          if (actionName.includes('holster')) {
            this._holsterTimeoutId = null;
          } else {
            this._actionTimeoutId = null;
          }
          settings.onComplete();
        }
      }, timeoutDuration);
      
      if (actionName.includes('holster')) {
        this._holsterTimeoutId = timeoutId;
      } else {
        this._actionTimeoutId = timeoutId;
      }
    }
    
    this.transitionInProgress = false;
    this._processQueue();
  }
  
  /**
   * Queue an animation to play when current animation completes
   * @param {string} actionName - The action name to queue
   * @param {Object} options - Transition options
   * @private 
   */
  _queueAnimation(actionName, options = {}) {
    this.queue.push({ actionName, options });
    
    // If no transition in progress, process queue immediately
    if (!this.transitionInProgress) {
      this._processQueue();
    }
  }
  
  /**
   * Process the animation queue
   * @private
   */
  _processQueue() {
    if (this.queue.length > 0) {
      const next = this.queue.shift();
      this._transitionTo(next.actionName, next.options);
    }
  }
  
  /**
   * Play the draw animation when starting to aim.
   * Transitions to aim when completed.
   */
  playDrawAim() {
    if (!this.isLoaded) return;
    
    const weaponPrefix = this._getWeaponPrefix();
    this.pendingHolster = false;
    
    // If we're already in aim mode, we don't need to do anything
    if (this.animationState === `${weaponPrefix}aim`) return;
    
    // Make sure the model is visible during draw
    this.group.visible = true;
    
    // If we're holstering, interrupt it and switch to draw
    if (this.animationState === `${weaponPrefix}holster`) {
      // Cancel any pending callbacks from the holster animation
      if (this.primaryAction === this.actions[`${weaponPrefix}holster`]) {
        this.blockHolster = false;
      }
      
      this._clearTimeouts();
      
      this._transitionTo(`${weaponPrefix}draw`, {
        resetTimeOnPlay: true,
        onComplete: () => {
          if (!this.pendingHolster) {
            this.pendingAimTransition = true;
            this._transitionTo(`${weaponPrefix}aim`, { resetTimeOnPlay: true });
            this.pendingAimTransition = false;
          } else {
            this.pendingHolster = false;
            this.playHolsterAnim();
          }
        }
      });
      return;
    }
    
    this._clearTimeouts();
    this.blockHolster = false;
    
    this._transitionTo(`${weaponPrefix}draw`, {
      resetTimeOnPlay: true,
      onComplete: () => {
        if (!this.pendingHolster) {
          this.pendingAimTransition = true;
          this._transitionTo(`${weaponPrefix}aim`, { resetTimeOnPlay: true });
          this.pendingAimTransition = false;
        } else {
          this.pendingHolster = false;
          this.playHolsterAnim();
        }
      }
    });
  }
  
  /**
   * Play the shooting animation while aiming
   */
  playShootAnim() {
    if (!this.isLoaded) return;
    
    const weaponPrefix = this._getWeaponPrefix();
    this.group.visible = true;
    
    // Can only shoot if in aim mode or already shooting
    if (this.animationState !== `${weaponPrefix}aim` && 
        this.animationState !== `${weaponPrefix}draw` && 
        this.animationState !== `${weaponPrefix}shot`) {
      return;
    }
    
    const completeAction = () => {
      if (!this.blockHolster && !this.pendingHolster) {
        this._transitionTo(`${weaponPrefix}aim`, { resetTimeOnPlay: true });
      } else if (this.pendingHolster) {
        this.pendingHolster = false;
        this.playHolsterAnim();
      }
    };
    
    // For rapid fire shooting, if we're already in the shoot animation,
    // cancel the current animation and any pending callback
    if (this.animationState === `${weaponPrefix}shot`) {
      this._clearTimeouts();
      
      // Reset the shot animation to play from the beginning
      const shootAction = this.actions[`${weaponPrefix}shot`];
      shootAction.reset();
      shootAction.time = 0;
      shootAction.enabled = true;
      shootAction.setEffectiveWeight(1);
      shootAction.play();
      
      // Set up a new completion callback
      const clipDuration = shootAction._clip.duration;
      this._actionTimeoutId = setTimeout(() => {
        if (this.primaryAction === shootAction) {
          this._actionTimeoutId = null;
          completeAction();
        }
      }, clipDuration * 1000 - 50);
      
      return;
    }
    
    // For first shot, transition to shoot animation normally
    this._transitionTo(`${weaponPrefix}shot`, {
      resetTimeOnPlay: true,
      onComplete: completeAction
    });
  }
  
  /**
   * Play the empty gun animation (when trying to shoot without ammo)
   */
  playFakeShootAnim() {
    if (!this.isLoaded) return;
    
    const weaponPrefix = this._getWeaponPrefix();
    this.group.visible = true;
    
    // Block everything until empty animation completes
    this.blockHolster = true;
    this.pendingHolster = false;
    this.forceVisible = true;
    
    this._clearTimeouts();
    
    // Reset all animations to ensure clean state
    Object.values(this.actions).forEach(action => {
      if (action !== this.actions[`${weaponPrefix}empty`]) {
        action.reset();
        action.setEffectiveWeight(0);
      }
    });
    
    // Transition to empty animation
    this._transitionTo(`${weaponPrefix}empty`, {
      resetTimeOnPlay: true,
      onComplete: () => {
        this._resetAnimationFlags();
        
        // Get current aim state
        const isAimingNow = window.localPlayer?.isAiming || false;
        
        // Transition based on current aim state
        if (isAimingNow) {
          this._transitionTo(`${weaponPrefix}aim`, { resetTimeOnPlay: true });
        } else {
          this._transitionTo('idle', { resetTimeOnPlay: true });
        }
      }
    });
  }
  
  /**
   * Play the holster animation (when stopping aiming)
   */
  playHolsterAnim() {
    if (!this.isLoaded) return;
    
    const weaponPrefix = this._getWeaponPrefix();
    
    // If we're currently playing empty or reload animations, don't interrupt
    if (this.blockHolster && this.animationState !== `${weaponPrefix}aim`) {
      this.pendingHolster = true;
      return;
    }
    
    // If we're in aim state, we should always be able to holster
    if (this.animationState === `${weaponPrefix}aim`) {
      this.blockHolster = false;
    }
    
    // Cancel any pending transition to aim state if we're still in drawing phase
    if (this.animationState === `${weaponPrefix}draw` && this.pendingAimTransition) {
      this.pendingAimTransition = false;
    }
    
    this._clearTimeouts();
    this.forceVisible = true;
    
    // Reset holster animation if interrupted during draw or aim
    if ((this.animationState === `${weaponPrefix}draw` || this.animationState === `${weaponPrefix}aim`) && 
         this.actions[`${weaponPrefix}holster`]) {
      this.actions[`${weaponPrefix}holster`].reset();
    }
    
    // Ensure holster animation can't be interrupted once started
    this.blockHolster = true;
    
    // Play the gun holster sound
    if (window.localPlayer?.soundManager) {
      const soundName = weaponPrefix === 'shotgun' ? "shotgunholstering" : "revolverholstering";
      window.localPlayer.soundManager.playSound(soundName, 0, 0.6);
    }
    
    // Transition to holster animation
    this._transitionTo(`${weaponPrefix}holster`, {
      resetTimeOnPlay: true,
      onComplete: () => {
        // After holster completes, transition to idle and hide model
        this._transitionTo('idle', {
          resetTimeOnPlay: true,
          onComplete: () => {
            this.blockHolster = false;
            this.pendingHolster = false;
            this.forceVisible = false;
            
            // Hide viewmodel when transitioning back to idle from holster
            setTimeout(() => {
              if (!this.forceVisible) this.group.visible = false;
            }, 50);
          }
        });
      }
    });
  }
  
  /**
   * Play the reload animation
   */
  playReloadAnim() {
    if (!this.isLoaded) return;
    
    const weaponPrefix = this._getWeaponPrefix();
    
    // Make sure the model is visible during reload
    this.group.visible = true;
    
    // Reset ALL animation state flags completely when starting reload
    this.forceVisible = true;
    this.blockHolster = true;
    this.pendingHolster = false;
    this.pendingAimTransition = false;
    
    this._clearTimeouts();
    
    // Reset all animations to ensure clean state
    Object.values(this.actions).forEach(action => {
      if (action !== this.actions[`${weaponPrefix}reload`]) {
        action.reset();
        action.enabled = false;
        action.setEffectiveWeight(0);
      }
    });
    
    // Play reload sound
    if (window.localPlayer?.soundManager) {
      const soundName = weaponPrefix === 'shotgun' ? "shotgunreloading" : "reloading";
      window.localPlayer.soundManager.playSound(soundName, 0, 0.6);
    }
    
    // Transition to reload animation
    this._transitionTo(`${weaponPrefix}reload`, {
      resetTimeOnPlay: true,
      onComplete: () => {
        // After reload completes, go back to idle animation first
        this._transitionTo('idle', {
          resetTimeOnPlay: true,
          onComplete: () => {
            this._resetAnimationFlags();
            
            // If player is still aiming after reload, immediately transition to draw
            const isAimingNow = window.localPlayer?.isAiming;
            if (isAimingNow) {
              this.animationState = 'idle';
              this.primaryAction = this.actions.idle;
              this.currentAction = this.actions.idle;
              
              // Start the draw animation with a slight delay to ensure clean state
              setTimeout(() => {
                if (window.localPlayer?.isAiming) this.playDrawAim();
              }, 10);
            }
          }
        });
      }
    });
  }
  
  /**
   * Play the idle animation - always looping
   */
  playIdle() {
    if (!this.isLoaded) return;
    
    // Only play idle if we're not in another animation
    if (!this.animationState || this.animationState === 'none') {
      this._transitionTo('idle', {
        resetTimeOnPlay: true
      });
    }
  }
  
  /**
   * Returns true if the current animation is a shooting animation
   * @returns {boolean} True if currently in shooting animation
   */
  isInShootAnimation() {
    return this.animationState === 'revolvershot' || 
           this.animationState === 'revolverempty' ||
           this.animationState === 'shotgunshot' ||
           this.animationState === 'shotgunempty';
  }
  
  /**
   * Updates the animation mixer
   * @param {number} deltaTime - Time since last frame in seconds
   */
  update(deltaTime) {
    if (!this.isLoaded || !this.mixer) return;
    
    this.mixer.update(deltaTime);
    
    // Add animation state monitoring to detect and recover from stuck animations
    if (!this._stateStartTime) {
      this._stateStartTime = {};
      this._lastAnimationState = '';
    }
    
    // If animation state changed, record the start time
    if (this.animationState !== this._lastAnimationState) {
      this._stateStartTime[this.animationState] = Date.now();
      this._lastAnimationState = this.animationState;
    }
    
    // Check for stuck animations - if an animation has been playing too long
    if (this.animationState && this._stateStartTime[this.animationState]) {
      const timeInState = Date.now() - this._stateStartTime[this.animationState];
      
      // Empty and holster animations can get stuck
      if ((this.animationState.includes('empty') || this.animationState.includes('holster')) && 
          timeInState > 5000) { // 5 seconds is too long for these animations
        console.warn(`Animation stuck in ${this.animationState} for ${timeInState}ms, resetting`);
        
        // Force reset animation flags
        this.blockHolster = false;
        this.pendingHolster = false;
        this.forceVisible = false;
        
        // Reset to idle state
        this._transitionTo('idle', {
          resetTimeOnPlay: true
        });
        
        // Reset timer
        this._stateStartTime = {};
      }
    }
  }
  
  /**
   * Returns the world position of the gun barrel tip
   * @returns {THREE.Vector3} The world position for spawning bullets and effects
   */
  getBarrelTipWorldPosition() {
    if (this.muzzleFlashAnchor) {
      const worldPos = new THREE.Vector3();
      this.muzzleFlashAnchor.getWorldPosition(worldPos);
      
      // Add a small forward offset to ensure effects appear in front of the barrel
      // This is in world space, so we need the camera's forward direction
      const forward = new THREE.Vector3(0, 0, -1);
      forward.applyQuaternion(this.group.getWorldQuaternion(new THREE.Quaternion()));
      forward.multiplyScalar(this.EFFECTS.BULLET_SPAWN.forward_offset); // Forward offset amount
      
      worldPos.add(forward);
      return worldPos;
    }
    
    // Fallback if muzzle flash anchor isn't ready yet
    return this.group.localToWorld(new THREE.Vector3(0, 0, -0.5));
  }
  
  /**
   * Updates the model's skin based on skin ID
   * @param {string} skinId - The skin ID to apply
   * @returns {boolean} - Whether the skin was successfully applied
   */
  updateSkin(skinId) {
    // Check if this is a valid skin
    if (!skinId || !this.availableSkins.hasOwnProperty(skinId)) {
      console.warn(`Invalid skin ID: ${skinId}`);
      return false;
    }
    
    // Check if player has permission for this skin
    if (skinId !== 'default' && !this.skinPermissions[skinId]) {
      console.warn(`Player does not have permission for skin: ${skinId}`);
      return false;
    }
    
    // Check if the texture was already loaded for this skin
    if (!this.availableSkins[skinId]) {
      this.loadSkinTexture(skinId);
      return false; // Will be applied once loaded
    }
    
    // Apply the skin texture to the model
    this.applyTextureToModel(this.availableSkins[skinId]);
    this.activeSkin = skinId;
    
    console.log(`Applied skin '${skinId}' to viewmodel`);
    return true;
  }
  
  /**
   * Loads a skin texture by ID
   * @param {string} skinId - The skin ID to load
   */
  loadSkinTexture(skinId) {
    if (!skinId || skinId === 'default') return;
    
    const texturePath = `models/textures/${skinId}.png`;
    
    console.log(`Loading skin texture for viewmodel: ${texturePath}`);
    
    new THREE.TextureLoader().load(
      texturePath,
      (texture) => {
        // Store the loaded texture
        this.availableSkins[skinId] = texture;
        
        // Apply if we have permission
        if (this.skinPermissions[skinId]) {
          this.applyTextureToModel(texture);
          this.activeSkin = skinId;
          console.log(`Applied newly loaded skin '${skinId}' to viewmodel`);
        }
      },
      undefined,
      (error) => console.error(`Error loading skin texture '${skinId}':`, error)
    );
  }
  
  /**
   * Applies a texture to the viewmodel
   * @param {THREE.Texture} texture - The texture to apply
   */
  applyTextureToModel(texture) {
    if (!this.model || !texture) return;
    
    // List of revolver part names to look for
    const revolverParts = ['barrel', 'drum', 'grip', 'revolver', 'gun'];
    
    // Apply the texture to all relevant meshes in the model
    this.model.traverse(child => {
      if (!child.isMesh || !child.material) return;
      
      // Check if this is a relevant part to apply the texture to
      const isRevolverMaterial = child.material.name?.includes('Material.002');
      const isRevolverPart = revolverParts.some(part => 
        child.name.toLowerCase().includes(part.toLowerCase())
      );
      
      if (isRevolverMaterial || isRevolverPart) {
        // Store the original/default texture if not already stored
        if (!this.availableSkins.default && child.material.map) {
          this.availableSkins.default = child.material.map.clone();
        }
        
        // Clone the original material to preserve all properties
        if (child.material._originalMaterial === undefined) {
          child.material._originalMaterial = child.material.clone();
        }
        
        // Copy properties from original texture
        if (child.material._originalMaterial?.map) {
          const originalTexture = child.material._originalMaterial.map;
          
          // Copy texture properties
          const props = ['wrapS', 'wrapT', 'flipY', 'encoding', 'generateMipmaps', 'minFilter', 'magFilter'];
          props.forEach(prop => texture[prop] = originalTexture[prop]);
          
          // Copy vector properties
          texture.repeat.copy(originalTexture.repeat);
          texture.offset.copy(originalTexture.offset);
          texture.center.copy(originalTexture.center);
          texture.rotation = originalTexture.rotation;
        }
        
        // Apply the new texture
        child.material.map = texture;
        child.material.needsUpdate = true;
      }
    });
  }
  
  /**
   * Updates skin permissions based on server data
   * @param {Object} skinData - Skin permission data from server
   */
  updateSkinPermissions(skinData) {
    if (!skinData) return;
    
    let skinChanged = false;
    
    // Update permissions for each skin
    Object.keys(skinData).forEach(skinId => {
      if (this.skinPermissions.hasOwnProperty(skinId)) {
        const oldPermission = this.skinPermissions[skinId];
        const newPermission = skinData[skinId];
        
        this.skinPermissions[skinId] = newPermission;
        
        // If permission was granted, preload the skin
        if (!oldPermission && newPermission) {
          this.loadSkinTexture(skinId);
          skinChanged = true;
        }
      }
    });
    
    // Reset to default skin if current skin is no longer permitted
    if (skinChanged && this.activeSkin && !this.skinPermissions[this.activeSkin]) {
      this.updateSkin('default');
    }
  }
  
  /**
   * Cancels the current reload animation and resets animation state
   */
  cancelReload() {
    if (!this.isLoaded) return;
    
    // Determine which weapon prefix to use
    const weaponPrefix = window.localPlayer && window.localPlayer.activeWeapon === 'shotgun' ? 'shotgun' : 'revolver';
    
    // Reset animation flags
    this.forceVisible = false;
    this.blockHolster = false;
    this.pendingHolster = false;
    this.pendingAimTransition = false;
    
    // Clear any pending animation timeouts
    if (this._actionTimeoutId) {
      clearTimeout(this._actionTimeoutId);
      this._actionTimeoutId = null;
    }
    if (this._holsterTimeoutId) {
      clearTimeout(this._holsterTimeoutId);
      this._holsterTimeoutId = null;
    }
    
    // Stop the reload animation
    if (this.actions[`${weaponPrefix}reload`]) {
      this.actions[`${weaponPrefix}reload`].stop();
    }
    
    // Transition to idle animation
    this._transitionTo(`${weaponPrefix}idle`, {
      resetTimeOnPlay: true
    });
    
    // If player isn't aiming, hide the viewmodel
    if (window.localPlayer && !window.localPlayer.isAiming) {
      setTimeout(() => {
        this.group.visible = false;
      }, 100); // Short delay to ensure animation transition starts
    }
    
    console.log(`Canceled ${weaponPrefix} reload animation`);
  }

  _getWeaponPrefix() {
    return window.localPlayer && window.localPlayer.activeWeapon === 'shotgun' ? 'shotgun' : 'revolver';
  }

  _clearTimeouts() {
    if (this._actionTimeoutId) {
      clearTimeout(this._actionTimeoutId);
      this._actionTimeoutId = null;
    }
    if (this._holsterTimeoutId) {
      clearTimeout(this._holsterTimeoutId);
      this._holsterTimeoutId = null;
    }
  }

  _resetAnimationFlags() {
    this.blockHolster = false;
    this.pendingHolster = false;
    this.forceVisible = false;
    this.pendingAimTransition = false;
  }
} 

================================================
File: /public/wallet-demo.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phantom Wallet Demo</title>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    h1 {
      color: #333;
    }
    
    .info-section {
      margin-top: 20px;
      padding: 15px;
      background-color: #f0f0f0;
      border-radius: 6px;
    }
    
    .info-section h2 {
      margin-top: 0;
      font-size: 18px;
    }
    
    .wallet-info {
      display: none;
    }
    
    .wallet-info.active {
      display: block;
    }
    
    #wallet-address {
      word-break: break-all;
      font-family: monospace;
      padding: 8px;
      background-color: #e5e5e5;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Phantom Wallet Integration Demo</h1>
    
    <div class="info-section">
      <h2>About This Demo</h2>
      <p>This page demonstrates a simple Phantom wallet integration for Solana. You can connect your wallet using the purple button in the top-right corner.</p>
    </div>
    
    <div class="info-section wallet-info" id="wallet-info">
      <h2>Connected Wallet Information</h2>
      <p><strong>Wallet Address:</strong></p>
      <div id="wallet-address">Not connected</div>
      
      <p><strong>Connection Status:</strong> <span id="connection-status">Disconnected</span></p>
    </div>
  </div>
  
  <!-- Load Solana Web3.js from CDN -->
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  
  <!-- Load our Phantom Wallet Adapter -->
  <script type="module">
    import phantomWalletAdapter from './js/phantom-wallet.js';
    
    // Initialize the adapter when the page loads
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize the wallet adapter
      phantomWalletAdapter.init();
      
      // Set up event listeners to update UI when wallet connects
      document.addEventListener('walletConnected', (e) => {
        updateWalletInfo(e.detail.publicKey);
      });
      
      // Try to auto-connect if previously connected
      if (phantomWalletAdapter.isPhantomInstalled()) {
        const provider = window.phantom?.solana;
        if (provider) {
          provider.on('connect', (publicKey) => {
            phantomWalletAdapter.wallet = provider;
            phantomWalletAdapter.publicKey = publicKey.toString();
            phantomWalletAdapter.isConnected = true;
            phantomWalletAdapter.updateConnectButtonStatus(true);
            updateWalletInfo(publicKey.toString());
          });
          
          provider.on('disconnect', () => {
            phantomWalletAdapter.wallet = null;
            phantomWalletAdapter.publicKey = null;
            phantomWalletAdapter.isConnected = false;
            phantomWalletAdapter.updateConnectButtonStatus(false);
            updateWalletInfo(null);
          });
        }
      }
      
      // Custom event listeners for wallet adapter
      phantomWalletAdapter.onConnect = (publicKey) => {
        updateWalletInfo(publicKey);
      };
      
      phantomWalletAdapter.onDisconnect = () => {
        updateWalletInfo(null);
      };
    });
    
    // Update the wallet info UI
    function updateWalletInfo(publicKey) {
      const walletInfoSection = document.getElementById('wallet-info');
      const walletAddressElem = document.getElementById('wallet-address');
      const connectionStatusElem = document.getElementById('connection-status');
      
      if (publicKey) {
        walletInfoSection.classList.add('active');
        walletAddressElem.textContent = publicKey;
        connectionStatusElem.textContent = 'Connected';
        connectionStatusElem.style.color = 'green';
      } else {
        walletInfoSection.classList.remove('active');
        walletAddressElem.textContent = 'Not connected';
        connectionStatusElem.textContent = 'Disconnected';
        connectionStatusElem.style.color = 'red';
      }
    }
  </script>
</body>
</html> 

================================================
File: /server.js
================================================
// server.js
require('dotenv').config();
console.log("Starting server initialization...");
const express = require('express');
console.log("Express loaded");
const http = require('http');
console.log("HTTP loaded");
const WebSocket = require('ws');
console.log("WebSocket loaded");
const url = require('url');
console.log("URL loaded");
const app = express();
console.log("Express app created");
// Native fetch is available in Node.js v22, no need to require node-fetch

// Add Telegram Bot API support
const TelegramBot = require('node-telegram-bot-api');
console.log("Telegram Bot API loaded");

// Use environment variable for the bot token from Replit Secrets
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || 'YOUR_TELEGRAM_BOT_TOKEN';
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID || 1517919597; // Numeric ID for @erikszo

// Initialize the Telegram bot
const telegramBot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: false });
console.log("Telegram bot initialized");

// Function to send Telegram notifications
function sendTelegramNotification(message) {
  try {
    telegramBot.sendMessage(TELEGRAM_CHAT_ID, message)
      .then(() => {
        console.log(`Notification sent to ${TELEGRAM_CHAT_ID}: ${message}`);
      })
      .catch((error) => {
        console.error(`Failed to send Telegram notification: ${error.message}`);
      });
  } catch (error) {
    console.error(`Error in Telegram notification: ${error.message}`);
  }
}

// Standard HTTP port for the server
const PORT = process.env.PORT || 80;
console.log("Port set to", PORT);

// Serve static files from "public"
app.use(express.static('public'));
console.log("Static file serving configured");

// Add a specific route for the wallet demo page
app.get('/wallet', (req, res) => {
  res.sendFile(__dirname + '/public/wallet-demo.html');
  console.log("Wallet demo page requested");
});

const server = http.createServer(app);
console.log("HTTP server created");
const wss = new WebSocket.Server({ server, clientTracking: true });
console.log("WebSocket server created");

// Track connected players
const players = new Map();    // playerId -> { ws, sessionId, position, rotation, health, ... }
const sessions = new Set();   // tracks sessionIds to prevent duplicate connections
let nextPlayerId = 1;
console.log("Player tracking variables initialized");

// Track bot players (new)
const botPlayers = new Map(); // botId -> { position, rotation, health, ... }
console.log("Bot player tracking initialized");

// New: Track persistent player identities
const playerIdentities = new Map(); // clientId -> { username, playerId, token, lastSeen }
console.log("Player identity tracking initialized");

// Production mode
const isDevMode = false;
console.log(`Server running in ${isDevMode ? 'DEVELOPMENT' : 'PRODUCTION'} mode`);

// Position history tracking to reduce unnecessary corrections
const playerPositionHistory = new Map(); // playerId -> array of recent positions
const POSITION_HISTORY_SIZE = 10; // Number of positions to track per player
const CORRECTION_COOLDOWN = 5000; // Minimum ms between position corrections
console.log("Position history tracking initialized");

// Anti-cheat: Game physics constants
const GAME_CONSTANTS = {
  // Weapon constraints
  BULLET_SPEED: 80,           // Bullet speed units/second
  MAX_BULLET_DISTANCE: 100,   // Maximum distance a bullet can travel
  WEAPON_COOLDOWN: 250,       // Minimum time between shots in ms
  RELOAD_TIME: 4000,          // Time required to reload in ms
  DAMAGE_PER_HIT: 20,         // Health points reduced per hit
  // Town boundaries
  TOWN_WIDTH: 60,             // Width of the town
  TOWN_LENGTH: 100,           // Length of the town
  // Physics update rate
  PHYSICS_UPDATE_INTERVAL: 16 // ms (approx 60fps)
};

// Anti-cheat: Track active bullets map
const activeBullets = new Map(); // bulletId -> {sourcePlayerId, position, direction, timeCreated, etc}
let nextBulletId = 1;

// Anti-cheat: Timeout tracking (for rate limiting and cooldowns)
const playerTimeouts = new Map(); // playerId -> { lastShot, lastReload, lastTeleport, etc }

// Anti-cheat: Nonce tracking (for anti-replay protection)
const playerNonces = new Map(); // playerId -> Set of used nonces
const playerSequences = new Map(); // playerId -> last sequence number

// Add NFT verification configuration
// Hardcoded NFT token address for now (this would be a specific NFT or collection address)
const SPECIAL_SKIN_NFT_ADDRESS = "3j4UKuFb7FDQ4ZNSbSujiak6Ps7AQVE9ynnLHorArzGz"; // Replace with actual Solana NFT mint address
// You can add additional NFT addresses here
const SPECIAL_SKIN_NFT_ADDRESSES = [
  "3j4UKuFb7FDQ4ZNSbSujiak6Ps7AQVE9ynnLHorArzGz",
  "81FNAomj6H5r2VJ3e5J6NLDShqiUaEbMwVuCssYpVm9E",
  "58NysJG5K18zgLMN4uKVJ8HhetwwGz5fUDBCk52UfMtA",
  "EsT86r7ZRAeqGaczHidEH8byaWjt4zgAWDLqRgNSN3i5",
  // Add more NFT mint addresses here
];
const HELIUS_API_KEY = process.env.HELIUS_API_KEY; // Helius API key
const HELIUS_API_URL = `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`;

// Map to store wallet to skin permission mappings
const walletSkins = new Map(); // walletAddress -> { skins: { skinId: true }, ... }

/**
 * Checks if a wallet owns a specific NFT or any from a list via Helius API
 * @param {string} walletAddress - The wallet address to check
 * @param {string|string[]} nftAddresses - Single NFT mint address or array of NFT mint addresses to verify ownership
 * @returns {Promise<boolean>} Whether the wallet owns any of the NFTs
 */
async function checkNftOwnership(walletAddress, nftAddresses) {
  try {
    // Convert single address to array if needed
    const addresses = Array.isArray(nftAddresses) ? nftAddresses : [nftAddresses];
    
    console.log(`Checking if wallet ${walletAddress} owns any of ${addresses.length} NFTs`);
    
    const response = await fetch(HELIUS_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: 'helius-test',
        method: 'getAssetsByOwner',
        params: {
          ownerAddress: walletAddress,
          page: 1,
          limit: 100,
        },
      }),
    });
    
    const data = await response.json();
    
    if (data.error) {
      console.error('Helius API error:', data.error);
      return false;
    }
    
    // Check if the wallet owns any of the NFTs
    const assets = data.result.items;
    const ownsNft = assets.some(asset => addresses.includes(asset.id));
    
    console.log(`Wallet ${walletAddress} ${ownsNft ? 'owns' : 'does not own'} one of the specified NFTs`);
    
    return ownsNft;
  } catch (error) {
    console.error('Error checking NFT ownership:', error);
    return false;
  }
}

/**
 * Updates the player's skin based on wallet NFT ownership
 * @param {string} playerId - The player ID
 * @param {string} walletAddress - The wallet address
 */
async function updatePlayerSkin(playerId, walletAddress) {
  try {
    // Check if the wallet owns any of the special NFTs
    const ownsSpecialSkin = await checkNftOwnership(walletAddress, SPECIAL_SKIN_NFT_ADDRESSES);
    
    // Update the player's skin permissions
    walletSkins.set(walletAddress, {
      skins: {
        bananaSkin: ownsSpecialSkin
      }
    });
    
    // Get the player from the players map
    const player = players.get(playerId);
    if (!player) return;
    
    // Update the player data with skin information
    player.skins = {
      bananaSkin: ownsSpecialSkin
    };
    
    // Broadcast the skin update to all players
    broadcastToAll({
      type: 'playerSkinUpdate',
      playerId: playerId,
      skins: {
        bananaSkin: ownsSpecialSkin
      }
    });
    
    // Send confirmation to the player
    player.ws.send(JSON.stringify({
      type: 'skinPermissionUpdate',
      skins: {
        bananaSkin: ownsSpecialSkin
      }
    }));
    
    console.log(`Updated skin permissions for player ${playerId} (wallet: ${walletAddress}): bananaSkin=${ownsSpecialSkin}`);
  } catch (error) {
    console.error(`Error updating player skin for ${playerId}:`, error);
  }
}

// Create helper function for sanitizing text to prevent XSS
function sanitizeText(text) {
  if (!text || typeof text !== 'string') return '';
  
  // Remove potentially dangerous content first
  text = text
    .replace(/<[^>]*>/g, '') // Remove HTML tags
    .replace(/javascript:/gi, '') // Remove javascript: protocol
    .replace(/on\w+=/gi, '') // Remove event handlers
    .trim();
    
  // Limit length for usernames
  if (text.length > 20) {
    text = text.substring(0, 20);
  }
  
  // Perform HTML escaping
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

// On new connection
wss.on('connection', (ws, req) => {
  // Parse parameters from query string
  const parameters = url.parse(req.url, true).query;
  const sessionId = parameters.sessionId;
  const clientId = parameters.clientId;
  let username = parameters.username;
  const token = parameters.token;
  const walletAddress = parameters.walletAddress; // New: Get wallet address if provided
  
  // Sanitize username to prevent XSS
  username = sanitizeText(username || 'Anonymous');

  // Check if this is a development mode connection
  const isDev = isDevMode && (parameters.dev === 'true' || parameters.newplayer === 'true');
  
  if (isDev) {
    console.log("Development mode connection detected");
  }

  // If we already have this sessionId, reject as duplicate
  // Skip this check for development mode connections
  if (sessionId && sessions.has(sessionId) && !isDev) {
    console.log(`Rejecting duplicate connection with sessionId: ${sessionId}`);
    ws.send(JSON.stringify({
      type: 'error',
      message: 'Duplicate connection detected',
      fatal: true
    }));
    return ws.close(1008, 'Duplicate connection');
  }

  if (sessionId) {
    sessions.add(sessionId);
  }

  // Verify player identity if clientId and token provided
  // Skip verification for development mode connections
  if (clientId && token && !isDev) {
    const storedIdentity = playerIdentities.get(clientId);
    
    // If we have this player's identity stored already
    if (storedIdentity) {
      // Check if token matches
      if (storedIdentity.token !== token) {
        console.log(`Token mismatch for clientId: ${clientId}`);
        ws.send(JSON.stringify({
          type: 'authFailure',
          reason: 'invalidToken',
          message: 'Invalid authentication token'
        }));
        return ws.close(1008, 'Authentication failure');
      }
      
      // Update the stored player identity
      storedIdentity.lastSeen = Date.now();
      storedIdentity.username = sanitizeText(username || storedIdentity.username);
      
      // Use the existing player ID for this client
      const playerId = storedIdentity.playerId;
      console.log(`Recognized returning player ${playerId} (clientId: ${clientId}, username: ${sanitizeText(username || storedIdentity.username)})`);
      
      // Send Telegram notification for returning player
      if (!isDev) {
        sendTelegramNotification(`🔄 Player reconnected: ${sanitizeText(username || storedIdentity.username)} (ID: ${playerId})`);
      }
      
      // Initialize player with recognized identity
      initializePlayer(ws, playerId, sessionId, clientId, sanitizeText(username || storedIdentity.username), token, isDev);
      return;
    }
  }

  // If we reach here, it's a new player or unrecognized returning player
  const playerId = nextPlayerId++;
  console.log(`Player ${playerId} connected (sessionId: ${sessionId || 'none'}, username: ${username}, isDev: ${isDev})`);

  // Store player identity information if provided (unless in dev mode with newplayer=true)
  if (clientId && !isDev) {
    playerIdentities.set(clientId, {
      username: username,
      playerId,
      token: token || '',
      lastSeen: Date.now()
    });
    console.log(`Associated player ${playerId} with clientId ${clientId} and username ${username}`);
    
    // Send Telegram notification for new player
    sendTelegramNotification(`🎮 New player joined: ${username} (ID: ${playerId})`);
  }

  // Initialize the new player
  initializePlayer(ws, playerId, sessionId, clientId, username, token, isDev);
});

// Extract player initialization to a separate function
function initializePlayer(ws, playerId, sessionId, clientId, username, token, isDev = false) {
  // Create initial player data with health
  players.set(playerId, {
    ws,
    sessionId,
    clientId,
    username,
    isDev, // Store dev mode flag for reference
    position: { x: 0, y: 1.6, z: 0 },
    rotation: { y: 0 },
    isAiming: false,
    isShooting: false,
    isReloading: false,
    health: 100,
    lastActivity: Date.now(),
    // Additional player state
    bullets: 6,
    maxBullets: 6,
    lastUpdateTime: Date.now(),
    // Initialize skin data for new players
    skins: {
      bananaSkin: false // Default to no special skin
    }
  });

  // Anti-cheat: Initialize timeout tracking
  playerTimeouts.set(playerId, {
    lastShot: 0,
    lastMovement: 0,
    lastReload: 0,
    lastPositionUpdate: 0,
    lastPositionCorrection: 0,
    reloadStartTime: 0,
    isReloading: false
  });

  // Anti-cheat: Initialize nonce/sequence tracking
  playerNonces.set(playerId, new Set());
  playerSequences.set(playerId, 0);

  // Send init data to this client (their ID + existing players)
  // FIXED: Ensure we don't include the player's own ID in the list of players sent
  ws.send(JSON.stringify({
    type: 'init',
    id: playerId,
    players: Array.from(players.entries())
      .filter(([pid]) => pid !== playerId) // Make sure to exclude the player's own ID
      .map(([pid, p]) => ({
        id: pid,
        position: p.position,
        rotation: p.rotation,
        isAiming: p.isAiming,
        isShooting: p.isShooting,
        isReloading: p.isReloading,
        health: p.health,
        username: p.username,
        skins: p.skins || { bananaSkin: false } // Include skin information for existing players
      }))
  }));

  // Send initial train state
  sendInitialTrainState(ws);

  // Notify others that a new player joined
  broadcastToOthers(playerId, {
    type: 'playerJoined',
    id: playerId,
    position: players.get(playerId).position,
    rotation: players.get(playerId).rotation,
    health: players.get(playerId).health,
    username: players.get(playerId).username,
    skins: players.get(playerId).skins // Include skins in the join message
  });

  // Handle incoming messages
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);

      // Update lastActivity
      const player = players.get(playerId);
      if (!player) return;
      
      player.lastActivity = Date.now();

      // Anti-cheat: Sequence number validation
      if (data.sequenceNumber !== undefined) {
        const lastSequence = playerSequences.get(playerId) || 0;
        
        // Reject if sequence number is not greater than the last one
        if (data.sequenceNumber <= lastSequence) {
          console.log(`Rejecting message with old sequence number: ${data.sequenceNumber} (last: ${lastSequence})`);
          return sendErrorToPlayer(playerId, "Invalid sequence number", false);
        }
        
        // Update the last sequence number
        playerSequences.set(playerId, data.sequenceNumber);
      }

      // Anti-cheat: Nonce validation for critical actions
      if ((data.type === 'shoot' || data.type === 'playerHit') && data.nonce) {
        const playerNonceSet = playerNonces.get(playerId);
        
        // Check if nonce has been used before
        if (playerNonceSet && playerNonceSet.has(data.nonce)) {
          console.log(`Rejecting repeated nonce: ${data.nonce} from player ${playerId}`);
          return sendErrorToPlayer(playerId, "Duplicate nonce detected", false);
        }
        
        // Store the nonce
        if (playerNonceSet) {
          playerNonceSet.add(data.nonce);
          
          // Limit nonce set size to prevent memory issues
          if (playerNonceSet.size > 1000) {
            // Keep only the most recent 500 nonces
            const nonceArray = Array.from(playerNonceSet);
            const newNonceSet = new Set(nonceArray.slice(nonceArray.length - 500));
            playerNonces.set(playerId, newNonceSet);
          }
        }
      }

      switch (data.type) {
        case 'update':
          handlePlayerUpdate(playerId, data);
          break;

        case 'shoot':
          handlePlayerShoot(playerId, data);
          break;

        case 'playerHit':
          handlePlayerHit(playerId, data.targetId, data.hitData, data.bulletId);
          break;

        case 'reload':
          handlePlayerReload(playerId, data);
          break;

        case 'ping':
          // respond
          ws.send(JSON.stringify({ type: 'pong' }));
          break;

        // Handle chat messages
        case 'chat':
          handleChatMessage(playerId, data.message);
          break;

        // Handle bot player updates
        case 'bot_update':
          handleBotUpdate(data);
          break;
        
        // Handle bot player removal
        case 'bot_remove':
          handleBotRemove(data);
          break;

        // Handle wallet connection from client
        case 'walletConnect':
          if (!data.walletAddress) {
            console.error(`Invalid wallet connection from player ${playerId}: No wallet address provided`);
            return;
          }
          
          const player = players.get(playerId);
          if (!player) {
            console.error(`Wallet connection received for unknown player ${playerId}`);
            return;
          }
          
          console.log(`Player ${playerId} connected wallet: ${data.walletAddress}`);
          
          // Update player record with wallet address
          player.walletAddress = data.walletAddress;
          
          // Check NFT ownership and update skin permissions
          updatePlayerSkin(playerId, data.walletAddress);
          break;

        // Handle train state request
        case 'requestTrainState':
          console.log(`Player ${playerId} requested train state`);
          sendInitialTrainState(player.ws);
          return;

        default:
          break;
      }
    } catch (err) {
      console.error(`Error handling message from player ${playerId}:`, err);
    }
  });

  // On close
  ws.on('close', () => {
    cleanupPlayer(playerId);
  });

  // On error
  ws.on('error', (err) => {
    console.error(`WebSocket error for player ${playerId}:`, err);
    cleanupPlayer(playerId);
  });

  // Update the global player count UI
  updatePlayerCount();
}

// Handle player updates - removed speed/position validation
function handlePlayerUpdate(playerId, data) {
  const player = players.get(playerId);
  const timeouts = playerTimeouts.get(playerId);
  
  if (!player || !timeouts) return;
  
  const now = Date.now();
  
  // Anti-cheat: Basic rate limit for position updates only
  if (now - timeouts.lastPositionUpdate < 16) { // Max 60 updates per second
    return; // Silently ignore too frequent updates
  }
  timeouts.lastPositionUpdate = now;
  
  // Update player data - town boundary check removed to allow players to explore freely
  if (data.position) {
    player.position = data.position;
  }
  
  // Update other player properties
  player.rotation = data.rotation || player.rotation;
  player.isAiming = data.isAiming !== undefined ? data.isAiming : player.isAiming;
  player.isReloading = data.isReloading !== undefined ? data.isReloading : player.isReloading;
  
  if (data.isSprinting !== undefined) {
    player.isSprinting = data.isSprinting;
  }
  
  // Broadcast valid update to others
  broadcastToOthers(playerId, {
    type: 'playerUpdate',
    id: playerId,
    position: player.position,
    rotation: player.rotation,
    isAiming: player.isAiming,
    isShooting: player.isShooting,
    isReloading: player.isReloading,
    health: player.health,
    username: player.username
  });
}

// Anti-cheat: Handle player shooting with validation and server-side trajectory
function handlePlayerShoot(playerId, data) {
  const player = players.get(playerId);
  const timeouts = playerTimeouts.get(playerId);
  
  if (!player || !timeouts) return;
  
  const now = Date.now();
  
  // Anti-cheat: Check if player has bullets
  if (player.bullets <= 0) {
    return sendErrorToPlayer(playerId, "Cannot shoot: out of ammo", false);
  }
  
  // Anti-cheat: Check if player is reloading
  if (player.isReloading) {
    return sendErrorToPlayer(playerId, "Cannot shoot while reloading", false);
  }
  
  // Anti-cheat: Enforce weapon cooldown
  if (now - timeouts.lastShot < GAME_CONSTANTS.WEAPON_COOLDOWN) {
    console.log(`Rate limit exceeded: Player ${playerId} attempted to shoot too quickly`);
    return sendErrorToPlayer(playerId, "Shooting too fast", false);
  }
  
  // Validate bullet data
  if (!data.bulletData || !data.bulletData.position || !data.bulletData.direction) {
    return sendErrorToPlayer(playerId, "Invalid bullet data", false);
  }
  
  // Validate bullet direction (must be normalized)
  const direction = data.bulletData.direction;
  const dirMagnitude = Math.sqrt(direction.x*direction.x + direction.y*direction.y + direction.z*direction.z);
  
  if (Math.abs(dirMagnitude - 1) > 0.01) {
    console.log(`Invalid bullet direction: not normalized for player ${playerId} (magnitude: ${dirMagnitude.toFixed(2)})`);
    
    // Normalize the direction
    direction.x /= dirMagnitude;
    direction.y /= dirMagnitude;
    direction.z /= dirMagnitude;
  }
  
  // All validations passed, decrement bullet count
  player.bullets--;
  
  // Update lastShot timestamp
  timeouts.lastShot = now;
  
  // Handle shotgun pellets - generate multiple projectiles with spread
  const isShotgun = player.activeWeapon === 'shotgun';
  const bulletCount = isShotgun ? 10 : 1; // 10 pellets for shotgun, 1 for revolver
  
  // If multiple bullets come from revolver in a single shot, it's likely cheating
  if (!isShotgun && data.bulletData.pelletCount && data.bulletData.pelletCount > 1) {
    console.log(`Potential cheating detected: Player ${playerId} tried to fire multiple revolver bullets at once`);
    return sendErrorToPlayer(playerId, "Invalid bullet count for weapon type", true);
  }
  
  // Create server-side bullets (one bullet for revolver, multiple pellets for shotgun)
  for (let i = 0; i < bulletCount; i++) {
    const bulletId = nextBulletId++;
    
    // For shotgun, apply spread to each pellet except the first one (which uses the original aim direction)
    let pelletDirection = { ...direction };
    
    if (isShotgun && i > 0) {
      // Apply realistic shotgun spread
      const spread = 0.08; // Match client-side spread value
      pelletDirection = {
        x: direction.x + (Math.random() - 0.5) * spread,
        y: direction.y + (Math.random() - 0.5) * spread,
        z: direction.z + (Math.random() - 0.5) * spread
      };
      
      // Normalize the direction after applying spread
      const pelletDirMag = Math.sqrt(
        pelletDirection.x * pelletDirection.x + 
        pelletDirection.y * pelletDirection.y + 
        pelletDirection.z * pelletDirection.z
      );
      
      pelletDirection.x /= pelletDirMag;
      pelletDirection.y /= pelletDirMag;
      pelletDirection.z /= pelletDirMag;
    }
    
    const bullet = {
      id: bulletId,
      sourcePlayerId: playerId,
      position: data.bulletData.position,
      direction: pelletDirection,
      distanceTraveled: 0,
      maxDistance: GAME_CONSTANTS.MAX_BULLET_DISTANCE,
      speed: GAME_CONSTANTS.BULLET_SPEED,
      timeCreated: now,
      active: true,
      isShotgunPellet: isShotgun,
      pelletIndex: i
    };
    
    // Add to active bullets
    activeBullets.set(bulletId, bullet);
    
    // For the first bullet/pellet or if it's a revolver shot, notify all clients
    // For shotgun pellets after the first, only notify about first pellet to save bandwidth
    if (i === 0 || !isShotgun) {
      broadcastToAll({
        type: 'playerShoot',
        id: playerId,
        bulletId: bulletId,
        bulletData: {
          position: data.bulletData.position,
          direction: pelletDirection,
          isShotgunPellet: isShotgun
        }
      });
    }
  }
  
  // Update the player's shooting state
  player.isShooting = true;
  
  // Reset shooting state after a short delay
  setTimeout(() => {
    if (players.has(playerId)) {
      players.get(playerId).isShooting = false;
    }
  }, 100);
}

// Anti-cheat: Handle player reload with validation
function handlePlayerReload(playerId, data) {
  const player = players.get(playerId);
  const timeouts = playerTimeouts.get(playerId);
  
  if (!player || !timeouts) return;
  
  const now = Date.now();
  
  // Check if player is already reloading
  if (player.isReloading) {
    return sendErrorToPlayer(playerId, "Already reloading", false);
  }
  
  // Check if player has full ammo
  if (player.bullets >= player.maxBullets) {
    return sendErrorToPlayer(playerId, "Ammo already full", false);
  }
  
  // Start reload process
  player.isReloading = true;
  timeouts.isReloading = true;
  timeouts.reloadStartTime = now;
  
  // Notify all players about reload start
  broadcastToAll({
    type: 'playerUpdate',
    id: playerId,
    isReloading: true
  });
  
  // Schedule reload completion
  setTimeout(() => {
    if (!players.has(playerId)) return;
    
    const timeouts = playerTimeouts.get(playerId);
    if (!timeouts) return;
    
    // Check if player is still reloading (could have been cancelled)
    if (timeouts.isReloading) {
      const player = players.get(playerId);
      
      // Complete reload
      player.bullets = player.maxBullets;
      player.isReloading = false;
      timeouts.isReloading = false;
      
      // Notify all players about reload completion
      broadcastToAll({
        type: 'playerUpdate',
        id: playerId,
        isReloading: false,
        bullets: player.maxBullets
      });
    }
  }, GAME_CONSTANTS.RELOAD_TIME);
}

// Anti-cheat: Handle player hit validation
function handlePlayerHit(playerId, targetId, hitData, bulletId) {
  console.log(`Player ${playerId} claims hit on player ${targetId}`);
  
  // Basic validation
  if (!players.has(playerId) || !players.has(targetId)) {
    console.log(`Hit claim invalid - player ${playerId} or target ${targetId} not found`);
    return;
  }
  
  const player = players.get(playerId);
  const target = players.get(targetId);
  
  // Check if bullet ID is valid, if provided
  if (bulletId && !activeBullets.has(bulletId)) {
    console.log(`Invalid bullet ID: ${bulletId}`);
    return sendErrorToPlayer(playerId, "Invalid bullet ID", false);
  }
  
  // Track hit timestamps to prevent double-counting hits
  // Initialize hit tracking structure if not already present
  if (!player.recentHits) {
    player.recentHits = new Map();
  }
  
  // Check for duplicate/too frequent hits on the same target
  const now = Date.now();
  const lastHitTime = player.recentHits.get(targetId) || 0;
  
  // If this is a shotgun hit, use a shorter debounce time to allow multiple pellets to hit
  const isShotgunHit = player.activeWeapon === 'shotgun' || 
                      (bulletId && activeBullets.has(bulletId) && activeBullets.get(bulletId).isShotgunPellet);
  
  // Use a shorter debounce time for shotgun pellets (50ms) vs regular bullets (300ms)
  const hitDebounceTime = isShotgunHit ? 50 : 300;
  
  if (now - lastHitTime < hitDebounceTime) {
    console.log(`Hit debounced: Player ${playerId} hit ${targetId} too quickly after last hit (${now - lastHitTime}ms)`);
    return; // Silently ignore too-frequent hits
  }
  
  // Update last hit time for this target
  player.recentHits.set(targetId, now);
  
  // Rest of original hit handling
  // Get bullet data if available
  let bullet = null;
  if (bulletId && activeBullets.has(bulletId)) {
    bullet = activeBullets.get(bulletId);
  }
  
  // Calculate damage based on hit zone and weapon type
  let damage = GAME_CONSTANTS.DAMAGE_PER_HIT;
  
  // Check if this is a shotgun pellet hit
  const isShotgunPellet = player.activeWeapon === 'shotgun' || 
                         (bullet && bullet.isShotgunPellet);
  
  if (isShotgunPellet) {
    // Shotgun pellet damage
    if (hitData.hitZone === 'head') {
      damage = 10; // Per pellet headshot damage
    } else {
      damage = 5;  // Per pellet body/limb damage
    }
  } else {
    // Regular bullet damage
    if (hitData.hitZone === 'head') {
      damage = 100; // One-shot kill for headshots
    } else if (hitData.hitZone === 'body') {
      damage = 40; // Standard body shot
    } else if (hitData.hitZone === 'limbs') {
      damage = 20; // Reduced damage for limbs
    }
  }
  
  // Apply damage to target
  target.health = Math.max(0, target.health - damage);
  
  // Notify both target and shooter
  if (target.ws && target.ws.readyState === WebSocket.OPEN) {
    target.ws.send(JSON.stringify({
      type: 'hit',
      sourceId: playerId,
      hitData: hitData,
      hitZone: hitData.hitZone,
      health: target.health
    }));
  }
  
  if (player.ws && player.ws.readyState === WebSocket.OPEN) {
    player.ws.send(JSON.stringify({
      type: 'playerHit',
      targetId: targetId,
      sourceId: playerId,
      hitPosition: hitData.position,
      health: target.health,
      hitZone: hitData.hitZone,
      damage: damage
    }));
  }
  
  // Broadcast hit to other players for visual effects
  broadcastToOthers([playerId, targetId], {
    type: 'playerHit',
    targetId: targetId,
    sourceId: playerId,
    hitPosition: hitData.position,
    health: target.health,
    hitZone: hitData.hitZone,
    damage: damage
  });
  
  // Check if target has been defeated
  if (target.health <= 0) {
    handlePlayerDeath(targetId, playerId);
  }
}

// Anti-cheat: Bullet-player collision detection
function isPlayerHitByBullet(player, bullet) {
  // Calculate player hitbox (simple cylinder)
  const playerRadius = 0.6;  // Increased horizontal radius to match client's bodyWidth
  const playerHeight = 2.0;  // vertical height
  
  // Calculate distance from bullet to player (horizontal only)
  const dx = bullet.position.x - player.position.x;
  const dz = bullet.position.z - player.position.z;
  const horizontalDist = Math.sqrt(dx * dx + dz * dz);
  
  // Check if bullet is within player's horizontal radius
  if (horizontalDist > playerRadius) {
    return false;
  }
  
  // Check if bullet is within player's vertical bounds
  const bulletY = bullet.position.y;
  const playerBottom = player.position.y - 1.6; // Adjust based on your coordinate system
  const playerTop = playerBottom + playerHeight;
  
  // Add some tolerance to vertical bounds
  const tolerance = 0.2;
  if (bulletY < playerBottom - tolerance || bulletY > playerTop + tolerance) {
    return false;
  }
  
  // Bullet is inside player's hitbox
  return true;
}

// Anti-cheat: Handle player death
function handlePlayerDeath(playerId, killedById) {
  const player = players.get(playerId);
  if (!player) return;
  
  console.log(`Player ${playerId} was killed by player ${killedById}`);
  
  // Send death notification to all clients
  broadcastToAll({
    type: 'playerDeath',
    id: playerId,
    killedById: killedById
  });
  
  // Send death notification to the killed player
  if (player.ws && player.ws.readyState === WebSocket.OPEN) {
    player.ws.send(JSON.stringify({
      type: 'death',
      killerId: killedById
    }));
  }
  
  // Send kill notification to the killer
  const killer = players.get(killedById);
  if (killer && killer.ws && killer.ws.readyState === WebSocket.OPEN) {
    killer.ws.send(JSON.stringify({
      type: 'kill',
      targetId: playerId
    }));
  }
  
  // Delay respawn to allow death animation to complete
  setTimeout(() => {
    // Check if player is still connected
    if (players.has(playerId)) {
      respawnPlayer(playerId);
    }
  }, 2000); // 2 second delay for death animation
}

// Anti-cheat: Respawn a player
function respawnPlayer(playerId) {
  const player = players.get(playerId);
  if (!player) return;
  
  // Reset player state
  player.health = 100;
  
  // Reset weapon state based on active weapon
  if (!player.activeWeapon) {
    player.activeWeapon = 'revolver'; // Default if not set
  }
  
  // Define weapon capacities
  const weaponCapacity = {
    revolver: 6,
    shotgun: 2
  };
  
  // Set max bullets based on active weapon
  player.maxBullets = weaponCapacity[player.activeWeapon] || 6;
  
  // Reset ammo to maximum
  player.bullets = player.maxBullets;
  
  // Reset states
  player.isReloading = false;
  player.isAiming = false;
  player.isShooting = false;
  
  // Generate random spawn position within town
  const spawnX = (Math.random() - 0.5) * GAME_CONSTANTS.TOWN_WIDTH * 0.8;
  const spawnY = 1.6;
  const spawnZ = (Math.random() - 0.5) * GAME_CONSTANTS.TOWN_LENGTH * 0.8;
  
  // Set spawn position
  player.position = { x: spawnX, y: spawnY, z: spawnZ };
  
  // Notify the player they're respawning
  if (player.ws.readyState === WebSocket.OPEN) {
    player.ws.send(JSON.stringify({
      type: 'respawn',
      position: player.position,
      health: player.health,
      bullets: player.bullets,
      maxBullets: player.maxBullets,
      activeWeapon: player.activeWeapon
    }));
  }
  
  // Broadcast the respawn to all players
  broadcastToAll({
    type: 'playerUpdate',
    id: playerId,
    position: player.position,
    health: player.health,
    isReloading: false,
    isAiming: false,
    isDying: false,             // Explicitly reset death animation state
    resetAnimationState: true,  // Special flag to trigger animation reset on clients
    activeWeapon: player.activeWeapon
  });
}

// Anti-cheat: Check if position is within town boundaries
function isPositionInTown(position) {
  // Modified to always return true, allowing players to leave town
  return true;
}

// Anti-cheat: Send position correction to player
function sendPositionCorrection(playerId, correctPosition) {
  const player = players.get(playerId);
  if (!player || player.ws.readyState !== WebSocket.OPEN) return;
  
  const now = Date.now();
  const timeouts = playerTimeouts.get(playerId);
  
  // Skip if we've recently sent a correction
  if (timeouts && timeouts.lastPositionCorrection && 
      now - timeouts.lastPositionCorrection < CORRECTION_COOLDOWN) {
    return;
  }
  
  // Calculate distance between current position and correction
  const currentPos = player.position;
  const distance = Math.sqrt(
    Math.pow(currentPos.x - correctPosition.x, 2) +
    Math.pow(currentPos.y - correctPosition.y, 2) +
    Math.pow(currentPos.z - correctPosition.z, 2)
  );
  
  // Only send significant corrections (>5 units) to avoid unnecessary resets
  if (distance > 5) {
    console.log(`Sending position correction to player ${playerId}, distance: ${distance.toFixed(2)}`);
    
    // Update last correction time
    if (timeouts) {
      timeouts.lastPositionCorrection = now;
    }
    
    player.ws.send(JSON.stringify({
      type: 'positionCorrection',
      position: correctPosition
    }));
  }
}

// Anti-cheat: Send error message to player
function sendErrorToPlayer(playerId, message, fatal = false) {
  const player = players.get(playerId);
  if (!player || player.ws.readyState !== WebSocket.OPEN) return;
  
  player.ws.send(JSON.stringify({
    type: 'error',
    message: message,
    fatal: fatal
  }));
}

// Cleanup a disconnected or stale player
function cleanupPlayer(playerId) {
  const player = players.get(playerId);
  
  if (!player) return;
  
  console.log(`Cleaning up player ${playerId}`);
  
  // If this player has a clientId, update their lastSeen time
  if (player.clientId) {
    const identity = playerIdentities.get(player.clientId);
    if (identity) {
      identity.lastSeen = Date.now();
      console.log(`Updated lastSeen for identity ${player.clientId}`);
    }
  }
  
  if (player.sessionId) {
    sessions.delete(player.sessionId);
  }
  
  players.delete(playerId);
  
  // Anti-cheat: Clean up associated data
  playerTimeouts.delete(playerId);
  playerNonces.delete(playerId);
  playerSequences.delete(playerId);
  playerPositionHistory.delete(playerId);
  
  // Send Telegram notification for player disconnect
  if (player.username && !player.isDev) {
    sendTelegramNotification(`👋 Player left: ${player.username} (ID: ${playerId})`);
  }

  // Notify all that the player left
  broadcastToAll({
    type: 'playerLeft',
    id: playerId
  });

  updatePlayerCount();
}

// Broadcast a "playerCount" update to all
function updatePlayerCount() {
  broadcastToAll({
    type: 'playerCount',
    count: players.size
  });
}

// Broadcast to all except a given playerId
function broadcastToOthers(excludeId, data) {
  for (const [pid, pl] of players.entries()) {
    // Skip if this is the excluded player ID (could be a number or an array of numbers)
    if (Array.isArray(excludeId) ? excludeId.includes(pid) : pid === excludeId) continue;
    
    if (pl.ws.readyState === WebSocket.OPEN) {
      pl.ws.send(JSON.stringify(data));
    }
  }
}

// Broadcast to all players
function broadcastToAll(data) {
  players.forEach((player, id) => {
    if (player.ws.readyState === WebSocket.OPEN) {
      player.ws.send(JSON.stringify(data));
    }
  });
}

/**
 * Handle chat messages from players and broadcast them
 * @param {number} playerId - The ID of the player sending the message 
 * @param {string} message - The chat message
 */
function handleChatMessage(playerId, message) {
  // Get player info
  const player = players.get(playerId);
  if (!player) return;
  
  // Rate limiting - max one message per 2 seconds
  const now = Date.now();
  const timeouts = playerTimeouts.get(playerId);
  if (timeouts) {
    if (!timeouts.lastChat) {
      timeouts.lastChat = 0;
    }
    
    // Rate limiting
    if (now - timeouts.lastChat < 2000) {
      console.log(`Chat rate limited for player ${playerId}`);
      return;
    }
    
    timeouts.lastChat = now;
  }
  
  // Validate and sanitize message
  if (!message || typeof message !== 'string') return;
  
  // Limit message length (chat messages can be longer than usernames)
  if (message.length > 60) {
    message = message.substring(0, 60);
  }
  
  // Sanitize the message
  message = sanitizeText(message);
  
  console.log(`Chat message from ${player.username} (${playerId}): ${message}`);
  
  // Broadcast the message to all players
  broadcastToAll({
    type: 'chatMessage',
    senderId: playerId,
    username: player.username,
    message: message
  });
}

// Handle bot player updates
function handleBotUpdate(data) {
  // This function is still used by client-controlled bots
  // Update the bot player with the provided data
  if (!data.id || !botPlayers.has(data.id)) {
    // If bot doesn't exist yet, create it
    const botId = data.id || `bot_${Date.now()}`;
    
    botPlayers.set(botId, {
      id: botId,
      position: data.position || { x: 0, y: 1.6, z: 0 },
      rotation: data.rotation || { y: 0 },
      isAiming: data.isAiming || false,
      isShooting: data.isShooting || false,
      isReloading: data.isReloading || false,
      health: data.health || 100,
      username: sanitizeText(data.username || 'Bot')
    });
    
    // Broadcast to all players that a new bot has joined
    broadcastToAll({
      type: 'playerJoined',
      id: botId,
      position: botPlayers.get(botId).position,
      rotation: botPlayers.get(botId).rotation,
      health: botPlayers.get(botId).health,
      username: botPlayers.get(botId).username,
      isBot: true
    });
    
    console.log(`Added bot player: ${botId} (${botPlayers.get(botId).username})`);
    return;
  }
  
  // Update existing bot
  const bot = botPlayers.get(data.id);
  
  // Update bot properties
  if (data.position) bot.position = data.position;
  if (data.rotation) bot.rotation = data.rotation;
  if (data.isAiming !== undefined) bot.isAiming = data.isAiming;
  if (data.isShooting !== undefined) bot.isShooting = data.isShooting;
  if (data.isReloading !== undefined) bot.isReloading = data.isReloading;
  if (data.health !== undefined) bot.health = data.health;
  
  // Broadcast updated bot state
  broadcastToAll({
    type: 'playerUpdate',
    id: data.id,
    position: bot.position,
    rotation: bot.rotation,
    isAiming: bot.isAiming,
    isShooting: bot.isShooting,
    isReloading: bot.isReloading,
    health: bot.health,
    username: bot.username,
    isBot: true
  });
}

// Handle bot player removal
function handleBotRemove(data) {
  if (!data.id || !botPlayers.has(data.id)) {
    console.log(`Cannot remove non-existent bot: ${data.id}`);
    return;
  }
  
  const botId = data.id;
  const bot = botPlayers.get(botId);
  
  // Remove the bot
  botPlayers.delete(botId);
  
  // Broadcast that the bot has left
  broadcastToAll({
    type: 'playerLeft',
    id: botId
  });
  
  console.log(`Removed bot player: ${botId} (${bot.username})`);
}

/**
 * Convert degrees to radians
 * @param {number} degrees - Angle in degrees
 * @returns {number} The angle in radians
 */
function degToRad(degrees) {
  return degrees * (Math.PI / 180);
}

// =============================================
// Train System - Server Side Implementation
// =============================================

// Train variables
const TRAIN_SPEED = 0.0003; // Same speed as client to maintain consistency
const TRAIN_TRACK_START = { x: 0, y: 0, z: -1000 };
const TRAIN_TRACK_END = { x: 0, y: 0, z: 1000 };
const TRAIN_TRACK_LENGTH = 2000; // Total length between start and end
const TRAIN_CYCLE_TIME = Math.floor(TRAIN_TRACK_LENGTH / (TRAIN_SPEED * 60)); // Time in ms for a full one-way trip

// Time-based tracking
const TRAIN_START_TIME = Date.now(); // Global reference time when train started
let trainDirection = 1; // Current direction (1 = forward, -1 = backward)

// Send train updates every 2 seconds
const TRAIN_BROADCAST_INTERVAL = 2000;
setInterval(() => {
  broadcastTrainState();
}, TRAIN_BROADCAST_INTERVAL);

/**
 * Get current train direction based on elapsed time
 * @returns {number} 1 for forward, -1 for backward
 */
function getCurrentTrainDirection() {
  const elapsedTime = Date.now() - TRAIN_START_TIME;
  const cycleCount = Math.floor(elapsedTime / TRAIN_CYCLE_TIME);
  // Direction changes every cycle
  return cycleCount % 2 === 0 ? 1 : -1;
}

/**
 * Calculate train progress (0-1) based on elapsed time
 * @returns {number} Progress value between 0-1
 */
function calculateTrainProgress() {
  const elapsedTime = Date.now() - TRAIN_START_TIME;
  const cycleCount = Math.floor(elapsedTime / TRAIN_CYCLE_TIME);
  const timeInCurrentCycle = elapsedTime % TRAIN_CYCLE_TIME;
  
  // Calculate progress within current cycle (0-1)
  const cycleProgress = timeInCurrentCycle / TRAIN_CYCLE_TIME;
  
  // If even cycle, progress from 0 to 1 (forward)
  // If odd cycle, progress from 1 to 0 (backward)
  return cycleCount % 2 === 0 ? cycleProgress : 1 - cycleProgress;
}

/**
 * Broadcasts the current train state to all connected clients
 */
function broadcastTrainState() {
  // Only broadcast if there are connected players
  if (players.size === 0) return;
  
  // Get current values
  const progress = calculateTrainProgress();
  const direction = getCurrentTrainDirection();
  
  const trainState = {
    type: 'trainState',
    startTime: TRAIN_START_TIME,
    cycleTime: TRAIN_CYCLE_TIME,
    speed: TRAIN_SPEED,
    trackLength: TRAIN_TRACK_LENGTH,
    timestamp: Date.now(),
    // Include current values for debugging
    progress,
    direction
  };
  
  console.log(`Broadcasting train state: startTime=${TRAIN_START_TIME}, progress=${progress.toFixed(4)}, direction=${direction}`);
  broadcastToAll(trainState);
}

/**
 * Sends initial train state when a player connects
 * @param {WebSocket} ws - Player's WebSocket connection
 */
function sendInitialTrainState(ws) {
  if (ws.readyState === WebSocket.OPEN) {
    // Get current values
    const progress = calculateTrainProgress();
    const direction = getCurrentTrainDirection();
    
    const trainStateMsg = {
      type: 'trainInit',
      startTime: TRAIN_START_TIME,
      cycleTime: TRAIN_CYCLE_TIME,
      speed: TRAIN_SPEED,
      trackLength: TRAIN_TRACK_LENGTH,
      trackStart: TRAIN_TRACK_START,
      trackEnd: TRAIN_TRACK_END,
      timestamp: Date.now(),
      // Include current values for debugging
      progress,
      direction
    };
    
    console.log(`Sending initial train state: startTime=${TRAIN_START_TIME}, progress=${progress.toFixed(4)}, direction=${direction}`);
    ws.send(JSON.stringify(trainStateMsg));
  }
}

// Heartbeat to remove stale connections
const HEARTBEAT_INTERVAL = 30000; // 30s
const CONNECTION_TIMEOUT = 60000; // 60s

setInterval(() => {
  const now = Date.now();
  for (const [id, player] of players.entries()) {
    if (now - player.lastActivity > CONNECTION_TIMEOUT) {
      console.log(`Removing stale connection for player ${id}`);
      if (player.ws.readyState === WebSocket.OPEN) {
        player.ws.close(1000, 'Connection timeout');
      }
      cleanupPlayer(id);
    } else if (player.ws.readyState === WebSocket.OPEN) {
      // keep alive
      player.ws.send(JSON.stringify({ type: 'ping' }));
    }
  }
}, HEARTBEAT_INTERVAL);

// Anti-cheat: Run physics update loop
setInterval(updateBullets, GAME_CONSTANTS.PHYSICS_UPDATE_INTERVAL);

// Anti-cheat: Bullet physics update
function updateBullets() {
  const now = Date.now();
  
  // Update each active bullet
  for (const [bulletId, bullet] of activeBullets.entries()) {
    if (!bullet.active) continue;
    
    // Calculate time since last update
    const deltaTime = (now - bullet.timeCreated) / 1000;
    
    // Calculate new position
    const distanceThisFrame = bullet.speed * deltaTime;
    bullet.position.x += bullet.direction.x * distanceThisFrame;
    bullet.position.y += bullet.direction.y * distanceThisFrame;
    bullet.position.z += bullet.direction.z * distanceThisFrame;
    
    // Update total distance traveled
    bullet.distanceTraveled += distanceThisFrame;
    
    // Check if bullet has traveled too far
    if (bullet.distanceTraveled >= bullet.maxDistance) {
      bullet.active = false;
      continue;
    }
  }
  
  // Clean up inactive bullets
  for (const [bulletId, bullet] of activeBullets.entries()) {
    if (!bullet.active) {
      activeBullets.delete(bulletId);
    }
  }
}

// Start server
server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('Server shutting down...');
  
  for (const [id, player] of players.entries()) {
    if (player.ws.readyState === WebSocket.OPEN) {
      player.ws.close(1000, 'Server shutting down');
    }
  }
  server.close(() => {
    console.log('Server shutdown complete.');
    process.exit(0);
  });
});
    </codebase>
</context>
