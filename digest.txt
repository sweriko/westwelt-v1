<goal>
 
</goal>

<output_requirements>
- Don't be lazy, provide thorough, high-quality code.
- Provide complete file contents for any modified or new files.
- Write clean, well-documented code with appropriate error handling.
- Never use ellipsis (...) or placeholder comments, as an excuse to omit code for brewity.
</output_requirements>

<context>
    <codebase>
Directory structure:
└── /./
    ├── index.html
    ├── package.json
    ├── public/
    │   ├── models/
    │   │   └── playermodel.glb
    │   └── textures/
    ├── server/
    │   └── server.js
    ├── src/
    │   ├── ecs/
    │   │   ├── components.ts
    │   │   ├── config.ts
    │   │   ├── scene.ts
    │   │   ├── systems/
    │   │   │   ├── collision.ts
    │   │   │   ├── debugVis.ts
    │   │   │   ├── grass.ts
    │   │   │   ├── healthSystem.ts
    │   │   │   ├── input.ts
    │   │   │   ├── network/
    │   │   │   │   └── client.ts
    │   │   │   ├── physics.ts
    │   │   │   ├── player/
    │   │   │   │   ├── animationStateMachine.ts
    │   │   │   │   ├── animationSystem.ts
    │   │   │   │   ├── controlPanel.ts
    │   │   │   │   ├── fpsBodySystem.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── lookSystem.ts
    │   │   │   │   ├── movementSystem.ts
    │   │   │   │   └── shootSystem.ts
    │   │   │   ├── projectile.ts
    │   │   │   ├── renderSync.ts
    │   │   │   └── timeStep.ts
    │   │   ├── timeUtils.ts
    │   │   ├── utils/
    │   │   │   ├── eventUtils.ts
    │   │   │   └── mathUtils.ts
    │   │   └── world.ts
    │   ├── gameloop.ts
    │   ├── main.ts
    │   └── types/
    ├── tsconfig.json
    └── vite.config.ts

================================================
File: /index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Rapier × Three × bitecs starter</title>
  <style>html,body{margin:0;height:100%;overflow:hidden}</style>
</head>
<body>
  <canvas id="c"></canvas>
  <script type="module" src="/src/main.ts"></script>
</body>
</html>


================================================
File: /package.json
================================================
{
  "name": "rapier-three-bitecs-multiplayer",
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "server": "node server/server.js"
  },
  "dependencies": {
    "@dimforge/rapier3d-compat": "^0.16.1",
    "bitecs": "^0.3.40",
    "three": "^0.176.0",
    "ws": "^8.18.0"
  },
  "devDependencies": {
    "@types/three": "^0.167.2",
    "@types/ws": "^8.5.11",
    "typescript": "^5.5.4",
    "vite": "^5.3.5",
    "vite-plugin-top-level-await": "^1.5.0",
    "vite-plugin-wasm": "^3.4.1"
  }
}


================================================
File: /server/server.js
================================================
import { WebSocketServer } from 'ws';
import * as RAPIER from '@dimforge/rapier3d-compat'; // Import Rapier for server-side logic if needed

console.log("Initializing Rapier on the server...");
await RAPIER.init();
console.log("Rapier initialized.");

const PORT = process.env.PORT || 8080;
const wss = new WebSocketServer({ port: PORT });

const players = new Map(); // playerId -> { ws, state }
let nextPlayerId = 1;

const TICK_RATE = 60; // Send updates 60 times per second
const SERVER_DT = 1 / TICK_RATE;

// --- Server-Side Rapier World (Optional but Recommended for Authority) ---
// If you want authoritative physics, uncomment and configure this.
// For this initial setup, we'll rely more on client state reporting + validation.
/*
const physicsWorld = new RAPIER.World({ x: 0, y: -9.81, z: 0 });
const playerBodies = new Map(); // playerId -> Rapier RigidBody
*/
// --- End Server-Side Physics ---

console.log(`WebSocket server started on port ${PORT}`);

wss.on('connection', (ws) => {
    const playerId = nextPlayerId++;
    console.log(`Player ${playerId} connected.`);

    const initialState = {
        id: playerId,
        position: { x: 0, y: 5, z: 0 }, // Initial spawn position
        rotation: { x: 0, y: 0, z: 0, w: 1 },
        animationState: 0, // e.g., Idle
        health: 100,
        maxHealth: 100,
        lastUpdateTime: Date.now()
    };
    players.set(playerId, { ws, state: initialState });

    // --- Server-Side Physics Body (Optional) ---
    /*
    const playerBodyDesc = RAPIER.RigidBodyDesc.dynamic()
        .setTranslation(initialState.position.x, initialState.position.y, initialState.position.z)
        .setAdditionalMass(1.0); // Give players mass
    const playerBody = physicsWorld.createRigidBody(playerBodyDesc);
    const playerColliderDesc = RAPIER.ColliderDesc.capsule(0.9, 0.3); // Match client collider
    physicsWorld.createCollider(playerColliderDesc, playerBody);
    playerBodies.set(playerId, playerBody);
    */
    // --- End Server-Side Physics Body ---

    // Send init data to the new player
    ws.send(JSON.stringify({
        type: 'init',
        playerId: playerId,
        initialState: initialState,
        // Send state of all other currently connected players
        players: Array.from(players.values())
                       .filter(p => p.state.id !== playerId) // Exclude self
                       .map(p => p.state)
    }));

    // Notify other players about the new player
    broadcast({
        type: 'playerJoined',
        playerState: initialState
    }, ws); // Exclude the new player itself

    ws.on('message', (message) => {
        try {
            const data = JSON.parse(message.toString());
            const player = players.get(playerId);
            if (!player) return;

            player.state.lastUpdateTime = Date.now(); // Keep track of activity

            switch (data.type) {
                case 'playerUpdate':
                    // Basic validation (more can be added)
                    if (isValidState(data.state)) {
                        // Update server state directly for now
                        player.state = { ...player.state, ...data.state };

                        // --- Server-Side Physics Update (Optional) ---
                        /*
                        const body = playerBodies.get(playerId);
                        if (body && data.state.position && data.state.rotation) {
                            // Apply position/rotation updates to the server-side body
                            // Add checks to prevent cheating (e.g., teleporting)
                            body.setTranslation(data.state.position, true);
                            body.setRotation(data.state.rotation, true);
                            // Or apply forces/velocities based on input in data.state
                        }
                        */
                        // --- End Server-Side Physics Update ---

                        // Don't broadcast immediately, wait for server tick
                    } else {
                        console.warn(`Invalid state update received from player ${playerId}`);
                    }
                    break;

                case 'shoot':
                    // Validate shoot request (e.g., cooldown, ammo)
                    console.log(`Player ${playerId} shot`);
                    // Broadcast the shoot event to other players
                    broadcast({
                        type: 'playerShoot',
                        playerId: playerId,
                        position: data.position,
                        direction: data.direction
                    }, ws); // Exclude shooter
                    break;

                case 'playerHit': // Message from shooter reporting they hit someone
                    const targetPlayer = players.get(data.targetId);
                    const sourcePlayer = players.get(playerId);

                    if (targetPlayer && sourcePlayer) {
                        // SERVER-AUTHORITATIVE HIT VALIDATION NEEDED HERE
                        // 1. Raycast from sourcePlayer's validated position/direction
                        // 2. Check distance, line of sight, timing, etc.
                        // 3. If valid, apply damage and broadcast

                        // --- Simplified Hit Processing (Trusting Client - NOT SECURE) ---
                        console.log(`Player ${playerId} reported hitting player ${data.targetId} on zone ${data.hitZone}`);
                        targetPlayer.state.health = Math.max(0, targetPlayer.state.health - data.damage);

                        // Notify the hit player
                        if (targetPlayer.ws.readyState === WebSocket.OPEN) {
                            targetPlayer.ws.send(JSON.stringify({
                                type: 'playerDamaged',
                                sourceId: playerId,
                                damage: data.damage,
                                hitZone: data.hitZone,
                                newHealth: targetPlayer.state.health
                            }));
                        }

                        // Confirm the hit back to the shooter
                        if (sourcePlayer.ws.readyState === WebSocket.OPEN) {
                           sourcePlayer.ws.send(JSON.stringify({
                                type: 'hitConfirmed',
                                targetId: data.targetId,
                                newHealth: targetPlayer.state.health
                           }));
                        }

                         // Broadcast health update for the target player
                        broadcast({
                            type: 'healthUpdate',
                            playerId: data.targetId,
                            health: targetPlayer.state.health
                        });


                        if (targetPlayer.state.health <= 0) {
                            console.log(`Player ${data.targetId} defeated by Player ${playerId}`);
                            // Handle player defeat (e.g., respawn logic)
                             handlePlayerDefeat(data.targetId, playerId);
                        }
                        // --- End Simplified Hit Processing ---
                    }
                    break;

                case 'pong':
                    // Client responded to ping, update last activity time
                    player.state.lastUpdateTime = Date.now();
                    break;

                default:
                    console.log(`Received unknown message type: ${data.type}`);
            }
        } catch (error) {
            console.error(`Failed to process message: ${error}`);
        }
    });

    ws.on('close', () => {
        console.log(`Player ${playerId} disconnected.`);
        const player = players.get(playerId);

        // --- Server-Side Physics Cleanup (Optional) ---
        /*
        const body = playerBodies.get(playerId);
        if (body) {
            physicsWorld.removeRigidBody(body);
            playerBodies.delete(playerId);
        }
        */
        // --- End Server-Side Physics Cleanup ---

        players.delete(playerId);
        broadcast({ type: 'playerLeft', playerId });
    });

    ws.on('error', (error) => {
        console.error(`WebSocket error for player ${playerId}: ${error}`);
        ws.close(); // Force close on error
        // Cleanup is handled by the 'close' event
    });
});

// Basic state validation
function isValidState(state) {
    if (!state) return false;
    // Add more checks: position bounds, rotation validity, etc.
    if (state.position && (isNaN(state.position.x) || isNaN(state.position.y) || isNaN(state.position.z))) return false;
    if (state.rotation && (isNaN(state.rotation.x) || isNaN(state.rotation.y) || isNaN(state.rotation.z) || isNaN(state.rotation.w))) return false;
    if (state.health && (isNaN(state.health) || state.health < 0)) return false; // Health shouldn't be NaN or negative before server processes death
    if (state.animationState && isNaN(state.animationState)) return false;
    return true;
}

// Function to broadcast messages to all connected clients (optionally excluding one)
function broadcast(data, senderWs = null) {
    const message = JSON.stringify(data);
    players.forEach((player) => {
        if (player.ws !== senderWs && player.ws.readyState === WebSocket.OPEN) {
            player.ws.send(message);
        }
    });
}

function handlePlayerDefeat(defeatedPlayerId, killerPlayerId) {
    // Notify everyone about the defeat
    broadcast({ type: 'playerDefeated', defeatedId: defeatedPlayerId, killerId: killerPlayerId });

    // Schedule respawn
    setTimeout(() => {
        const player = players.get(defeatedPlayerId);
        if (player && player.ws.readyState === WebSocket.OPEN) { // Check if player still connected
            // Reset state and assign new spawn position
            const spawnPosition = { x: (Math.random() - 0.5) * 20, y: 5, z: (Math.random() - 0.5) * 20 }; // Example random spawn
            player.state.position = spawnPosition;
            player.state.health = player.state.maxHealth;
            player.state.animationState = 0; // Reset to Idle

            // --- Server-Side Physics Reset (Optional) ---
            /*
            const body = playerBodies.get(defeatedPlayerId);
            if (body) {
                body.setTranslation(spawnPosition, true);
                body.setLinvel({ x: 0, y: 0, z: 0 }, true);
                body.setAngvel({ x: 0, y: 0, z: 0 }, true);
            }
            */
           // --- End Server-Side Physics Reset ---


            console.log(`Player ${defeatedPlayerId} respawning.`);

            // Notify the respawned player
            player.ws.send(JSON.stringify({
                type: 'respawn',
                newState: player.state
            }));

            // Notify others about the respawn (sends the full new state)
             broadcast({
                 type: 'playerRespawned',
                 playerState: player.state
             }, player.ws);

        } else {
             console.log(`Player ${defeatedPlayerId} disconnected before respawn.`);
        }
    }, 3000); // 3-second respawn delay
}

// Server-side game loop for physics and state broadcasting
let lastTickTime = Date.now();
function gameLoop() {
    const now = Date.now();
    const delta = (now - lastTickTime) / 1000; // Delta time in seconds
    lastTickTime = now;

    // --- Server-Side Physics Step (Optional) ---
    // physicsWorld.step();
    // --- End Server-Side Physics Step ---

    // Gather current state of all players
    const worldState = {
        type: 'worldState',
        timestamp: Date.now(),
        players: []
    };

    players.forEach((player, playerId) => {
         // --- Update player state from physics world (Optional) ---
         /*
         const body = playerBodies.get(playerId);
         if (body) {
             const pos = body.translation();
             const rot = body.rotation();
             player.state.position = { x: pos.x, y: pos.y, z: pos.z };
             player.state.rotation = { x: rot.x, y: rot.y, z: rot.z, w: rot.w };
             // You might also derive animationState from velocity here
         }
         */
        // --- End Update from physics ---
        worldState.players.push(player.state);
    });

    // Broadcast the world state to all players
    if (worldState.players.length > 0) {
        broadcast(worldState);
    }

     // Heartbeat / Keep-alive ping
    players.forEach((player) => {
        if (player.ws.readyState === WebSocket.OPEN) {
             if (now - player.state.lastUpdateTime > 10000) { // Check for inactivity (e.g., 10 seconds)
                 player.ws.ping(); // Send WebSocket ping
             }
        }
    });

}

setInterval(gameLoop, 1000 / TICK_RATE); // Run game loop at TICK_RATE Hz

// Basic keep-alive/timeout check
setInterval(() => {
    const now = Date.now();
    players.forEach((player, playerId) => {
        if (now - player.state.lastUpdateTime > 30000) { // 30 seconds timeout
            console.log(`Player ${playerId} timed out.`);
            player.ws.terminate(); // Force close connection
            // Cleanup is handled by the 'close' event
        }
    });
}, 10000); // Check every 10 seconds

================================================
File: /src/ecs/components.ts
================================================
import { Types, defineComponent } from 'bitecs';

/** World-space transform (pos-quat - Standardized order) */
export const Transform = defineComponent({
  x: Types.f32, y: Types.f32, z: Types.f32,
  qx: Types.f32, qy: Types.f32, qz: Types.f32, qw: Types.f32
});

/** Linear velocity – used for projectiles & potentially network prediction */
export const Velocity = defineComponent({ x: Types.f32, y: Types.f32, z: Types.f32 });

/** TTL in milliseconds (bullets) */
export const Lifespan = defineComponent({ ttl: Types.f32, born: Types.f32 });

/** Debug visualization flag - used to store current debug state */
export const DebugVis = defineComponent({ active: Types.ui8 });

/** First-person controller state (Local Player Only) */
export const FPController = defineComponent({
  pitch: Types.f32,        // Camera pitch angle
  vertVel: Types.f32,      // Vertical velocity
  moveState: Types.ui8,    // 0=Grounded, 1=Jumping, 2=Falling
  lastGrounded: Types.f32, // Time when last grounded
  lastJump: Types.f32,     // Time when last jumped
  lastShot: Types.f32,     // Time when last shot
  jumpRequested: Types.ui8,// Jump buffer flag
  lastJumpRequest: Types.f32 // Time when jump was requested
});

/** Debug visualization mesh references */
export const DebugMeshRef = defineComponent({ id: Types.ui32 });

/** Trajectory for debug visualization */
export const Trajectory = defineComponent({
  // No data needed, just a tag to indicate an entity has a trajectory
});

/** Collision event data */
export const CollisionEvent = defineComponent({
  entity1: Types.ui32,     // First entity in collision
  entity2: Types.ui32,     // Second entity in collision
  impulse: Types.f32,      // Collision impulse magnitude
  time: Types.f32          // When collision occurred
});

/** Foreign-object indirection – store handles in JS Maps */
export const RigidBodyRef = defineComponent({ id: Types.ui32 });
export const MeshRef      = defineComponent({ id: Types.ui32 });

/** Tags */
// Player tag is now split into LocalPlayer and RemotePlayer
export const Player = defineComponent();
export const Projectile = defineComponent();
export const CubeTag    = defineComponent();

// --- New Multiplayer Components ---

/** Identifies the local player entity */
export const LocalPlayer = defineComponent();

/** Identifies a remote player entity */
export const RemotePlayer = defineComponent();

/** Stores the server-assigned network ID */
export const NetworkId = defineComponent({ id: Types.ui32 });

/** Stores player health */
export const Health = defineComponent({
  current: Types.f32,
  max: Types.f32
});

/** Stores the current animation state (enum defined elsewhere) */
export const AnimationState = defineComponent({ state: Types.ui8 });

/** Stores target network state for interpolation */
export const InterpolationTarget = defineComponent({
  targetX: Types.f32, targetY: Types.f32, targetZ: Types.f32,
  targetQX: Types.f32, targetQY: Types.f32, targetQZ: Types.f32, targetQW: Types.f32,
  timestamp: Types.f32 // Timestamp of the target state from the server
});

================================================
File: /src/ecs/config.ts
================================================
/**
 * Global configuration values
 */

export const PlayerConfig = {
  // Movement
  WALK_SPEED: 8,
  SPRINT_FACTOR: 1.8,
  AIR_CONTROL: 0.7,
  JUMP_VEL: 14,
  GRAVITY: 20,
  TERMINAL_FALL: -20,

  // Timing
  JUMP_CD_MS: 300,
  COYOTE_MS: 150,
  JUMP_BUFFER_MS: 200,

  // Look
  MOUSE_SENSITIVITY: 0.0035,

  // Health
  MAX_HEALTH: 100
};

export const WeaponConfig = {
  // Add this back for the player system
  SHOOT_CD_MS: 200, 
  BULLET_SPEED: 40,
  BULLET_TTL_MS: 5000, // Used for visual effect lifetime
  BULLET_SPAWN_DISTANCE: 1.5,
  // Added example damage values (server should determine actual damage)
  DAMAGE_BODY: 30,
  DAMAGE_HEAD: 100,
  DAMAGE_LIMB: 15
};

export const PhysicsConfig = {
  IMPACT_FORCE: 20.0,
  SOLVER_ITERATIONS: 4,
  CCD_SUBSTEPS: 4,
  VELOCITY_THRESHOLD: 30.0
};

export const TimeStepConfig = {
  FIXED_DT: 1/60,
  MAX_STEPS: 5,
  MAX_FRAME_TIME: 0.25,
  MIN_DT: 1/240
};

export const SceneConfig = {
  GROUND_COLOR: 0x1a5f2a,
  GROUND_SIZE: 200,
  SKY_COLOR: 0x87CEEB,
  CUBE_STACK_SIZE: 6,
  EXTRA_CUBES: 20,
  CUBE_RESTITUTION: 0.4,
  CUBE_FRICTION: 0.5,
  AMBIENT_LIGHT_INTENSITY: 0.8,
  DIRECTIONAL_LIGHT_INTENSITY: 1.0
};

// Movement state enum values
export const MovementState = {
  GROUNDED: 0,
  JUMPING: 1,
  FALLING: 2
};

// Animation state enum values
export const PlayerAnimationState = {
  // Basic states
  IDLE: 0,
  WALKING: 1,
  RUNNING: 2,
  JUMPING: 3,
  FALLING: 4,
  
  // Combat states
  SHOOTING: 5, 
  AIMING: 6,   
  RELOAD: 7,
  
  // Movement states
  CROUCH_IDLE: 8,
  CROUCH_WALK: 9,
  CROUCH_RUN: 10,
  SPRINT: 11,
  
  // Special states
  DEATH: 12,
  HIT_REACTION: 13,
  INSPECT_WEAPON: 14
};

// Animation transition timing map (in seconds)
export const AnimationTransitions = {
  // Default transition time between states
  DEFAULT: 0.2,
  
  // Specific state transitions that need custom timing
  [PlayerAnimationState.IDLE + "_to_" + PlayerAnimationState.WALKING]: 0.3,
  [PlayerAnimationState.RUNNING + "_to_" + PlayerAnimationState.IDLE]: 0.5,
  [PlayerAnimationState.JUMPING + "_to_" + PlayerAnimationState.FALLING]: 0.1,
  [PlayerAnimationState.AIMING + "_to_" + PlayerAnimationState.SHOOTING]: 0.05
};

// Network configuration
export const NetworkConfig = {
    SERVER_URL: `ws://${window.location.hostname}:8080`, // Adjust hostname/port if needed
    UPDATE_INTERVAL_MS: 50, // Send local player updates 20 times per second
    INTERPOLATION_DELAY_MS: 100, // Delay applied to remote player interpolation
    PING_INTERVAL_MS: 5000 // Send ping every 5 seconds
};

================================================
File: /src/ecs/scene.ts
================================================
/**********************************************************************
 * scene.ts – Three + Rapier initialisation & scene population
 *********************************************************************/
import * as THREE  from 'three';
import { addComponent, addEntity } from 'bitecs';
import {
  CubeTag, MeshRef, RigidBodyRef, Transform
} from './components';
import { ECS, ECSContext } from './world';
import { SceneConfig } from './config';

/* ------------------------------------------------------------------ */
/* createContext – bootstrap renderer / physics / camera              */
export async function createContext(
  canvas: HTMLCanvasElement,
  RAPIER: typeof import('@dimforge/rapier3d-compat')
): Promise<ECSContext> {
  /* Rapier ---------------------------------------------------------- */
  const rapier = RAPIER;
  const physics = new rapier.World({ x: 0, y: -9.81, z: 0 });

  /* Three renderer -------------------------------------------------- */
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type    = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(SceneConfig.SKY_COLOR);
  scene.fog        = new THREE.FogExp2(0x88BBFF, 0.0025);

  const camera = new THREE.PerspectiveCamera(
    75, window.innerWidth / window.innerHeight, 0.1, 1000
  );

  // Set up window resize handler
  setupWindowResize(camera, renderer);

  // Create context object
  const ctx: ECSContext = {
    rapier, physics,
    three: { scene, camera, renderer },
    maps : { mesh: new Map(), rb: new Map() }
  };

  // Set up lighting, sky and ground
  setupLighting(ctx);
  setupSky(ctx);
  setupGround(ctx);

  return ctx;
}

/* ------------------------------------------------------------------ */
/* Helper function to set up window resize handling                   */
function setupWindowResize(camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer) {
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

/* ------------------------------------------------------------------ */
/* Helper function to set up scene lighting                           */
function setupLighting(ctx: ECSContext) {
  const scene = ctx.three.scene;
  
  // Add ambient light
  scene.add(new THREE.AmbientLight(
    0xffffff, SceneConfig.AMBIENT_LIGHT_INTENSITY
  ));

  // Add directional light with shadows
  const dirLight = new THREE.DirectionalLight(
    0xffffff, SceneConfig.DIRECTIONAL_LIGHT_INTENSITY
  );
  dirLight.position.set(5, 10, 7);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.set(2048, 2048);
  dirLight.shadow.camera.left = -20;
  dirLight.shadow.camera.right = 20;
  dirLight.shadow.camera.top = 20;
  dirLight.shadow.camera.bottom = -20;
  dirLight.shadow.camera.near = 0.5;
  dirLight.shadow.camera.far  = 50;
  scene.add(dirLight);
}

/* ------------------------------------------------------------------ */
/* Helper function to create sky dome                                 */
function setupSky(ctx: ECSContext) {
  const scene = ctx.three.scene;
  const sky = new THREE.SphereGeometry(400, 32, 15).scale(-1, 1, 1);
  scene.add(new THREE.Mesh(
    sky, 
    new THREE.MeshBasicMaterial({ 
      color: SceneConfig.SKY_COLOR, 
      side: THREE.BackSide 
    })
  ));
}

/* ------------------------------------------------------------------ */
/* Helper function to create ground plane                             */
function setupGround(ctx: ECSContext) {
  const scene = ctx.three.scene;
  const { rapier, physics } = ctx;
  
  const HALF_H = 0.05;                 // 0.1 m thick collider
  const GROUND_Y = -HALF_H;
  const SIZE = SceneConfig.GROUND_SIZE;

  // Create ground mesh
  const groundMesh = new THREE.Mesh(
    new THREE.PlaneGeometry(SIZE, SIZE).rotateX(-Math.PI / 2),
    new THREE.MeshStandardMaterial({ 
      color: SceneConfig.GROUND_COLOR, 
      roughness: 0.8, 
      metalness: 0.2 
    })
  );
  groundMesh.receiveShadow = true;
  groundMesh.position.y    = GROUND_Y;
  scene.add(groundMesh);

  // Create ground collider
  const groundBody = physics.createRigidBody(
    rapier.RigidBodyDesc.fixed().setTranslation(0, GROUND_Y, 0)
  );
  physics.createCollider(
    rapier.ColliderDesc.cuboid(SIZE/2, HALF_H, SIZE/2), groundBody
  );
}

/* ------------------------------------------------------------------ */
/* populateScene – central cube stack + scattered cubes               */
export function populateScene(world: ECS, ctx: ECSContext): void {
  const { rapier, physics, maps, three } = ctx;
  
  // Create shared geometry and materials for cube factory
  const geometries = new Map<number, THREE.BoxGeometry>();
  const materials = new Map<number, THREE.MeshStandardMaterial>();
  
  // Cube factory function with reused geometries/materials
  const makeCube = (
    x: number, y: number, z: number,
    size = 1, color = Math.random() * 0xffffff
  ) => {
    /* Three mesh ---------------------------------------------------- */
    // Reuse or create geometry
    if (!geometries.has(size)) {
      geometries.set(size, new THREE.BoxGeometry(size, size, size));
    }
    
    // Reuse material if same color (within tolerance) or create new
    let material: THREE.MeshStandardMaterial | undefined;
    for (const [existingColor, existingMaterial] of materials.entries()) {
      // Allow for small color differences (hex representation)
      if (Math.abs(existingColor - color) < 100) {
        material = existingMaterial;
        break;
      }
    }
    
    if (!material) {
      material = new THREE.MeshStandardMaterial({ 
        color, 
        roughness: 0.7, 
        metalness: 0.3 
      });
      materials.set(color, material);
    }
    
    const mesh = new THREE.Mesh(geometries.get(size)!, material);
    mesh.castShadow = mesh.receiveShadow = true;
    mesh.position.set(x, y, z);
    three.scene.add(mesh);

    /* Rapier body --------------------------------------------------- */
    const rb = physics.createRigidBody(
      rapier.RigidBodyDesc.dynamic()
            .setTranslation(x, y, z)
            .setCcdEnabled(true)
    );
    physics.createCollider(
      rapier.ColliderDesc.cuboid((size * 0.98) / 2, (size * 0.98) / 2, (size * 0.98) / 2)
            .setRestitution(SceneConfig.CUBE_RESTITUTION)
            .setFriction(SceneConfig.CUBE_FRICTION),
      rb
    );

    /* ECS entity ---------------------------------------------------- */
    const eid = addEntity(world);
    addComponent(world, CubeTag,     eid);
    addComponent(world, Transform,   eid);
    addComponent(world, MeshRef,     eid);
    addComponent(world, RigidBodyRef,eid);

    maps.mesh.set(eid, mesh);
    maps.rb.set(eid, rb);
    RigidBodyRef.id[eid] = rb.handle;
    
    // Update handle map
    if (world.ctx.entityHandleMap) {
      world.ctx.entityHandleMap.set(rb.handle, eid);
    }
  };

  /* Create cube stacks */
  const stackSize = SceneConfig.CUBE_STACK_SIZE;
  const halfStack = stackSize / 2;
  
  // Make a cube stack
  for (let y = 0; y < stackSize; ++y)
    for (let x = 0; x < stackSize; ++x)
      for (let z = 0; z < stackSize; ++z)
        makeCube(x - halfStack, y + 0.5, z - halfStack);

  /* extra cubes */
  for (let i = 0; i < SceneConfig.EXTRA_CUBES; i++)
    makeCube(
      (Math.random() - 0.5) * 20,
      10 + Math.random() * 10,
      (Math.random() - 0.5) * 20,
      0.5 + Math.random() * 1.5
    );
}


================================================
File: /src/ecs/systems/collision.ts
================================================
import { defineQuery, addComponent, addEntity, hasComponent } from 'bitecs';
import { Projectile, CubeTag, RigidBodyRef, CollisionEvent, Health, LocalPlayer, NetworkId } from '../components';
import { ECS } from '../world';
import { vec3Pool, createEntityPairKey } from '../utils/mathUtils';
import { PhysicsConfig, WeaponConfig } from '../config';
import { network } from './network/client';

export function initCollisionSystem(world: ECS) {
  // Queries for finding entities
  const projectileQuery = defineQuery([Projectile, RigidBodyRef]);
  const cubeQuery = defineQuery([CubeTag, RigidBodyRef]);
  const localPlayerQuery = defineQuery([LocalPlayer]);
  
  // Processed collisions cache to avoid duplicates
  const processedCollisions = new Map<bigint, number>();

  // Initialize entity handle mapping if not done already
  if (!world.ctx.entityHandleMap) {
    world.ctx.entityHandleMap = new Map<number, number>();
  }

  // Helper function to mark entities for deletion
  function markEntityForDeletion(w: ECS, eid: number) {
    const mesh = w.ctx.maps.mesh.get(eid);
    if (mesh) {
      if (!mesh.userData) mesh.userData = {};
      mesh.userData.markedForDeletion = true;
    }
  }

  return (w: ECS) => {
    const now = performance.now();

    // Clean up old processed collisions
    for (const [key, time] of processedCollisions.entries()) {
      if (now - time > 200) {
        processedCollisions.delete(key);
      }
    }

    // Skip if event queue not available
    if (!w.ctx.eventQueue) {
      return w;
    }

    // Update entity handle map for projectiles and cubes
    // This helps translate Rapier body handles to our ECS entity IDs
    for (const eid of projectileQuery(w)) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb && !w.ctx.entityHandleMap!.has(rb.handle)) {
        w.ctx.entityHandleMap!.set(rb.handle, eid);
      }
    }
    
    for (const eid of cubeQuery(w)) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb && !w.ctx.entityHandleMap!.has(rb.handle)) {
        w.ctx.entityHandleMap!.set(rb.handle, eid);
      }
    }

    // Process collision events from Rapier physics
    w.ctx.eventQueue.drainCollisionEvents((handle1: number, handle2: number, started: boolean) => {
      if (!started) return; // Only care about collision starts

      // Get entity IDs from rigid body handles
      const entity1 = w.ctx.entityHandleMap!.get(handle1);
      const entity2 = w.ctx.entityHandleMap!.get(handle2);

      if (!entity1 || !entity2) return;

      // Check entity types
      const isProjectile1 = hasComponent(w, Projectile, entity1);
      const isProjectile2 = hasComponent(w, Projectile, entity2);
      const isCube1 = hasComponent(w, CubeTag, entity1);
      const isCube2 = hasComponent(w, CubeTag, entity2);
      const isLocalPlayer1 = hasComponent(w, LocalPlayer, entity1);
      const isLocalPlayer2 = hasComponent(w, LocalPlayer, entity2);
      
      // --- Collision: Projectile <-> Cube ---
      if ((isProjectile1 && isCube2) || (isProjectile2 && isCube1)) {
        const projectileEid = isProjectile1 ? entity1 : entity2;
        const cubeEid = isCube1 ? entity1 : entity2;

        // Create a unique collision ID to prevent duplicate processing
        const collisionId = createEntityPairKey(projectileEid, cubeEid);
        if (processedCollisions.has(collisionId)) return;
        processedCollisions.set(collisionId, now);

        // Get the rigid bodies
        const cubeRB = w.ctx.maps.rb.get(cubeEid);
        const projectileRB = w.ctx.maps.rb.get(projectileEid);
        if (!cubeRB || !projectileRB) return;

        // Apply impulse to cube
        const bulletPos = projectileRB.translation();
        const cubePos = cubeRB.translation();
        
        // Calculate impact direction
        const impactDir = vec3Pool.get().set(
          cubePos.x - bulletPos.x, 
          cubePos.y - bulletPos.y, 
          cubePos.z - bulletPos.z
        ).normalize();
        
        // If direction is zero (direct center hit), use reversed bullet velocity
        if (impactDir.lengthSq() < 0.001) {
          const vel = projectileRB.linvel();
          impactDir.set(-vel.x, -vel.y, -vel.z).normalize();
        }
        
        // Apply impulse at impact point
        cubeRB.applyImpulseAtPoint(
          { 
            x: impactDir.x * PhysicsConfig.IMPACT_FORCE, 
            y: impactDir.y * PhysicsConfig.IMPACT_FORCE, 
            z: impactDir.z * PhysicsConfig.IMPACT_FORCE 
          },
          bulletPos,
          true
        );
        
        // Apply random torque for more natural movement
        cubeRB.applyTorqueImpulse(
          { 
            x: (Math.random() - 0.5) * PhysicsConfig.IMPACT_FORCE * 0.3, 
            y: (Math.random() - 0.5) * PhysicsConfig.IMPACT_FORCE * 0.3, 
            z: (Math.random() - 0.5) * PhysicsConfig.IMPACT_FORCE * 0.3 
          }, 
          true
        );

        // Mark projectile for deletion
        markEntityForDeletion(w, projectileEid);
        vec3Pool.release(impactDir);
        return; // Processed this collision
      }

      // --- Collision: Projectile <-> LocalPlayer ---
      // This should only happen with OTHER players' projectiles hitting the local player
      // The server is authoritative, but we can use this to provide immediate visual feedback
      if ((isProjectile1 && isLocalPlayer2) || (isProjectile2 && isLocalPlayer1)) {
        const projectileEid = isProjectile1 ? entity1 : entity2;
        const playerEid = isLocalPlayer1 ? entity1 : entity2;

        // Create a unique collision ID to prevent duplicate processing
        const collisionId = createEntityPairKey(projectileEid, playerEid);
        if (processedCollisions.has(collisionId)) return;
        processedCollisions.set(collisionId, now);

        console.log(`Local impact detected: projectile ${projectileEid} hit local player ${playerEid}`);
        
        // Mark projectile for deletion (visual feedback)
        markEntityForDeletion(w, projectileEid);
        
        // Server will determine actual damage via hit event,
        // but we can trigger immediate local feedback if desired:
        // For example, play hit sound, flash screen, etc.
        
        return; // Processed this collision
      }
    });

    return w;
  };
}

================================================
File: /src/ecs/systems/debugVis.ts
================================================
import { defineQuery } from 'bitecs';
import { DebugVis, Projectile, LocalPlayer, RemotePlayer, RigidBodyRef } from '../components';
import { ECS } from '../world';
import * as THREE from 'three';
import { vec3Pool } from '../utils/mathUtils';

// Maximum number of points in trajectory
const MAX_TRAJECTORY_POINTS = 100;

export function initDebugVisSystem(world: ECS) {
  const debugQuery = defineQuery([DebugVis]);
  const playerQuery = defineQuery([LocalPlayer, RigidBodyRef]);
  const projectileQuery = defineQuery([Projectile, RigidBodyRef]);
  
  // Store trajectory data
  const trajectoryLines = new Map<number, THREE.Line>();
  const trajectories = new Map<number, {
    count: number,  // Current number of points
    maxCount: number  // Maximum capacity
  }>();
  
  // Store pre-allocated buffers to avoid creating new ones each frame
  const positionBuffers = new Map<number, {
    array: Float32Array,
    attribute: THREE.BufferAttribute
  }>();
  
  // Shared line material for all trajectories
  const lineMaterial = new THREE.LineBasicMaterial({ 
    color: 0xff9900, 
    transparent: true, 
    opacity: 0.7 
  });
  
  // Create player capsule mesh for debug
  let playerCapsule: THREE.Mesh | null = null;
  
  // Create a simple cylinder geometry
  const createCylinderGeometry = (radius: number, height: number, widthSegments = 16): THREE.BufferGeometry => {
    // Create cylinder body
    return new THREE.CylinderGeometry(
      radius, radius, height - radius * 2, widthSegments, 1, true
    );
  };
  
  // Initialize the debug capsule and materials
  const wireframeMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    wireframe: true,
    transparent: true,
    opacity: 0.7
  });
  
  // Create the capsule mesh once at initialization
  const capsuleGeometry = createCylinderGeometry(0.3, 1.8, 16);
  playerCapsule = new THREE.Mesh(capsuleGeometry, wireframeMaterial);
  world.ctx.three.scene.add(playerCapsule);
  playerCapsule.visible = false; // Hidden by default
  
  return (w: ECS) => {
    // First check if debug visualization is enabled
    const debugEnts = debugQuery(w);
    const debugId = debugEnts.length > 0 ? debugEnts[0] : -1;
    const debugActive = debugId !== -1 && DebugVis.active[debugId] === 1;
    
    // Update player capsule visibility and position
    if (playerCapsule) {
      playerCapsule.visible = debugActive;
      
      // Update position if visible
      if (debugActive) {
        const playerEnts = playerQuery(w);
        if (playerEnts.length > 0) {
          const playerEid = playerEnts[0];
          const playerObj = w.ctx.maps.mesh.get(playerEid);
          if (playerObj) {
            playerCapsule.position.copy(playerObj.position);
            playerCapsule.position.y -= 0.3; // Adjust to match center of capsule
            playerCapsule.rotation.y = playerObj.rotation.y;
          }
        }
      }
    }
    
    // Update projectile trajectories
    for (const projectileEid of projectileQuery(w)) {
      // Get current position for this projectile
      const rb = w.ctx.maps.rb.get(projectileEid);
      if (!rb) continue;
      
      // Get position and add to trajectory
      const pos = rb.translation();
      const currentPos = vec3Pool.get().set(pos.x, pos.y, pos.z);
      
      // Initialize trajectory and buffer if needed
      if (!trajectories.has(projectileEid)) {
        // Create trajectory tracking object
        trajectories.set(projectileEid, {
          count: 0,
          maxCount: MAX_TRAJECTORY_POINTS
        });
        
        // Pre-allocate the Float32Array with maximum size
        const posArray = new Float32Array(MAX_TRAJECTORY_POINTS * 3);
        const posAttribute = new THREE.BufferAttribute(posArray, 3);
        positionBuffers.set(projectileEid, {
          array: posArray,
          attribute: posAttribute
        });
      }
      
      // Get the trajectory data
      const trajectory = trajectories.get(projectileEid)!;
      // Get the buffer
      const buffer = positionBuffers.get(projectileEid)!;
      
      // Add current position directly to the buffer
      if (trajectory.count < MAX_TRAJECTORY_POINTS) {
        // We have room, add at the end
        const idx = trajectory.count * 3;
        buffer.array[idx] = currentPos.x;
        buffer.array[idx + 1] = currentPos.y;
        buffer.array[idx + 2] = currentPos.z;
        trajectory.count++;
      } else {
        // Shift all points one position back using copyWithin (much faster than loop)
        buffer.array.copyWithin(0, 3);
        
        // Add new point at the end
        const idx = (trajectory.count - 1) * 3;
        buffer.array[idx] = currentPos.x;
        buffer.array[idx + 1] = currentPos.y;
        buffer.array[idx + 2] = currentPos.z;
      }
      
      // Mark buffer for update
      buffer.attribute.needsUpdate = true;
      
      // Release the pooled vector
      vec3Pool.release(currentPos);
      
      // Only update/show trajectory lines if debug is active
      if (debugActive) {
        if (trajectoryLines.has(projectileEid)) {
          // Update existing line - reuse the geometry
          const line = trajectoryLines.get(projectileEid)!;
          line.visible = true;
          
          // Get the pre-allocated buffer and update it
          const buffer = positionBuffers.get(projectileEid)!;
          
          // Update geometry to draw only the current points
          line.geometry.setDrawRange(0, trajectory.count);
          buffer.attribute.needsUpdate = true;
        } else {
          // Create new line with dynamic buffer geometry
          const geometry = new THREE.BufferGeometry();
          const buffer = positionBuffers.get(projectileEid)!;
          
          // Add attribute to geometry
          geometry.setAttribute('position', buffer.attribute);
          
          // Set initial draw range
          geometry.setDrawRange(0, trajectory.count);
          
          // Use the shared material
          const line = new THREE.Line(geometry, lineMaterial);
          trajectoryLines.set(projectileEid, line);
          w.ctx.three.scene.add(line);
        }
      } else {
        // Hide lines if debug is disabled
        if (trajectoryLines.has(projectileEid)) {
          trajectoryLines.get(projectileEid)!.visible = false;
        }
      }
    }
    
    // Clean up trajectories for removed projectiles
    for (const [eid, line] of trajectoryLines.entries()) {
      const projectileExists = projectileQuery(w).includes(eid);
      
      // Check if projectile is marked for deletion
      const mesh = w.ctx.maps.mesh.get(eid);
      const markedForDeletion = mesh?.userData?.markedForDeletion === true;
      
      if (!projectileExists || markedForDeletion) {
        // Remove the trajectory line
        w.ctx.three.scene.remove(line);
        line.geometry.dispose();
        if (line.material instanceof THREE.Material) {
          line.material.dispose();
        } else if (Array.isArray(line.material)) {
          line.material.forEach(mat => mat.dispose());
        }
        trajectoryLines.delete(eid);
        trajectories.delete(eid);
        positionBuffers.delete(eid);
      }
    }
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/grass.ts
================================================
import * as THREE from 'three';
import { ECS } from '../world';
import { defineQuery, enterQuery, exitQuery } from 'bitecs';
import { CubeTag, Transform } from '../components';

// Custom shader material class for grass
class ShaderManager {
  private static instance: ShaderManager;
  private shaderCache: Record<string, { vertex: string, fragment: string }> = {};
  
  private constructor() {
    this.initShaders();
  }

  public static getInstance(): ShaderManager {
    if (!ShaderManager.instance) {
      ShaderManager.instance = new ShaderManager();
    }
    return ShaderManager.instance;
  }

  private initShaders(): void {
    // Define grass shader
    const grassVertexShader = `
      uniform vec2 grassSize;
      uniform vec4 grassParams;
      uniform vec4 grassDraw;
      uniform float time;
      uniform vec3 playerPos;
      uniform mat4 viewMatrixInverse;

      attribute float vertIndex;

      varying vec4 vGrassParams;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      varying vec2 vUv;

      // Math utility functions
      float saturate(float x) {
        return clamp(x, 0.0, 1.0);
      }

      float linearstep(float minValue, float maxValue, float v) {
        return clamp((v - minValue) / (maxValue - minValue), 0.0, 1.0);
      }

      float easeOut(float x, float t) {
        return 1.0 - pow(1.0 - x, t);
      }

      float easeIn(float x, float t) {
        return pow(x, t);
      }

      // Hash functions
      vec2 hash22(vec2 p) {
        p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
        return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
      }

      vec4 hash42(vec2 p) {
        vec4 p4 = fract(vec4(p.xyxy) * vec4(0.1031, 0.1030, 0.0973, 0.1099));
        p4 += dot(p4, p4.wzxy + 33.33);
        return fract((p4.xxyz + p4.yzzw) * p4.zywx) * 2.0 - 1.0;
      }

      // Noise function for wind
      float noise12(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        
        // Smooth interpolation
        vec2 u = f * f * (3.0 - 2.0 * f);
        
        // Hash corners
        float a = dot(hash22(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));
        float b = dot(hash22(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));
        float c = dot(hash22(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));
        float d = dot(hash22(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));
        
        // Mix
        return mix(mix(a, b, u.x), mix(c, d, u.x), u.y) * 0.5 + 0.5;
      }

      // Matrix utility functions
      mat3 rotateX(float theta) {
        float c = cos(theta);
        float s = sin(theta);
        return mat3(
          vec3(1.0, 0.0, 0.0),
          vec3(0.0, c, -s),
          vec3(0.0, s, c)
        );
      }

      mat3 rotateY(float theta) {
        float c = cos(theta);
        float s = sin(theta);
        return mat3(
          vec3(c, 0.0, s),
          vec3(0.0, 1.0, 0.0),
          vec3(-s, 0.0, c)
        );
      }

      mat3 rotateAxis(vec3 axis, float angle) {
        axis = normalize(axis);
        float s = sin(angle);
        float c = cos(angle);
        float oc = 1.0 - c;
        
        return mat3(
          oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
          oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
          oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c
        );
      }

      void main() {
        vec3 grassOffset = vec3(position.x, 0.0, position.y);

        // Blade world position
        vec3 grassBladeWorldPos = (modelMatrix * vec4(grassOffset, 1.0)).xyz;
        float heightmapSample = 0.0;
        float heightmapSampleHeight = 1.0;

        vec4 hashVal1 = hash42(vec2(grassBladeWorldPos.x, grassBladeWorldPos.z));

        float highLODOut = smoothstep(grassDraw.x * 0.5, grassDraw.x, distance(cameraPosition, grassBladeWorldPos));
        float lodFadeIn = smoothstep(grassDraw.x, grassDraw.y, distance(cameraPosition, grassBladeWorldPos));

        // Check terrain type
        float isSandy = 0.0;
        float grassAllowedHash = hashVal1.w - isSandy;
        float isGrassAllowed = step(0.0, grassAllowedHash);

        float randomAngle = hashVal1.x * 2.0 * 3.14159;
        float randomShade = clamp(hashVal1.y * 0.5 + 0.5, 0.5, 1.0);
        float randomHeight = mix(0.75, 1.5, hashVal1.z * 0.5 + 0.5) * mix(1.0, 0.0, lodFadeIn) * isGrassAllowed * heightmapSampleHeight;
        float randomWidth = (1.0 - isSandy) * heightmapSampleHeight;
        float randomLean = mix(0.1, 0.4, hashVal1.w * 0.5 + 0.5);

        vec2 hashGrassColour = hash22(vec2(grassBladeWorldPos.x, grassBladeWorldPos.z)) * 0.5 + 0.5;
        float leanAnimation = (noise12(vec2(time * 0.35) + grassBladeWorldPos.xz * 137.423) * 2.0 - 1.0) * 0.1;

        float GRASS_SEGMENTS = grassParams.x;
        float GRASS_VERTICES = grassParams.y;

        // Figure out vertex id
        float vertID = mod(float(vertIndex), GRASS_VERTICES);

        // 1 = front, -1 = back
        float zSide = -(floor(vertIndex / GRASS_VERTICES) * 2.0 - 1.0);

        // 0 = left, 1 = right
        float xSide = mod(vertID, 2.0);

        float heightPercent = (vertID - xSide) / (GRASS_SEGMENTS * 2.0);

        // Select grass blade variation (0-4 for 5 variations)
        float bladeVariation = floor(hashVal1.x * 5.0);

        float grassTotalHeight = grassSize.y * randomHeight;
        float grassTotalWidthHigh = easeOut(1.0 - heightPercent, 2.0);
        float grassTotalWidthLow = 1.0 - heightPercent;
        float grassTotalWidth = grassSize.x * mix(grassTotalWidthHigh, grassTotalWidthLow, highLODOut) * randomWidth;

        // Shift verts
        float x = (xSide - 0.5) * grassTotalWidth;
        float y = heightPercent * grassTotalHeight;

        float windDir = noise12(grassBladeWorldPos.xz * 0.05 + 0.05 * time) * 6.28318;
        float windNoiseSample = noise12(grassBladeWorldPos.xz * 0.25 + time * 1.0) * 2.0 - 1.0;
        float windLeanAngle = mix(0.25, 1.0, clamp(windNoiseSample * 0.5 + 0.5, 0.0, 1.0));
        windLeanAngle = easeIn(windLeanAngle, 2.0) * 1.25;
        vec3 windAxis = vec3(cos(windDir), 0.0, sin(windDir));

        windLeanAngle *= heightPercent;

        float distToPlayer = distance(grassBladeWorldPos.xz, playerPos.xz);
        float playerFalloff = smoothstep(2.5, 1.0, distToPlayer);
        float playerLeanAngle = mix(0.0, 0.2, playerFalloff * linearstep(0.5, 0.0, windLeanAngle));
        vec3 grassToPlayer = normalize(vec3(playerPos.x, 0.0, playerPos.z) - vec3(grassBladeWorldPos.x, 0.0, grassBladeWorldPos.z));
        vec3 playerLeanAxis = vec3(grassToPlayer.z, 0, -grassToPlayer.x);

        randomLean += leanAnimation;

        float easedHeight = mix(easeIn(heightPercent, 2.0), 1.0, highLODOut);
        float curveAmount = -randomLean * easedHeight;

        float ncurve1 = -randomLean * easedHeight;
        vec3 n1 = vec3(0.0, (heightPercent + 0.01), 0.0);
        n1 = rotateX(ncurve1) * n1;

        float ncurve2 = -randomLean * easedHeight * 0.9;
        vec3 n2 = vec3(0.0, (heightPercent + 0.01) * 0.9, 0.0);
        n2 = rotateX(ncurve2) * n2;

        vec3 ncurve = normalize(n1 - n2);

        mat3 grassMat = rotateAxis(playerLeanAxis, playerLeanAngle) * rotateAxis(windAxis, windLeanAngle) * rotateY(randomAngle);

        vec3 grassFaceNormal = vec3(0.0, 0.0, 1.0);
        grassFaceNormal = grassMat * grassFaceNormal;
        grassFaceNormal *= zSide;

        vec3 grassVertexNormal = vec3(0.0, -ncurve.z, ncurve.y);
        vec3 grassVertexNormal1 = rotateY(3.14159 * 0.3 * zSide) * grassVertexNormal;

        grassVertexNormal1 = grassMat * grassVertexNormal1;
        grassVertexNormal1 *= zSide;

        vec3 grassVertexPosition = vec3(x, y, 0.0);
        grassVertexPosition = rotateX(curveAmount) * grassVertexPosition;
        grassVertexPosition = grassMat * grassVertexPosition;

        grassVertexPosition += grassOffset;

        vGrassParams = vec4(heightPercent, grassBladeWorldPos.y, highLODOut, xSide);
        
        const float SKY_RATIO = 0.15;
        vec3 UP = vec3(0.0, 1.0, 0.0);
        float skyFadeIn = (1.0 - highLODOut) * SKY_RATIO;
        vNormal = normalize(mix(UP, grassVertexNormal1, skyFadeIn));

        vec3 pos = grassVertexPosition;

        vec3 viewDir = normalize(cameraPosition - grassBladeWorldPos);
        vec3 viewDirXZ = normalize(vec3(viewDir.x, 0.0, viewDir.z));
        vec3 grassFaceNormalXZ = normalize(vec3(grassFaceNormal.x, 0.0, grassFaceNormal.z));

        float viewDotNormal = saturate(dot(grassFaceNormal, viewDirXZ));
        float viewSpaceThickenFactor = easeOut(1.0 - viewDotNormal, 4.0) * smoothstep(0.0, 0.2, viewDotNormal);

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        
        // Thicken effect for better visibility
        mvPosition.x += viewSpaceThickenFactor * (xSide - 0.5) * grassTotalWidth * 0.5 * zSide;
        
        gl_Position = projectionMatrix * mvPosition;
        
        vPosition = pos;
        vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
        
        // Map UV to select one of the 5 blade variations
        // Each blade is 143px wide in a 715px texture (1/5 = 0.2 of the total width)
        // X coordinate: map the xSide (0-1) to a 0.2 width segment based on variation
        float uvX = (xSide * 0.2) + (bladeVariation * 0.2);
        vUv = vec2(uvX, heightPercent);
      }
    `;
    
    const grassFragmentShader = `
      uniform vec3 diffuse;
      uniform vec3 specular;
      uniform float shininess;
      uniform float opacity;
      uniform float time;
      uniform sampler2D grassTexture;
      
      varying vec4 vGrassParams;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      varying vec2 vUv;
      
      // Light data (mimic Three.js directional light)
      struct DirectionalLight {
        vec3 direction;
        vec3 color;
      };
      
      const DirectionalLight directionalLight = DirectionalLight(
        normalize(vec3(-0.5, 0.8, 0.5)),
        vec3(1.0, 1.0, 1.0)
      );
      
      // Utility functions
      float saturate(float x) {
        return clamp(x, 0.0, 1.0);
      }
      
      float easeIn(float x, float t) {
        return pow(x, t);
      }
      
      vec3 calculateLighting(vec3 normal, vec3 viewDir, vec3 baseColor) {
        // Ambient term
        vec3 ambient = vec3(0.3) * baseColor;
        
        // Diffuse term with wrapped lighting for softer look
        float wrap = 0.5;
        float NdotL = saturate((dot(normal, directionalLight.direction) + wrap) / (1.0 + wrap));
        vec3 diffuseLight = NdotL * directionalLight.color * baseColor;
        
        // Simple specular for highlights
        vec3 halfVector = normalize(directionalLight.direction + viewDir);
        float NdotH = max(0.0, dot(normal, halfVector));
        vec3 specularLight = pow(NdotH, shininess) * specular * directionalLight.color;
        
        // Back-lighting for translucency effect
        float backLight = saturate((dot(viewDir, -directionalLight.direction) + wrap) / (1.0 + wrap));
        float backFalloff = 0.5;
        vec3 backScatter = directionalLight.color * pow(backLight, 1.0) * backFalloff * baseColor * (1.0 - vGrassParams.z);
        
        return ambient + diffuseLight + specularLight + backScatter;
      }
      
      void main() {
        // Grass color processing
        float heightPercent = vGrassParams.x;
        float lodFadeIn = vGrassParams.z;
        
        // Sample the grass texture
        vec4 texSample = texture2D(grassTexture, vUv);
        
        // Use texture color directly
        vec3 baseColor = texSample.rgb;
        
        // Apply ambient occlusion at the base for natural grounding
        float ao = mix(0.25, 1.0, easeIn(heightPercent, 2.0));
        baseColor *= ao;
        
        // Lighting calculation
        vec3 viewDir = normalize(cameraPosition - vWorldPosition);
        vec3 litColor = calculateLighting(normalize(vNormal), viewDir, baseColor);
        
        // Use alpha from texture if available
        float alpha = texSample.a;
        if (alpha < 0.5) discard; // Discard pixels with low alpha
        
        gl_FragColor = vec4(litColor, 1.0);
      }
    `;
    
    this.shaderCache['GRASS'] = {
      vertex: grassVertexShader,
      fragment: grassFragmentShader
    };
  }

  public getShader(name: string): { vertex: string, fragment: string } {
    if (!this.shaderCache[name]) {
      console.error(`Shader ${name} not found`);
      return { vertex: '', fragment: '' };
    }
    return this.shaderCache[name];
  }
}

// Custom shader material class that works with our shader system
class CustomShaderMaterial extends THREE.ShaderMaterial {
  constructor(type: string, parameters: THREE.ShaderMaterialParameters = {}) {
    const shaderManager = ShaderManager.getInstance();
    const shader = shaderManager.getShader(type);
    
    if (!parameters.uniforms) {
      parameters.uniforms = {};
    }
    
    parameters.vertexShader = shader.vertex;
    parameters.fragmentShader = shader.fragment;
    
    super(parameters);
    
    // Set some default values
    this.transparent = parameters.transparent !== undefined ? parameters.transparent : false;
    this.side = parameters.side !== undefined ? parameters.side : THREE.FrontSide;
    this.depthWrite = parameters.depthWrite !== undefined ? parameters.depthWrite : true;
    this.depthTest = parameters.depthTest !== undefined ? parameters.depthTest : true;
  }
  
  setFloat(name: string, value: number): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value = value;
    }
  }
  
  setVector2(name: string, value: THREE.Vector2): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setVector3(name: string, value: THREE.Vector3): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setVector4(name: string, value: THREE.Vector4): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setMatrix(name: string, value: THREE.Matrix4): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value: value.clone() };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setTexture(name: string, value: THREE.Texture): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value = value;
    }
  }
}

// Simple math utility functions
const setSeed = (seed: number): void => {
  // Use a simple random number generator
  Math.random = () => {
    const x = Math.sin(seed++) * 10000;
    return x - Math.floor(x);
  };
};

const randRange = (min: number, max: number): number => {
  return Math.random() * (max - min) + min;
};

// Constants for grass rendering
const NUM_GRASS = (32 * 32) * 3;
const GRASS_SEGMENTS_LOW = 1;
const GRASS_SEGMENTS_HIGH = 6;
const GRASS_VERTICES_LOW = (GRASS_SEGMENTS_LOW + 1) * 2;
const GRASS_VERTICES_HIGH = (GRASS_SEGMENTS_HIGH + 1) * 2;
const GRASS_LOD_DIST = 25;
const GRASS_MAX_DIST = 180;
const GRASS_PATCH_SIZE = 5 * 2;
const GRASS_WIDTH = 0.1;
const GRASS_HEIGHT = 1.5;

// Grass component implementation
class GrassComponent {
  private meshesLow: THREE.Mesh[] = [];
  private meshesHigh: THREE.Mesh[] = [];
  private group: THREE.Group;
  private totalTime: number = 0;
  private grassMaterialLow: CustomShaderMaterial;
  private grassMaterialHigh: CustomShaderMaterial;
  private geometryLow: THREE.InstancedBufferGeometry;
  private geometryHigh: THREE.InstancedBufferGeometry;
  private readonly _scene: THREE.Scene;
  private grassTexture: THREE.Texture;

  constructor(scene: THREE.Scene, private camera: THREE.PerspectiveCamera) {
    this._scene = scene;
    this.group = new THREE.Group();
    this.group.name = "GRASS";
    
    // Load grass texture
    this.grassTexture = new THREE.TextureLoader().load('/textures/grassblade.png');
    this.grassTexture.wrapS = THREE.ClampToEdgeWrapping;
    this.grassTexture.wrapT = THREE.ClampToEdgeWrapping;
    this.grassTexture.minFilter = THREE.LinearFilter;
    this.grassTexture.magFilter = THREE.LinearFilter;
    this.grassTexture.generateMipmaps = true;
    // The texture contains 5 blades horizontally, prevent texture bleeding between variants
    this.grassTexture.anisotropy = 16; // Improves appearance at angles
    
    // Initialize grass materials
    this.grassMaterialLow = this.createGrassMaterial(true);
    this.grassMaterialHigh = this.createGrassMaterial(false);
    
    // Create grass geometries
    this.geometryLow = this.createGrassGeometry(GRASS_SEGMENTS_LOW);
    this.geometryHigh = this.createGrassGeometry(GRASS_SEGMENTS_HIGH);
    
    // Add group to scene
    scene.add(this.group);
  }

  private createGrassMaterial(isLowDetail: boolean): CustomShaderMaterial {
    const material = new CustomShaderMaterial('GRASS', {
      uniforms: {
        grassSize: { value: new THREE.Vector2(GRASS_WIDTH, GRASS_HEIGHT) },
        grassParams: { value: new THREE.Vector4(
          isLowDetail ? GRASS_SEGMENTS_LOW : GRASS_SEGMENTS_HIGH,
          isLowDetail ? GRASS_VERTICES_LOW : GRASS_VERTICES_HIGH,
          0, 0
        )},
        grassDraw: { value: new THREE.Vector4(GRASS_LOD_DIST, GRASS_MAX_DIST, 0, 0) },
        time: { value: 0.0 },
        playerPos: { value: new THREE.Vector3(0, 0, 0) },
        viewMatrixInverse: { value: new THREE.Matrix4() },
        diffuse: { value: new THREE.Color(0xffffff) },
        specular: { value: new THREE.Color(0x111111) },
        shininess: { value: 30 },
        grassTexture: { value: this.grassTexture }
      },
      transparent: true,
      alphaTest: 0.5,
      side: THREE.DoubleSide
    });
    
    return material;
  }

  private createGrassGeometry(segments: number): THREE.InstancedBufferGeometry {
    setSeed(0);

    const VERTICES = (segments + 1) * 2;

    // Create indices
    const indices: number[] = [];
    for (let i = 0; i < segments; ++i) {
      const vi = i * 2;
      indices[i*12+0] = vi + 0;
      indices[i*12+1] = vi + 1;
      indices[i*12+2] = vi + 2;

      indices[i*12+3] = vi + 2;
      indices[i*12+4] = vi + 1;
      indices[i*12+5] = vi + 3;

      const fi = VERTICES + vi;
      indices[i*12+6] = fi + 2;
      indices[i*12+7] = fi + 1;
      indices[i*12+8] = fi + 0;

      indices[i*12+9]  = fi + 3;
      indices[i*12+10] = fi + 1;
      indices[i*12+11] = fi + 2;
    }

    // Create offsets
    const offsets: number[] = [];
    for (let i = 0; i < NUM_GRASS; ++i) {
      offsets.push(randRange(-GRASS_PATCH_SIZE * 0.5, GRASS_PATCH_SIZE * 0.5));
      offsets.push(randRange(-GRASS_PATCH_SIZE * 0.5, GRASS_PATCH_SIZE * 0.5));
      offsets.push(0);
    }

    // Create vertex IDs
    const vertID = new Uint8Array(VERTICES*2);
    for (let i = 0; i < VERTICES*2; ++i) {
      vertID[i] = i;
    }

    // Create instanced geometry
    const geo = new THREE.InstancedBufferGeometry();
    geo.instanceCount = NUM_GRASS;
    geo.setAttribute('vertIndex', new THREE.Uint8BufferAttribute(vertID, 1));
    geo.setAttribute('position', new THREE.InstancedBufferAttribute(new Float32Array(offsets), 3));
    geo.setIndex(indices);
    geo.boundingSphere = new THREE.Sphere(new THREE.Vector3(0, 0, 0), 1 + GRASS_PATCH_SIZE * 2);

    return geo;
  }

  private createGrassMesh(distToCell: number): THREE.Mesh {
    const isLowDetail = distToCell > GRASS_LOD_DIST;
    const geometry = isLowDetail ? this.geometryLow : this.geometryHigh;
    const material = isLowDetail ? this.grassMaterialLow : this.grassMaterialHigh;
    
    const mesh = new THREE.Mesh(geometry, material);
    if (!mesh) {
      throw new Error("Failed to create grass mesh");
    }
    mesh.receiveShadow = true;
    mesh.castShadow = false;
    mesh.visible = false;
    
    if (isLowDetail) {
      this.meshesLow.push(mesh);
    } else {
      this.meshesHigh.push(mesh);
    }
    
    this.group.add(mesh);
    return mesh;
  }

  update(deltaTime: number, playerPosition: THREE.Vector3): void {
    this.totalTime += deltaTime;

    // Update material time uniforms
    this.grassMaterialLow.setFloat('time', this.totalTime);
    this.grassMaterialHigh.setFloat('time', this.totalTime);
    
    // Update player position
    this.grassMaterialLow.setVector3('playerPos', playerPosition);
    this.grassMaterialHigh.setVector3('playerPos', playerPosition);
    
    // Update view matrix
    this.grassMaterialLow.setMatrix('viewMatrixInverse', this.camera.matrixWorld);
    this.grassMaterialHigh.setMatrix('viewMatrixInverse', this.camera.matrixWorld);

    // Make all grass patches invisible initially
    for (const child of this.group.children) {
      child.visible = false;
    }

    // Create frustum for culling
    const frustum = new THREE.Frustum();
    const projScreenMatrix = new THREE.Matrix4();
    projScreenMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(projScreenMatrix);
    
    // Calculate base cell position
    const baseCellPos = new THREE.Vector3().copy(this.camera.position);
    baseCellPos.divideScalar(GRASS_PATCH_SIZE);
    baseCellPos.floor();
    baseCellPos.multiplyScalar(GRASS_PATCH_SIZE);
    
    // Copy meshes arrays for reuse
    const meshesLow = [...this.meshesLow];
    const meshesHigh = [...this.meshesHigh];
    
    // Camera position flattened to XZ plane for distance calculation
    const cameraPosXZ = new THREE.Vector3(this.camera.position.x, 0, this.camera.position.z);
    
    // Spawn grass patches
    let totalGrass = 0;
    let totalVerts = 0;
    
    for (let x = -22; x < 22; x++) {
      for (let z = -22; z < 22; z++) {
        // Current cell position
        const currentCell = new THREE.Vector3(
          baseCellPos.x + x * GRASS_PATCH_SIZE, 
          0,
          baseCellPos.z + z * GRASS_PATCH_SIZE
        );
        
        // Create AABB for culling
        const aabb = new THREE.Box3().setFromCenterAndSize(
          currentCell,
          new THREE.Vector3(GRASS_PATCH_SIZE, 1000, GRASS_PATCH_SIZE)
        );
        
        // Calculate distance to cell
        const distToCell = aabb.distanceToPoint(cameraPosXZ);
        
        // Skip if too far
        if (distToCell > GRASS_MAX_DIST) {
          continue;
        }
        
        // Skip if outside frustum
        if (!frustum.intersectsBox(aabb)) {
          continue;
        }
        
        // Create or reuse grass mesh based on distance
        if (distToCell > GRASS_LOD_DIST) {
          const mesh = meshesLow.length > 0 ? meshesLow.pop()! : this.createGrassMesh(distToCell);
          mesh.position.copy(currentCell);
          mesh.visible = true;
          totalVerts += GRASS_VERTICES_LOW;
        } else {
          const mesh = meshesHigh.length > 0 ? meshesHigh.pop()! : this.createGrassMesh(distToCell);
          mesh.position.copy(currentCell);
          mesh.visible = true;
          totalVerts += GRASS_VERTICES_HIGH;
        }
        
        totalGrass += 1;
      }
    }
  }
}

let grassComponent: GrassComponent | null = null;

// Initialize the grass system
export function initGrassSystem(world: ECS) {
  const { scene, camera } = world.ctx.three;
  
  // Create the grass component on system init
  grassComponent = new GrassComponent(scene, camera as THREE.PerspectiveCamera);
  
  // Return the system function
  return function grassSystem(world: ECS) {
    // Get player position from the camera
    const playerPosition = world.ctx.three.camera.position.clone();
    
    // Update grass with elapsed time and player position
    if (grassComponent) {
      grassComponent.update(world.time.dt, playerPosition);
    }
    
    return world;
  };
} 

================================================
File: /src/ecs/systems/healthSystem.ts
================================================
import { defineQuery, hasComponent, removeEntity } from "bitecs";
import { Health, LocalPlayer, NetworkId, RemotePlayer } from "../components";
import { ECS } from "../world";
import { network } from "./network/client"; // Assuming network client is accessible

export function initHealthSystem(world: ECS) {
    const playerQuery = defineQuery([Health, NetworkId]); // Query players with health and network ID

    return (w: ECS) => {
        const entities = playerQuery(w);

        for (const eid of entities) {
            if (Health.current[eid] <= 0) {
                // Player is defeated
                if (hasComponent(w, LocalPlayer, eid)) {
                    // Handle local player death (e.g., show death screen, disable input)
                    // The server will send the actual respawn command
                    if (!w.ctx.localPlayerDefeated) { // Prevent multiple death triggers
                        console.log("Local player defeated! Waiting for server respawn...");
                        w.ctx.localPlayerDefeated = true; // Flag to prevent re-triggering
                        // Optionally disable local player controls here
                        // The 'respawn' message from the server will re-enable things
                    }
                } else if (hasComponent(w, RemotePlayer, eid)) {
                    // Handle remote player death visual/sound (optional)
                    // Server handles actual removal/respawn logic
                     // console.log(`Remote player ${NetworkId.id[eid]} visually defeated.`);
                     // Potentially trigger death animation here if not handled by worldState update
                     // Note: Server might remove the player entity shortly after defeat broadcast
                }

                // Note: Don't remove the entity here. The server controls entity lifetime.
                // The server will either send a respawn update or a playerLeft message.
            } else {
                 // If player was defeated but now has health > 0 (likely respawned)
                 if (hasComponent(w, LocalPlayer, eid) && w.ctx.localPlayerDefeated) {
                     console.log("Local player respawned.");
                     w.ctx.localPlayerDefeated = false; // Reset defeated flag
                     // Re-enable controls if they were disabled
                 }
            }
        }

        // Reset local player defeated flag if the entity is removed (e.g., disconnect)
        if (w.ctx.localPlayerDefeated && !entities.includes(world.players.get(world.ctx.localPlayerId!)!)) {
             w.ctx.localPlayerDefeated = false;
        }


        return w;
    };
}

// Add localPlayerDefeated flag to ECSContext interface in world.ts
declare module '../world' {
    interface ECSContext {
        localPlayerDefeated?: boolean;
    }
}

================================================
File: /src/ecs/systems/input.ts
================================================
import { addComponent, addEntity } from 'bitecs';
import { DebugVis } from '../components';
import { ECS } from '../world';
import { safeAddEventListener, setupEventCleanup } from '../utils/eventUtils';

// Add property to Window interface
declare global {
  interface Window {
    listenersAttached?: boolean;
  }
}

export interface InputState {
  fw: boolean; bk: boolean; lf: boolean; rt: boolean;
  sprint: boolean;
  shoot: boolean; jump: boolean;
  pointerLocked: boolean;
  dx: number; dy: number;
  debugActive: boolean;
}

export function initInputSystem(world: ECS) {
  const state: InputState = {
    fw: false, bk: false, lf: false, rt: false,
    sprint: false,
    shoot: false, jump: false,
    pointerLocked: false,
    dx: 0, dy: 0,
    debugActive: false
  };
  
  // Keep track of whether V was pressed last frame
  let vWasPressed = false;
  
  // Create a singleton debug entity and add the component to it
  const debugId = addEntity(world); // Create a new entity, don't assume ID 0
  addComponent(world, DebugVis, debugId);
  DebugVis.active[debugId] = 0; // 0 = off, 1 = on

  /* keyboard ------------------------------------------------------- */
  const key = (code: string, v: boolean) => {
    if (code === 'KeyW' || code === 'ArrowUp')    state.fw     = v;
    if (code === 'KeyS' || code === 'ArrowDown')  state.bk     = v;
    if (code === 'KeyA' || code === 'ArrowLeft')  state.lf     = v;
    if (code === 'KeyD' || code === 'ArrowRight') state.rt     = v;
    if (code === 'Space')                         state.jump   = v;
    if (code === 'ShiftLeft' || code === 'ShiftRight') state.sprint = v;
    
    // Handle V key press for debug visualization toggle
    if (code === 'KeyV') {
      // Toggle on key down only
      if (v && !vWasPressed) {
        // Toggle debug state
        const newState = DebugVis.active[debugId] === 0 ? 1 : 0;
        DebugVis.active[debugId] = newState;
        state.debugActive = newState === 1;
        console.log(`Debug visualization: ${state.debugActive ? 'ON' : 'OFF'}`);
      }
      vWasPressed = v;
    }
  };
  
  // Only attach event listeners once
  if (!window.listenersAttached) {
    safeAddEventListener(window, 'keydown', e => key((e as KeyboardEvent).code, true));
    safeAddEventListener(window, 'keyup',   e => key((e as KeyboardEvent).code, false));

    /* mouse ---------------------------------------------------------- */
    const canvas = document.getElementById('c') as HTMLCanvasElement;
    safeAddEventListener(canvas, 'click', () => canvas.requestPointerLock());

    safeAddEventListener(document, 'pointerlockchange', () => {
      state.pointerLocked = !!document.pointerLockElement;
    });

    safeAddEventListener(window, 'mousemove', e => {
      if (!state.pointerLocked) return;
      state.dx += (e as MouseEvent).movementX;
      state.dy += (e as MouseEvent).movementY;
    });

    safeAddEventListener(window, 'mousedown', e => { if ((e as MouseEvent).button === 0) state.shoot = true; });
    safeAddEventListener(window, 'mouseup',   e => { if ((e as MouseEvent).button === 0) state.shoot = false; });
    
    // Set up event cleanup
    setupEventCleanup();
    
    // Mark listeners as attached
    window.listenersAttached = true;
  }

  return (w: ECS) => { 
    // Set the input state on the world
    w.input = state;
    return w;
  };
}


================================================
File: /src/ecs/systems/network/client.ts
================================================
import {
    addComponent,
    addEntity,
    defineQuery,
    enterQuery,
    exitQuery,
    hasComponent,
    removeComponent,
    removeEntity
} from 'bitecs';
import * as THREE from 'three';
import { NetworkConfig, WeaponConfig, PlayerConfig } from '../../config';
import {
    AnimationState, Health, InterpolationTarget, LocalPlayer, MeshRef, NetworkId, RemotePlayer, RigidBodyRef, Transform, Projectile, Lifespan, Velocity
} from '../../components';
import { ECS, ECSContext } from '../../world';
import { PlayerAnimationState } from '../../config';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'; // Needed for loading remote player models
import { createVisualProjectile } from '../player/shootSystem'; // Import the visual projectile function

// --- Network State Interface ---
export interface NetworkState {
    connected: boolean;
    connecting: boolean;
    socket: WebSocket | null;
    messageQueue: any[]; // Queue for incoming messages
    pendingUpdates: Map<number, any>; // EntityId -> Last sent state for diffing (optimization)
    lastSentTime: number;
    lastPingTime: number;
}

// --- Network Singleton ---
// Using a singleton pattern for managing the WebSocket connection
class NetworkClient {
    private world: ECS | null = null;
    private state: NetworkState = {
        connected: false,
        connecting: false,
        socket: null,
        messageQueue: [],
        pendingUpdates: new Map(),
        lastSentTime: 0,
        lastPingTime: 0
    };
    private reconnectAttempts = 0;
    private maxReconnectAttempts = 5;
    private reconnectTimer: NodeJS.Timeout | null = null;
    private modelsLoaded = false; // Track if base models are loaded

    async connect(world: ECS): Promise<void> {
        if (this.state.connected || this.state.connecting) {
            console.warn("Network connection already established or in progress.");
            return;
        }

        this.world = world;
        this.world.network = this.state; // Link the state to the world
        this.state.connecting = true;
        console.log(`Attempting to connect to ${NetworkConfig.SERVER_URL}...`);

        // Preload models needed for remote players before connecting
        await this.preloadModels();

        try {
            this.state.socket = new WebSocket(NetworkConfig.SERVER_URL);

            this.state.socket.onopen = () => {
                console.log("WebSocket connection established.");
                this.state.connected = true;
                this.state.connecting = false;
                this.reconnectAttempts = 0; // Reset attempts on successful connection
                if (this.reconnectTimer) clearTimeout(this.reconnectTimer);
                this.state.lastPingTime = Date.now(); // Start ping timer
            };

            this.state.socket.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data as string);
                    // Push message to the queue to be processed by the system
                    this.state.messageQueue.push(message);
                } catch (error) {
                    console.error("Failed to parse server message:", error);
                }
            };

            this.state.socket.onerror = (error) => {
                console.error("WebSocket error:", error);
                // Error event often precedes close event, let onclose handle reconnect
            };

            this.state.socket.onclose = (event) => {
                console.log(`WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason}`);
                this.state.connected = false;
                this.state.connecting = false;
                this.state.socket = null;
                this.world!.ctx.localPlayerId = null; // Reset local player ID
                // Maybe clear existing remote players here? Or let the server handle it on re-init.
                this.scheduleReconnect();
            };
        } catch (error) {
            console.error("Failed to create WebSocket connection:", error);
            this.state.connecting = false;
            this.scheduleReconnect();
        }
    }

    private scheduleReconnect(): void {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.error("Max reconnection attempts reached. Please refresh the page.");
            return;
        }
        if (this.reconnectTimer) clearTimeout(this.reconnectTimer);

        this.reconnectAttempts++;
        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts -1), 30000); // Exponential backoff
        console.log(`Attempting to reconnect in ${delay / 1000} seconds (Attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);

        this.reconnectTimer = setTimeout(() => {
            if (this.world) {
                this.connect(this.world);
            }
        }, delay);
    }

    send(data: any): void {
        if (this.state.connected && this.state.socket) {
            this.state.socket.send(JSON.stringify(data));
        }
    }

    disconnect(): void {
        if (this.reconnectTimer) clearTimeout(this.reconnectTimer);
        this.reconnectAttempts = this.maxReconnectAttempts; // Prevent further attempts
        if (this.state.socket) {
            this.state.socket.close();
            this.state.socket = null;
        }
        this.state.connected = false;
        this.state.connecting = false;
        console.log("Network disconnected manually.");
    }

    // --- Model Preloading ---
    private async preloadModels() {
        if (this.modelsLoaded) return;
        console.log("Preloading player model for remote players...");
        const loader = new GLTFLoader();
        try {
            await loader.loadAsync('/models/playermodel.glb');
            this.modelsLoaded = true;
            console.log("Player model preloaded successfully.");
        } catch (error) {
            console.error("Failed to preload player model:", error);
        }
    }
}

export const network = new NetworkClient(); // Export singleton instance

// --- ECS Network System ---
export function initNetworkSystem(world: ECS) {
    const localPlayerQuery = defineQuery([LocalPlayer, Transform, Health, AnimationState]);
    const remotePlayerQuery = defineQuery([RemotePlayer, NetworkId, Transform, MeshRef, InterpolationTarget]);
    const networkIdMap = world.players; // Use the map from the world object

    // --- Queries for Adding/Removing Remote Players ---
    const remotePlayerEnterQuery = enterQuery(remotePlayerQuery);
    const remotePlayerExitQuery = exitQuery(remotePlayerQuery);

    // --- Message Handlers ---
    const handleInit = (data: any) => {
        console.log("Received init from server:", data);
        world.ctx.localPlayerId = data.playerId;

        // Find the local player entity (should have been created by initPlayerSystem)
        const localPlayers = localPlayerQuery(world);
        if (localPlayers.length > 0) {
            const localEid = localPlayers[0];
            // Add NetworkId if it doesn't exist, or update it
            if (!hasComponent(world, NetworkId, localEid)) {
                 addComponent(world, NetworkId, localEid);
            }
            NetworkId.id[localEid] = data.playerId;
            networkIdMap.set(data.playerId, localEid);

             // Initialize local player state from server if necessary (e.g., spawn pos)
            if (data.initialState?.position) {
                 Transform.x[localEid] = data.initialState.position.x;
                 Transform.y[localEid] = data.initialState.position.y;
                 Transform.z[localEid] = data.initialState.position.z;
                // Also update the RigidBody position if it exists
                const rb = world.ctx.maps.rb.get(localEid);
                if(rb) {
                    rb.setTranslation(data.initialState.position, true);
                     // Reset velocity after setting position
                    rb.setLinvel({ x: 0, y: 0, z: 0 }, true);
                    rb.setAngvel({ x: 0, y: 0, z: 0 }, true);
                }
            }
            if (data.initialState?.rotation) {
                Transform.qx[localEid] = data.initialState.rotation.x;
                Transform.qy[localEid] = data.initialState.rotation.y;
                Transform.qz[localEid] = data.initialState.rotation.z;
                Transform.qw[localEid] = data.initialState.rotation.w;
                 const rb = world.ctx.maps.rb.get(localEid);
                 if(rb) rb.setRotation(data.initialState.rotation, true);
            }
             if (data.initialState?.health !== undefined) {
                Health.current[localEid] = data.initialState.health;
                Health.max[localEid] = data.initialState.maxHealth || PlayerConfig.MAX_HEALTH;
             }
        } else {
            console.error("LocalPlayer entity not found during network init!");
        }

        // Add existing players from the server message
        data.players?.forEach((playerState: any) => handlePlayerJoined({ playerState }));
    };

    const handlePlayerJoined = (data: any) => {
        const playerState = data.playerState;
        if (!playerState || playerState.id === world.ctx.localPlayerId || networkIdMap.has(playerState.id)) {
            return; // Don't add self or existing players
        }
        console.log(`Player ${playerState.id} joined, creating remote entity...`);
        addRemotePlayer(world, world.ctx, playerState);
    };

    const handlePlayerLeft = (data: any) => {
        const remoteEid = networkIdMap.get(data.playerId);
        if (remoteEid !== undefined) {
            console.log(`Player ${data.playerId} left, removing entity ${remoteEid}`);
            removeRemotePlayer(world, world.ctx, remoteEid);
            networkIdMap.delete(data.playerId);
        } else {
             console.log(`Received playerLeft for unknown or already removed player ${data.playerId}`);
        }
    };

    const handleWorldState = (data: any) => {
        data.players?.forEach((playerState: any) => {
            if (playerState.id === world.ctx.localPlayerId) return; // Ignore updates for local player state

            const remoteEid = networkIdMap.get(playerState.id);
            if (remoteEid !== undefined) {
                // Update existing remote player's target state for interpolation
                if (hasComponent(world, InterpolationTarget, remoteEid)) {
                    InterpolationTarget.targetX[remoteEid] = playerState.position.x;
                    InterpolationTarget.targetY[remoteEid] = playerState.position.y;
                    InterpolationTarget.targetZ[remoteEid] = playerState.position.z;
                    InterpolationTarget.targetQX[remoteEid] = playerState.rotation.x;
                    InterpolationTarget.targetQY[remoteEid] = playerState.rotation.y;
                    InterpolationTarget.targetQZ[remoteEid] = playerState.rotation.z;
                    InterpolationTarget.targetQW[remoteEid] = playerState.rotation.w;
                    InterpolationTarget.timestamp[remoteEid] = data.timestamp; // Use server timestamp
                }
                if (hasComponent(world, AnimationState, remoteEid)) {
                    AnimationState.state[remoteEid] = playerState.animationState;
                }
                if (hasComponent(world, Health, remoteEid) && playerState.health !== undefined) {
                     Health.current[remoteEid] = playerState.health;
                }
            } else {
                // Player doesn't exist locally, add them (might happen on late join/reconnect)
                console.log(`WorldState adding missing player ${playerState.id}`);
                addRemotePlayer(world, world.ctx, playerState);
            }
        });
    };

    const handlePlayerShoot = (data: any) => {
        const shooterEid = networkIdMap.get(data.playerId);
        if (shooterEid === undefined || shooterEid === world.ctx.localPlayerId) return; // Ignore self or unknown

        // Find the shooter entity to get accurate position/direction for effects
        const shooterMesh = world.ctx.maps.mesh.get(shooterEid);
        if (shooterMesh) {
            // Use the provided position/direction from the message for spawning
            const pos = new THREE.Vector3(data.position.x, data.position.y, data.position.z);
            const dir = new THREE.Vector3(data.direction.x, data.direction.y, data.direction.z);

            // Create visual projectile for remote player shot
            createVisualProjectile(world, pos, dir, 0x00aaff);
            
            // TODO: Play shooting sound spatially from shooterMesh position
        } else {
            console.warn(`Shooter mesh not found for remote player ${data.playerId}`);
        }
    };

    const handlePlayerDamaged = (data: any) => {
        const localPlayers = localPlayerQuery(world);
        if (localPlayers.length > 0) {
            const localEid = localPlayers[0];
            console.log(`Local player (${NetworkId.id[localEid]}) took ${data.damage} damage from ${data.sourceId}`);
            if (hasComponent(world, Health, localEid)) {
                Health.current[localEid] = data.newHealth;
                // Trigger UI update or visual feedback here
                console.log(`My new health: ${Health.current[localEid]}`);
            }
        }
    };

    const handleHealthUpdate = (data: any) => {
        const targetEid = networkIdMap.get(data.playerId);
        if (targetEid !== undefined && targetEid !== world.ctx.localPlayerId) {
            if (hasComponent(world, Health, targetEid)) {
                Health.current[targetEid] = data.health;
            }
        }
    };

    const handleRespawn = (data: any) => {
        console.log("Received respawn confirmation from server", data.newState);
        const localPlayers = localPlayerQuery(world);
        if (localPlayers.length > 0) {
            const localEid = localPlayers[0];
            const newState = data.newState;

            // Forcefully set state based on server respawn data
            if (newState.position) {
                Transform.x[localEid] = newState.position.x;
                Transform.y[localEid] = newState.position.y;
                Transform.z[localEid] = newState.position.z;
                const rb = world.ctx.maps.rb.get(localEid);
                if (rb) {
                    rb.setTranslation(newState.position, true);
                    rb.setLinvel({ x: 0, y: 0, z: 0 }, true);
                    rb.setAngvel({ x: 0, y: 0, z: 0 }, true);
                }
                // Reset vertical velocity in FPController
                if(hasComponent(world, FPController, localEid)) {
                    FPController.vertVel[localEid] = 0;
                    FPController.moveState[localEid] = MovementState.GROUNDED; // Assume grounded after respawn
                }
            }
            if (newState.rotation) {
                Transform.qx[localEid] = newState.rotation.x;
                Transform.qy[localEid] = newState.rotation.y;
                Transform.qz[localEid] = newState.rotation.z;
                Transform.qw[localEid] = newState.rotation.w;
                const rb = world.ctx.maps.rb.get(localEid);
                if(rb) rb.setRotation(newState.rotation, true);
                // Also potentially update camera pitch if needed, though server usually doesn't dictate this
            }
            if (newState.health !== undefined) {
                Health.current[localEid] = newState.health;
                Health.max[localEid] = newState.maxHealth || PlayerConfig.MAX_HEALTH;
            }
            AnimationState.state[localEid] = PlayerAnimationState.IDLE; // Reset animation

            console.log(`Local player respawned at ${newState.position.x.toFixed(2)}, ${newState.position.y.toFixed(2)}, ${newState.position.z.toFixed(2)}`);
            // Trigger UI updates if necessary
        }
    };

    // --- System Logic ---
    return (w: ECS) => {
        const now = Date.now();

        // --- Process Incoming Messages ---
        while (w.network.messageQueue.length > 0) {
            const message = w.network.messageQueue.shift();
            switch (message.type) {
                case 'init': handleInit(message); break;
                case 'playerJoined': handlePlayerJoined(message); break;
                case 'playerLeft': handlePlayerLeft(message); break;
                case 'worldState': handleWorldState(message); break; // Use worldState for updates
                case 'playerShoot': handlePlayerShoot(message); break;
                case 'playerDamaged': handlePlayerDamaged(message); break; // When local player is damaged
                case 'healthUpdate': handleHealthUpdate(message); break; // For remote player health changes
                case 'respawn': handleRespawn(message); break;
                case 'hitConfirmed': /* Optional: Show hit marker for local player */ break;
                case 'playerDefeated': /* Optional: Show kill feed message */ break;
                case 'playerRespawned': /* Optional: Handle remote player visual respawn */ break;
                case 'ping': /* Server ping, client can ignore or track latency */ break;
                case 'error': console.error("Server Error:", message.message); break;
                default: console.warn("Received unhandled message type:", message.type);
            }
        }

        // --- Send Local Player Updates ---
        if (w.network.connected && now - w.network.lastSentTime > NetworkConfig.UPDATE_INTERVAL_MS) {
            const localPlayers = localPlayerQuery(w);
            if (localPlayers.length > 0) {
                const eid = localPlayers[0];
                const currentState = {
                    position: { x: Transform.x[eid], y: Transform.y[eid], z: Transform.z[eid] },
                    rotation: { x: Transform.qx[eid], y: Transform.qy[eid], z: Transform.qz[eid], w: Transform.qw[eid] },
                    animationState: AnimationState.state[eid],
                    health: Health.current[eid]
                };

                network.send({ type: 'playerUpdate', state: currentState });
                w.network.lastSentTime = now;
            }
        }

        // --- Interpolate Remote Players ---
        const remoteEntities = remotePlayerQuery(w);
        // Use a fixed delay for interpolation between server updates
        const renderTime = now - NetworkConfig.INTERPOLATION_DELAY_MS;

        for (const eid of remoteEntities) {
            // Get the target state from InterpolationTarget component
            const currentTimestamp = InterpolationTarget.timestamp[eid];
            const targetX = InterpolationTarget.targetX[eid];
            const targetY = InterpolationTarget.targetY[eid];
            const targetZ = InterpolationTarget.targetZ[eid];
            const targetQX = InterpolationTarget.targetQX[eid];
            const targetQY = InterpolationTarget.targetQY[eid];
            const targetQZ = InterpolationTarget.targetQZ[eid];
            const targetQW = InterpolationTarget.targetQW[eid];

            // Smooth interpolation factor - adjust this based on network conditions
            const lerpFactor = 0.1; // Reduced from 0.2 for smoother movement

            // Update position with interpolation
            Transform.x[eid] += (targetX - Transform.x[eid]) * lerpFactor;
            Transform.y[eid] += (targetY - Transform.y[eid]) * lerpFactor;
            Transform.z[eid] += (targetZ - Transform.z[eid]) * lerpFactor;

            // Use Quaternion slerp for smoother rotation interpolation
            const currentQuat = new THREE.Quaternion(Transform.qx[eid], Transform.qy[eid], Transform.qz[eid], Transform.qw[eid]);
            const targetQuat = new THREE.Quaternion(targetQX, targetQY, targetQZ, targetQW);
            
            // Use a smaller factor for rotation to avoid jittering
            const rotLerpFactor = 0.08; // Slower rotation interpolation
            currentQuat.slerp(targetQuat, rotLerpFactor);

            Transform.qx[eid] = currentQuat.x;
            Transform.qy[eid] = currentQuat.y;
            Transform.qz[eid] = currentQuat.z;
            Transform.qw[eid] = currentQuat.w;
            
            // Optional: Update the mesh directly here if needed
            // But generally this should be handled by renderSync
        }

        // --- Handle Player Model Loading for New Remote Players ---
        const entered = remotePlayerEnterQuery(w);
        for (const eid of entered) {
            const networkId = NetworkId.id[eid];
            console.log(`Remote player entity ${eid} (NetworkID: ${networkId}) entered query. Setting up model...`);
            // Ensure the setup runs only once per entity entry
            if (!world.ctx.maps.mesh.has(eid)) {
                setupRemotePlayerModel(world, world.ctx, eid, networkId);
            }
        }

        // --- Handle Cleanup for Removed Remote Players ---
        const exited = remotePlayerExitQuery(w);
        for (const eid of exited) {
            console.log(`Remote player entity ${eid} exited query. Cleaning up...`);
            removeRemotePlayer(world, world.ctx, eid);
            // The NetworkId mapping is cleaned up in handlePlayerLeft
        }

        // --- Ping Server ---
        if (w.network.connected && now - w.network.lastPingTime > NetworkConfig.PING_INTERVAL_MS) {
            network.send({ type: 'ping' });
            w.network.lastPingTime = now;
        }

        return w;
    };
}

async function addRemotePlayer(world: ECS, ctx: ECSContext, playerState: any) {
    if (ctx.localPlayerId === playerState.id) {
        console.warn(`Attempted to add local player ${playerState.id} as remote.`);
        return;
    }
    if (world.players.has(playerState.id)) {
        console.warn(`Remote player ${playerState.id} already exists.`);
        return;
    }

    const eid = addEntity(world);
    addComponent(world, RemotePlayer, eid);
    addComponent(world, NetworkId, eid);
    addComponent(world, Transform, eid);
    addComponent(world, MeshRef, eid); // Needed for RenderSync
    addComponent(world, Health, eid);
    addComponent(world, AnimationState, eid);
    addComponent(world, InterpolationTarget, eid); // For smooth movement

    NetworkId.id[eid] = playerState.id;
    Transform.x[eid] = playerState.position.x;
    Transform.y[eid] = playerState.position.y;
    Transform.z[eid] = playerState.position.z;
    Transform.qx[eid] = playerState.rotation.x;
    Transform.qy[eid] = playerState.rotation.y;
    Transform.qz[eid] = playerState.rotation.z;
    Transform.qw[eid] = playerState.rotation.w;
    Health.current[eid] = playerState.health;
    Health.max[eid] = playerState.maxHealth || PlayerConfig.MAX_HEALTH; // Use default if not provided
    AnimationState.state[eid] = playerState.animationState;

    // Initialize interpolation target to current state
    InterpolationTarget.targetX[eid] = playerState.position.x;
    InterpolationTarget.targetY[eid] = playerState.position.y;
    InterpolationTarget.targetZ[eid] = playerState.position.z;
    InterpolationTarget.targetQX[eid] = playerState.rotation.x;
    InterpolationTarget.targetQY[eid] = playerState.rotation.y;
    InterpolationTarget.targetQZ[eid] = playerState.rotation.z;
    InterpolationTarget.targetQW[eid] = playerState.rotation.w;
    InterpolationTarget.timestamp[eid] = Date.now(); // Use current time initially

    world.players.set(playerState.id, eid); // Map NetworkId to EntityId

    console.log(`Added remote player entity ${eid} for NetworkId ${playerState.id}`);

    // Model setup is now handled by the enterQuery in the system loop
}

async function setupRemotePlayerModel(world: ECS, ctx: ECSContext, eid: number, networkId: number) {
    console.log(`Setting up model for remote entity ${eid} (NetworkID: ${networkId})`);
    const loader = new GLTFLoader();
    try {
        const gltf = await loader.loadAsync('/models/playermodel.glb');
        const model = gltf.scene;

        model.scale.set(1, 1, 1); // Adjust scale as needed
        model.position.set(0, 0, 0); // Position should be at entity center, not offset
        model.rotation.y = 0; // Don't add rotation - let the transform handle it
        
        // Add animation mixer if animations exist
        let mixer: THREE.AnimationMixer | null = null;
        if (gltf.animations && gltf.animations.length > 0) {
            mixer = new THREE.AnimationMixer(model);
            // Store animations/actions for playback later
            model.userData.animations = gltf.animations; // Store animations raw data
            model.userData.mixer = mixer;
            model.userData.actions = {};
            
            gltf.animations.forEach(clip => {
                // Rename the clips to standardized names for better matching
                let clipName = clip.name.toLowerCase();
                let standardName = clip.name;
                
                if (clipName.includes('idle')) standardName = 'idle';
                else if (clipName.includes('walk')) standardName = 'walk';
                else if (clipName.includes('run')) standardName = 'run';
                else if (clipName.includes('jump')) {
                    if (clipName.includes('start')) standardName = 'jump_start';
                    else if (clipName.includes('fall')) standardName = 'jump_fall';
                    else standardName = 'jump';
                }
                
                const action = mixer.clipAction(clip);
                action.setLoop(THREE.LoopRepeat, Infinity);
                model.userData.actions[standardName] = action;
                console.log(`Animation loaded for remote player: ${standardName}`);
            });
            
            // Start idle animation by default
            if (model.userData.actions['idle']) {
                model.userData.actions['idle'].play();
            }
        }

        model.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });

        ctx.three.scene.add(model);
        ctx.maps.mesh.set(eid, model); // Link entity ID to the model
        console.log(`Model added for remote player ${networkId} (Entity ${eid})`);

    } catch (error) {
        console.error(`Failed to load model for remote player ${networkId}:`, error);
        // Optionally add a placeholder mesh on error
        const placeholder = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 1.8, 0.6),
            new THREE.MeshStandardMaterial({ color: 0xcccccc })
        );
        placeholder.position.y = 0.9;
        ctx.three.scene.add(placeholder);
        ctx.maps.mesh.set(eid, placeholder);
    }
}

function removeRemotePlayer(world: ECS, ctx: ECSContext, eid: number) {
    const mesh = ctx.maps.mesh.get(eid);
    if (mesh) {
        // Properly dispose of mesh resources
        mesh.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                child.geometry?.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach((mat) => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            }
        });
        ctx.three.scene.remove(mesh);
        ctx.maps.mesh.delete(eid);
    }
    
    // Remove Rapier body if it exists (remote players might not have one client-side)
    const rb = ctx.maps.rb.get(eid);
    if (rb) {
        ctx.physics.removeRigidBody(rb);
        ctx.maps.rb.delete(eid);
        if (ctx.entityHandleMap) {
            ctx.entityHandleMap.delete(rb.handle);
        }
    }

    // Remove the entity itself if it still exists
    if (hasComponent(world, NetworkId, eid)) { // Check if entity might have been removed already
        removeEntity(world, eid);
        console.log(`Removed remote player entity ${eid}`);
    } else {
        console.log(`Entity ${eid} already removed or invalid.`);
    }
}

================================================
File: /src/ecs/systems/physics.ts
================================================
import { defineQuery, exitQuery } from 'bitecs';
import { RigidBodyRef } from '../components';
import { ECS } from '../world';
import { PhysicsConfig, TimeStepConfig } from '../config';

export function initPhysicsSystem(_world: ECS) {
  const rbq = defineQuery([RigidBodyRef]);
  const exit = exitQuery(rbq);

  /* cleanup on entity removal */
  return (w: ECS) => {
    // Skip physics if we're not on a physics frame
    if (!w.time.shouldRunPhysics) {
      return w;
    }
    
    // Get all active rigid bodies
    const rigidBodies = [];
    for (const eid of rbq(w)) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb) rigidBodies.push(rb);
    }
    
    // Dynamically enable CCD on fast-moving objects
    for (const rb of rigidBodies) {
      try {
        // Different versions of Rapier have different APIs
        // Check if the body is dynamic (only dynamic bodies can have CCD)
        const isDynamic = rb.bodyType && 
                         rb.bodyType() === w.ctx.rapier.RigidBodyType.Dynamic;
        
        if (isDynamic) {
          const vel = rb.linvel();
          const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y + vel.z * vel.z);
          
          // Enable CCD for fast moving objects 
          // Check if this version of Rapier supports CCD toggling
          if (speed > PhysicsConfig.VELOCITY_THRESHOLD && rb.enableCcd) {
            rb.enableCcd(true);
          } 
          // Disable CCD for slower objects to improve performance
          else if (speed < PhysicsConfig.VELOCITY_THRESHOLD * 0.8 && rb.enableCcd) {
            rb.enableCcd(false);
          }
        }
      } catch (e) {
        // Skip CCD handling if the API doesn't match
      }
    }
    
    // Configure physics parameters if the API supports it
    try {
      if (w.ctx.physics.integrationParameters) {
        // Set solver iterations for more accurate simulation
        w.ctx.physics.integrationParameters.numSolverIterations = PhysicsConfig.SOLVER_ITERATIONS;
        
        // Increase CCD substeps - critical for bullet physics!
        w.ctx.physics.integrationParameters.maxCcdSubsteps = PhysicsConfig.CCD_SUBSTEPS;
      }
    } catch (e) {
      // Skip if the API doesn't support this
    }
    
    // Always use the fixed timestep from the time system
    const dt = w.time.fixedDt || TimeStepConfig.FIXED_DT;
    
    // Process physics step with fixed timestep - handle type issues with assertions
    if (w.ctx.eventQueue) {
      // Call step with the correct argument order based on Rapier type definitions
      // Type assertion needed due to version differences in Rapier API
      (w.ctx.physics.step as any)(w.ctx.eventQueue, dt);
    } else {
      // Type assertion needed due to differences in Rapier API versions
      (w.ctx.physics.step as any)(dt);
    }

    /* purge removed RigidBodies */
    for (const eid of exit(w)) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb) {
        w.ctx.physics.removeRigidBody(rb);
        w.ctx.maps.rb.delete(eid);
      }
    }
    return w;
  };
}


================================================
File: /src/ecs/systems/player/animationStateMachine.ts
================================================
/**
 * Animation state machine for the FPS full-body camera setup
 */
import * as THREE from 'three';
import { PlayerAnimationState, AnimationTransitions } from '../../config';

// Define animation clip meta data structure
interface AnimationClipMeta {
  name: string;          // Original name from the GLTF file
  state: number;         // Mapped state (PlayerAnimationState enum value)
  weight: number;        // Current weight (0-1)
  action: THREE.AnimationAction | null; // Reference to the THREE animation action
  loop: THREE.AnimationActionLoopStyles; // Loop type (THREE.LoopOnce, THREE.LoopRepeat, etc.)
  clampWhenFinished: boolean; // Whether to clamp the last frame when animation finishes
  timeScale: number;     // Animation playback speed
  isTransitioning: boolean; // Whether this animation is currently in a transition
}

export class AnimationStateMachine {
  // Animation mixer
  private mixer: THREE.AnimationMixer;
  
  // Animation data
  private clips: Map<number, AnimationClipMeta> = new Map();
  private activeState: number = PlayerAnimationState.IDLE;
  private previousState: number = PlayerAnimationState.IDLE;
  
  // Transition info
  private inTransition: boolean = false;
  private transitionTimer: number = 0;
  private transitionDuration: number = 0;
  
  // Debug
  private debug: boolean;
  
  /**
   * Create a new animation state machine
   * @param model The model to animate
   * @param animationClips Array of animation clips from the GLTF file
   * @param debug Whether to log debug info
   */
  constructor(model: THREE.Group, animationClips: THREE.AnimationClip[], debug: boolean = false) {
    this.mixer = new THREE.AnimationMixer(model);
    this.debug = debug;
    
    // Map animation clips to state enum values based on name pattern matching
    this.mapAnimationClips(animationClips);
    
    // Set initial state
    this.setState(PlayerAnimationState.IDLE);
    
    if (this.debug) {
      console.log(`Animation State Machine initialized with ${this.clips.size} clips`);
    }
  }
  
  /**
   * Map animation clips to state enum values by name pattern matching
   */
  private mapAnimationClips(animationClips: THREE.AnimationClip[]): void {
    // Map of keywords to animation states
    const keywordMap: Record<string, number> = {
      'idle': PlayerAnimationState.IDLE,
      'stand': PlayerAnimationState.IDLE,
      'walk': PlayerAnimationState.WALKING,
      'run': PlayerAnimationState.RUNNING,
      'sprint': PlayerAnimationState.SPRINT,
      'jump': PlayerAnimationState.JUMPING,
      'fall': PlayerAnimationState.FALLING,
      'shoot': PlayerAnimationState.SHOOTING,
      'fire': PlayerAnimationState.SHOOTING,
      'aim': PlayerAnimationState.AIMING,
      'reload': PlayerAnimationState.RELOAD,
      'crouch_idle': PlayerAnimationState.CROUCH_IDLE,
      'crouchidle': PlayerAnimationState.CROUCH_IDLE,
      'crouch_walk': PlayerAnimationState.CROUCH_WALK,
      'crouchwalk': PlayerAnimationState.CROUCH_WALK,
      'death': PlayerAnimationState.DEATH,
      'die': PlayerAnimationState.DEATH,
      'hit': PlayerAnimationState.HIT_REACTION,
      'inspect': PlayerAnimationState.INSPECT_WEAPON
    };
    
    // Process each animation clip
    for (const clip of animationClips) {
      // Convert clip name to lowercase for matching
      const lowerName = clip.name.toLowerCase();
      
      // Try to match keywords to determine state
      let state = -1;
      let highestPriorityMatch = -1;
      
      // Check for each keyword
      for (const [keyword, stateValue] of Object.entries(keywordMap)) {
        if (lowerName.includes(keyword)) {
          // If we find a match and it's higher priority (or first match), store it
          if (stateValue > highestPriorityMatch) {
            state = stateValue;
            highestPriorityMatch = stateValue;
          }
        }
      }
      
      // If no state was found, skip this clip
      if (state === -1) {
        if (this.debug) {
          console.log(`Could not map animation: ${clip.name}`);
        }
        continue;
      }
      
      // Create animation action from clip
      const action = this.mixer.clipAction(clip);
      
      // Configure default action settings
      action.setEffectiveWeight(0); // Start with zero weight
      action.enabled = true;
      
      // Determine if animation should loop based on state
      const shouldLoop = [
        PlayerAnimationState.DEATH,
        PlayerAnimationState.SHOOTING,
        PlayerAnimationState.RELOAD,
        PlayerAnimationState.HIT_REACTION,
        PlayerAnimationState.INSPECT_WEAPON
      ].includes(state) ? false : true;
      
      // Create clip metadata
      const clipMeta: AnimationClipMeta = {
        name: clip.name,
        state: state,
        weight: 0,
        action: action,
        loop: shouldLoop ? THREE.LoopRepeat : THREE.LoopOnce,
        clampWhenFinished: !shouldLoop,
        timeScale: 1.0,
        isTransitioning: false
      };
      
      // Configure action based on metadata
      action.setLoop(clipMeta.loop, Infinity);
      action.clampWhenFinished = clipMeta.clampWhenFinished;
      
      // Store in map
      this.clips.set(state, clipMeta);
      
      if (this.debug) {
        console.log(`Mapped animation: ${clip.name} -> ${this.getStateName(state)}`);
      }
    }
    
    // For any missing essential animations, create default placeholders
    this.createPlaceholderIfMissing(PlayerAnimationState.IDLE);
    this.createPlaceholderIfMissing(PlayerAnimationState.WALKING);
  }
  
  /**
   * Create a placeholder animation if a critical state is missing
   */
  private createPlaceholderIfMissing(state: number): void {
    if (!this.clips.has(state)) {
      if (this.debug) {
        console.warn(`Critical animation state missing: ${this.getStateName(state)}, creating placeholder`);
      }
      
      // Create a dummy clip
      const dummyClip = new THREE.AnimationClip(
        `placeholder_${this.getStateName(state)}`, 
        1, 
        [] // Empty tracks
      );
      
      // Create action from clip
      const action = this.mixer.clipAction(dummyClip);
      
      // Create clip metadata
      const clipMeta: AnimationClipMeta = {
        name: dummyClip.name,
        state: state,
        weight: 0,
        action: action,
        loop: THREE.LoopRepeat,
        clampWhenFinished: false,
        timeScale: 1.0,
        isTransitioning: false
      };
      
      // Configure action
      action.setLoop(clipMeta.loop, Infinity);
      action.clampWhenFinished = clipMeta.clampWhenFinished;
      
      // Store in map
      this.clips.set(state, clipMeta);
    }
  }
  
  /**
   * Get user-friendly name for an animation state
   */
  private getStateName(state: number): string {
    for (const [key, value] of Object.entries(PlayerAnimationState)) {
      if (typeof value === 'number' && value === state) {
        return key;
      }
    }
    return `Unknown(${state})`;
  }
  
  /**
   * Set the current animation state
   * @param state The new state to set
   * @param forceInstant If true, will switch immediately without transition
   * @returns True if state changed, false if same state or invalid state
   */
  setState(state: number, forceInstant: boolean = false): boolean {
    // If same state, do nothing
    if (state === this.activeState) {
      return false;
    }
    
    // Check if the state exists
    if (!this.clips.has(state)) {
      console.warn(`Animation state not available: ${this.getStateName(state)}`);
      
      // Try to use closest available state
      if (state === PlayerAnimationState.FALLING && this.clips.has(PlayerAnimationState.JUMPING)) {
        state = PlayerAnimationState.JUMPING;
      } else if (state === PlayerAnimationState.RUNNING && this.clips.has(PlayerAnimationState.WALKING)) {
        state = PlayerAnimationState.WALKING;
      } else if (state === PlayerAnimationState.JUMPING && this.clips.has(PlayerAnimationState.IDLE)) {
        state = PlayerAnimationState.IDLE;
      } else if (!this.clips.has(PlayerAnimationState.IDLE)) {
        // If we can't even fall back to IDLE, just return
        return false;
      } else {
        // Default fallback to IDLE
        state = PlayerAnimationState.IDLE;
      }
    }
    
    // Store previous state for reference
    this.previousState = this.activeState;
    
    // Get animations
    const prevAnim = this.clips.get(this.previousState);
    const nextAnim = this.clips.get(state);
    
    if (!prevAnim || !nextAnim || !prevAnim.action || !nextAnim.action) {
      console.error(`Invalid animation data for transition from ${this.getStateName(this.previousState)} to ${this.getStateName(state)}`);
      return false;
    }
    
    // Calculate transition time
    let transitionTime = AnimationTransitions.DEFAULT;
    const specificTransitionKey = `${this.previousState}_to_${state}`;
    if (specificTransitionKey in AnimationTransitions) {
      transitionTime = AnimationTransitions[specificTransitionKey as keyof typeof AnimationTransitions];
    }
    
    if (forceInstant) {
      transitionTime = 0;
    }
    
    // Set new active state
    this.activeState = state;
    
    // Handle transition
    if (transitionTime <= 0) {
      // Immediate switch
      prevAnim.action.stop();
      nextAnim.action.play();
      prevAnim.weight = 0;
      nextAnim.weight = 1;
      this.inTransition = false;
    } else {
      // Start crossfade transition
      prevAnim.action.fadeOut(transitionTime);
      nextAnim.action.reset().fadeIn(transitionTime).play();
      
      this.inTransition = true;
      this.transitionTimer = 0;
      this.transitionDuration = transitionTime;
      
      if (this.debug) {
        console.log(`Starting transition: ${this.getStateName(this.previousState)} -> ${this.getStateName(this.activeState)} (${transitionTime}s)`);
      }
    }
    
    return true;
  }
  
  /**
   * Update the animation state machine
   * @param deltaTime Time elapsed since last update in seconds
   */
  update(deltaTime: number): void {
    // Update the animation mixer
    this.mixer.update(deltaTime);
    
    // Update transition state if needed
    if (this.inTransition) {
      this.transitionTimer += deltaTime;
      
      // Calculate progress (0-1)
      const t = Math.min(1.0, this.transitionTimer / this.transitionDuration);
      
      // Get source and target animations
      const prevClip = this.clips.get(this.previousState);
      const nextClip = this.clips.get(this.activeState);
      
      if (prevClip && nextClip && prevClip.action && nextClip.action) {
        // Update weights based on progress
        prevClip.weight = 1.0 - t;
        nextClip.weight = t;
        
        // Apply weights to actions
        prevClip.action.setEffectiveWeight(prevClip.weight);
        nextClip.action.setEffectiveWeight(nextClip.weight);
        
        // Check if transition is complete
        if (t >= 1.0) {
          // Stop the previous animation
          prevClip.action.stop();
          prevClip.weight = 0;
          prevClip.isTransitioning = false;
          
          // Ensure the new animation has full weight
          nextClip.action.setEffectiveWeight(1);
          nextClip.weight = 1;
          nextClip.isTransitioning = false;
          
          // Transition complete
          this.inTransition = false;
          this.transitionTimer = 0;
          
          if (this.debug) {
            console.log(`Transition complete: ${this.getStateName(this.previousState)} -> ${this.getStateName(this.activeState)}`);
          }
        }
      }
    }
    
    // Check for animations that have ended (one-shot animations)
    const currentClip = this.clips.get(this.activeState);
    if (currentClip && currentClip.action && 
        currentClip.loop === THREE.LoopOnce && 
        !this.inTransition &&
        currentClip.action.loop === THREE.LoopOnce &&
        currentClip.action.time >= currentClip.action.getClip().duration) {
      
      // Animation has completed, transition to idle
      if (this.debug) {
        console.log(`One-shot animation completed: ${this.getStateName(this.activeState)}, returning to IDLE`);
      }
      
      this.setState(PlayerAnimationState.IDLE);
    }
  }
  
  /**
   * Get the current animation state
   */
  getState(): number {
    return this.activeState;
  }
  
  /**
   * Get the previous animation state
   */
  getPreviousState(): number {
    return this.previousState;
  }
  
  /**
   * Check if currently in transition between states
   */
  isInTransition(): boolean {
    return this.inTransition;
  }
  
  /**
   * Set the time scale for an animation
   * @param state The animation state to adjust
   * @param timeScale The new time scale (1.0 = normal speed)
   */
  setTimeScale(state: number, timeScale: number): void {
    const clipMeta = this.clips.get(state);
    if (clipMeta && clipMeta.action) {
      clipMeta.timeScale = timeScale;
      clipMeta.action.setEffectiveTimeScale(timeScale);
    }
  }
  
  /**
   * Set the time scale for the current animation
   * @param timeScale The new time scale (1.0 = normal speed)
   */
  setCurrentTimeScale(timeScale: number): void {
    this.setTimeScale(this.activeState, timeScale);
  }
  
  /**
   * Get the animation mixer
   */
  getMixer(): THREE.AnimationMixer {
    return this.mixer;
  }
} 

================================================
File: /src/ecs/systems/player/animationSystem.ts
================================================
/**
 * Player animation system - handles player model loading, animation states and transitions
 */
import { defineQuery } from 'bitecs';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { Player, LocalPlayer, MeshRef, FPController, AnimationState } from '../../components';
import { ECS } from '../../world';
import { MovementState, PlayerAnimationState } from '../../config';
import { AnimationStateMachine } from './animationStateMachine';
import { PlayerSystemConfig } from './index';

export function initPlayerAnimationSystem(world: ECS) {
    // Query for player entities
    const playerQuery = defineQuery([Player, MeshRef, FPController]);
    const localPlayerQuery = defineQuery([LocalPlayer, MeshRef, FPController]);
    
    // Animation variables
    let playerModel: THREE.Group | null = null;
    let animationStateMachine: AnimationStateMachine | null = null;
    
    // Legacy animation system variables (for backward compatibility)
    let mixer: THREE.AnimationMixer | null = null;
    let animations: Map<string, THREE.AnimationAction> = new Map();
    let currentAnimation: string | null = null;
    let activeAction: THREE.AnimationAction | null = null;
    
    // Movement tracking
    let movementState = "idle"; // Current movement state: "idle" or "walking"
    let movementTimer = 0; // Timer to prevent rapid state changes
    let movementBuffer = [false, false, false, false, false]; // Buffer last 5 movement samples
    let bufferIndex = 0;
    
    // Regular check to ensure animation is playing
    let animationCheckTimer = 0;
    
    // Load player model
    const loader = new GLTFLoader();
    loader.load('/models/playermodel.glb', (gltf) => {
        console.log('Player model loaded:', gltf);
        
        // Store the model for later use
        playerModel = gltf.scene;
        
        // Process the model differently based on camera mode
        if (PlayerSystemConfig.USE_FULLBODY_FPS) {
            // Advanced animation state machine for full-body FPS
            setupFullBodyFPS(gltf);
        } else {
            // Legacy animation system for traditional camera
            setupLegacyAnimations(gltf);
        }
        
        // Add model to scene and player
        if (playerModel) {
            // Scale and position adjustments
            playerModel.scale.set(1, 1, 1);
            
            // Get player entity and attach model to player
            const playerEntities = playerQuery(world);
            if (playerEntities.length > 0) {
                const pid = playerEntities[0];
                const holder = world.ctx.maps.mesh.get(pid);
                
                if (holder) {
                    // Position the model relative to the player's position
                    // Fix: Adjust Y position to prevent sinking into ground
                    playerModel.position.set(0, -0.9, 0);
                    playerModel.rotation.y = Math.PI; // Face the camera by default
                    
                    // Add model to player holder
                    holder.add(playerModel);
                    
                    // Log bone names for debugging/reference
                    console.log("--------- BONE NAMES ---------");
                    playerModel.traverse((object) => {
                        if (object instanceof THREE.Bone) {
                            console.log("Bone:", object.name);
                        }
                    });
                    
                    // Start with idle animation
                    if (PlayerSystemConfig.USE_FULLBODY_FPS) {
                        if (animationStateMachine) {
                            animationStateMachine.setState(PlayerAnimationState.IDLE);
                        }
                    } else {
                        setAnimation("idle");
                    }
                }
            }
        }
    });
    
    // Setup for full-body FPS animation system
    function setupFullBodyFPS(gltf: any) {
        if (!playerModel) return;
        
        // Create the animation state machine
        animationStateMachine = new AnimationStateMachine(
            playerModel,
            gltf.animations,
            true // Enable debug logging
        );
        
        console.log("Full-body FPS animation system initialized");
    }
    
    // Setup for legacy animation system
    function setupLegacyAnimations(gltf: any) {
        if (!playerModel) return;
        
        // Set up animation mixer
        mixer = new THREE.AnimationMixer(playerModel);
        
        // Process animations
        gltf.animations.forEach((clip: THREE.AnimationClip) => {
            // Create actions for each animation clip
            if (mixer) {
                const action = mixer.clipAction(clip);
                
                // Store by name for easier access
                if (clip.name.toLowerCase().includes('idle')) {
                    animations.set('idle', action);
                    console.log(`Animation loaded: ${clip.name} (IDLE)`);
                } else if (clip.name.toLowerCase().includes('walk')) {
                    animations.set('walking', action);
                    console.log(`Animation loaded: ${clip.name} (WALKING)`);
                } else {
                    console.log(`Other animation loaded: ${clip.name}`);
                }
            }
        });
        
        // Configure all animations
        animations.forEach(action => {
            // Ensure animations loop infinitely and never stop
            action.setLoop(THREE.LoopRepeat, Infinity);
            action.clampWhenFinished = false;
            action.timeScale = 1;
            action.setEffectiveWeight(1);
            action.enabled = true;
            
            // Disable automatic deactivation
            action.zeroSlopeAtEnd = false;
            action.zeroSlopeAtStart = false;
        });
        
        console.log("Legacy animation system initialized");
    }
    
    // Simple animation switch without complex crossfading (legacy)
    function setAnimation(state: string) {
        // Only used in legacy animation mode
        if (PlayerSystemConfig.USE_FULLBODY_FPS) return;
        
        // Ignore if we're already in this state or animations not loaded
        if (state === movementState || !animations.has(state === "walking" ? "walking" : "idle")) {
            return;
        }
        
        // Update state
        movementState = state;
        console.log(`Changing animation to ${state}`);
        
        // Get the new animation
        let newAction: THREE.AnimationAction | null = null;
        
        if (state === "walking") {
            const walkAction = animations.get("walking");
            if (walkAction) {
                newAction = walkAction;
            }
        } else {
            const idleAction = animations.get("idle");
            if (idleAction) {
                newAction = idleAction;
            }
        }
        
        // Only proceed if we have a valid action
        if (!newAction) return;
        
        // Fade between animations - smoother transition
        if (activeAction && activeAction !== newAction) {
            // Prepare new action
            newAction.reset();
            newAction.setEffectiveWeight(1);
            newAction.enabled = true;
            newAction.play();
            
            // Fade from current to new
            newAction.crossFadeFrom(activeAction, 0.2, true);
        } else {
            // First animation or direct switch
            newAction.enabled = true;
            newAction.reset();
            newAction.play();
        }
        
        // Update current animation state
        activeAction = newAction;
        currentAnimation = state === "walking" ? "walking" : "idle";
        
        // Set timeout before next state change is allowed
        movementTimer = 0.3; // 300ms debounce
    }
    
    // Ensure an animation is playing (fallback to idle) - legacy
    function ensureAnimationPlaying() {
        // Only used in legacy animation mode
        if (PlayerSystemConfig.USE_FULLBODY_FPS) return;
        
        if (!mixer || !animations.size) return;
        
        // Check if any action is currently running
        let isAnimationActive = false;
        
        // Check if the active action is properly running
        if (activeAction && activeAction.isRunning()) {
            isAnimationActive = true;
        }
        
        if (!isAnimationActive) {
            console.log("No active animation detected, resetting to idle");
            
            // Force idle animation to play
            const idleAction = animations.get("idle");
            if (idleAction) {
                // Stop all potentially paused actions
                mixer.stopAllAction();
                
                // Reset action state
                idleAction.reset();
                idleAction.setEffectiveWeight(1);
                idleAction.enabled = true;
                idleAction.play();
                
                // Update current state
                activeAction = idleAction;
                currentAnimation = "idle";
                movementState = "idle";
            }
        }
    }
    
    // Check if player is moving based on position buffer
    function isPlayerMoving() {
        // Count true values in buffer
        const movingFrames = movementBuffer.filter(moving => moving).length;
        // Consider moving if at least 3 of the last 5 frames showed movement
        return movingFrames >= 3;
    }
    
    // Update animation state based on entity state
    function updateAnimationState(eid: number, isMoving: boolean, isSprinting: boolean) {
        // Use the appropriate animation system based on config
        if (PlayerSystemConfig.USE_FULLBODY_FPS) {
            if (!animationStateMachine) return;
            
            // Determine the appropriate animation state
            let targetState = PlayerAnimationState.IDLE;
            
            // Get the move state (grounded, jumping, falling)
            const moveState = FPController.moveState[eid];
            
            if (moveState === MovementState.JUMPING) {
                targetState = PlayerAnimationState.JUMPING;
            } else if (moveState === MovementState.FALLING) {
                targetState = PlayerAnimationState.FALLING;
            } else {
                // Player is grounded
                if (isMoving) {
                    targetState = isSprinting ? 
                        PlayerAnimationState.RUNNING : 
                        PlayerAnimationState.WALKING;
                } else {
                    targetState = PlayerAnimationState.IDLE;
                }
            }
            
            // Apply the state change
            animationStateMachine.setState(targetState);
            
            // Update the Animation component with the current state
            AnimationState.state[eid] = targetState;
        } else {
            // Legacy animation system
            if (movementTimer <= 0) {
                if (isMoving && movementState !== "walking") {
                    setAnimation("walking");
                } else if (!isMoving && movementState !== "idle") {
                    setAnimation("idle");
                }
            }
        }
    }
    
    return (w: ECS) => {
        // Update timers
        if (movementTimer > 0) {
            movementTimer -= w.time.dt;
        }
        
        // Increment animation check timer
        animationCheckTimer += w.time.dt;
        
        // Update based on animation mode
        if (PlayerSystemConfig.USE_FULLBODY_FPS) {
            // Full-body FPS animation updates
            if (animationStateMachine) {
                animationStateMachine.update(w.time.dt);
            }
        } else {
            // Legacy animation checks and updates
            if (mixer && playerModel) {
                // Check animation state regularly to prevent T-pose
                if (animationCheckTimer > 1.0) { // Check every second
                    ensureAnimationPlaying();
                    animationCheckTimer = 0;
                }
                
                // Update animation mixer
                mixer.update(w.time.dt);
            } else {
                return w; // Skip rest of function if no animations
            }
        }
        
        // Process both player and localPlayer entities
        // In most cases, entities will have both components
        const entities = new Set([...playerQuery(w), ...localPlayerQuery(w)]);
        
        for (const eid of entities) {
            const holder = w.ctx.maps.mesh.get(eid);
            
            if (holder) {
                // Initialize previous position if needed
                if (!w.time.prevPlayerPos) {
                    w.time.prevPlayerPos = new THREE.Vector3(holder.position.x, holder.position.y, holder.position.z);
                    continue; // Skip this frame as we need two positions to compare
                }
                
                // Calculate horizontal movement (ignore Y)
                const deltaX = holder.position.x - w.time.prevPlayerPos.x;
                const deltaZ = holder.position.z - w.time.prevPlayerPos.z;
                const movementSq = deltaX * deltaX + deltaZ * deltaZ;
                
                // Store in moving buffer (true if moving, false if not)
                movementBuffer[bufferIndex] = movementSq > 0.0005;
                bufferIndex = (bufferIndex + 1) % movementBuffer.length;
                
                // Determine movement state
                const isMoving = isPlayerMoving();
                const isSprinting = w.input?.sprint || false;
                
                // Update animation state
                updateAnimationState(eid, isMoving, isSprinting);
                
                // Store current position for next frame
                w.time.prevPlayerPos.set(holder.position.x, holder.position.y, holder.position.z);
            }
        }
        
        return w;
    };
}

================================================
File: /src/ecs/systems/player/controlPanel.ts
================================================
/**
 * Control panel for the FPS full-body camera settings
 */
import { FPSBodySettings } from './fpsBodySystem';
import { PlayerSystemConfig } from './index';

// Settings categories
interface SettingsCategory {
  title: string;
  settings: Setting[];
  expanded: boolean;
}

// Individual setting
interface Setting {
  name: string;
  type: 'slider' | 'checkbox' | 'vector3';
  min?: number;
  max?: number;
  get: () => any;
  set: (val: any) => void;
  step?: number;
  description?: string;
}

export function createControlPanel() {
  // If control panel is disabled, do nothing
  if (!PlayerSystemConfig.SHOW_CONTROL_PANEL) {
    return;
  }
  
  // Check if panel already exists
  if (document.getElementById('fpsControlPanel')) {
    return;
  }
  
  // Create categories of settings
  const categories: SettingsCategory[] = [
    {
      title: 'Camera Positioning',
      expanded: true,
      settings: [
        {
          name: 'Camera Offset X',
          type: 'slider',
          min: -50,
          max: 50,
          step: 1,
          get: () => FPSBodySettings.CAMERA_OFFSET.x,
          set: (val) => FPSBodySettings.CAMERA_OFFSET.x = val,
          description: 'Left/right camera offset from eye position'
        },
        {
          name: 'Camera Offset Y',
          type: 'slider',
          min: -50,
          max: 50,
          step: 1,
          get: () => FPSBodySettings.CAMERA_OFFSET.y,
          set: (val) => FPSBodySettings.CAMERA_OFFSET.y = val,
          description: 'Up/down camera offset from eye position'
        },
        {
          name: 'Camera Offset Z',
          type: 'slider',
          min: -50,
          max: 50,
          step: 1,
          get: () => FPSBodySettings.CAMERA_OFFSET.z,
          set: (val) => FPSBodySettings.CAMERA_OFFSET.z = val,
          description: 'Forward/backward camera offset from eye position'
        }
      ]
    },
    {
      title: 'Debug',
      expanded: true,
      settings: [
        {
          name: 'Debug Visualization',
          type: 'checkbox',
          get: () => FPSBodySettings.DEBUG_VISUALIZATION,
          set: (val) => FPSBodySettings.DEBUG_VISUALIZATION = val,
          description: 'Show helpers for skeleton, bones, etc.'
        }
      ]
    }
  ];
  
  // Create panel container
  const panel = document.createElement('div');
  panel.id = 'fpsControlPanel';
  panel.style.position = 'fixed';
  panel.style.top = '10px';
  panel.style.right = '10px';
  panel.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
  panel.style.color = 'white';
  panel.style.padding = '10px';
  panel.style.borderRadius = '5px';
  panel.style.zIndex = '1000';
  panel.style.width = '300px';
  panel.style.fontFamily = 'Arial, sans-serif';
  panel.style.maxHeight = '80vh';
  panel.style.overflowY = 'auto';
  
  // Header
  const header = document.createElement('div');
  header.textContent = 'FPS Camera Settings';
  header.style.fontWeight = 'bold';
  header.style.marginBottom = '10px';
  header.style.borderBottom = '1px solid #555';
  header.style.paddingBottom = '5px';
  panel.appendChild(header);
  
  // Toggle button to show/hide panel
  const toggleButton = document.createElement('button');
  toggleButton.textContent = 'Hide';
  toggleButton.style.position = 'absolute';
  toggleButton.style.top = '10px';
  toggleButton.style.right = '10px';
  toggleButton.style.backgroundColor = '#555';
  toggleButton.style.border = 'none';
  toggleButton.style.color = 'white';
  toggleButton.style.padding = '2px 5px';
  toggleButton.style.borderRadius = '3px';
  toggleButton.style.cursor = 'pointer';
  panel.appendChild(toggleButton);
  
  // Content container
  const content = document.createElement('div');
  content.id = 'fpsControlPanelContent';
  panel.appendChild(content);
  
  // Toggle panel visibility
  let isPanelVisible = true;
  toggleButton.addEventListener('click', () => {
    isPanelVisible = !isPanelVisible;
    content.style.display = isPanelVisible ? 'block' : 'none';
    toggleButton.textContent = isPanelVisible ? 'Hide' : 'Show';
  });
  
  // Create sections for each category
  categories.forEach(category => {
    const section = document.createElement('div');
    section.style.marginBottom = '15px';
    
    // Category header
    const categoryHeader = document.createElement('div');
    categoryHeader.textContent = category.title;
    categoryHeader.style.fontWeight = 'bold';
    categoryHeader.style.marginBottom = '5px';
    categoryHeader.style.cursor = 'pointer';
    categoryHeader.style.backgroundColor = 'rgba(80, 80, 80, 0.5)';
    categoryHeader.style.padding = '3px 5px';
    categoryHeader.style.borderRadius = '3px';
    section.appendChild(categoryHeader);
    
    // Category content
    const categoryContent = document.createElement('div');
    categoryContent.style.display = category.expanded ? 'block' : 'none';
    categoryContent.style.paddingLeft = '10px';
    section.appendChild(categoryContent);
    
    // Toggle category expansion
    categoryHeader.addEventListener('click', () => {
      category.expanded = !category.expanded;
      categoryContent.style.display = category.expanded ? 'block' : 'none';
    });
    
    // Add each setting
    category.settings.forEach(setting => {
      const settingContainer = document.createElement('div');
      settingContainer.style.marginBottom = '8px';
      
      // Setting label
      const label = document.createElement('div');
      label.textContent = setting.name;
      label.style.marginBottom = '2px';
      settingContainer.appendChild(label);
      
      // Setting tooltip (description)
      if (setting.description) {
        label.title = setting.description;
        label.style.cursor = 'help';
      }
      
      if (setting.type === 'slider') {
        // Create slider container
        const sliderContainer = document.createElement('div');
        sliderContainer.style.display = 'flex';
        sliderContainer.style.alignItems = 'center';
        
        // Slider input
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = setting.min!.toString();
        slider.max = setting.max!.toString();
        slider.step = setting.step?.toString() || '0.01';
        slider.value = setting.get().toString();
        slider.style.flex = '1';
        
        // Value display
        const valueDisplay = document.createElement('span');
        valueDisplay.textContent = Number(slider.value).toFixed(2);
        valueDisplay.style.marginLeft = '10px';
        valueDisplay.style.width = '40px';
        valueDisplay.style.textAlign = 'right';
        
        // Update on input
        slider.addEventListener('input', () => {
          const value = parseFloat(slider.value);
          valueDisplay.textContent = value.toFixed(2);
          setting.set(value);
        });
        
        sliderContainer.appendChild(slider);
        sliderContainer.appendChild(valueDisplay);
        settingContainer.appendChild(sliderContainer);
      } else if (setting.type === 'checkbox') {
        // Create checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = setting.get();
        checkbox.id = `setting_${setting.name.replace(/\s+/g, '_')}`;
        
        // Create label
        const checkLabel = document.createElement('label');
        checkLabel.htmlFor = checkbox.id;
        checkLabel.textContent = `Enable ${setting.name}`;
        checkLabel.style.marginLeft = '5px';
        
        // Update on change
        checkbox.addEventListener('change', () => {
          setting.set(checkbox.checked);
        });
        
        // Add to container
        const checkboxContainer = document.createElement('div');
        checkboxContainer.appendChild(checkbox);
        checkboxContainer.appendChild(checkLabel);
        settingContainer.appendChild(checkboxContainer);
      } else if (setting.type === 'vector3') {
        // Not implemented in this basic control panel
        const notImplemented = document.createElement('div');
        notImplemented.textContent = 'Vector3 controls not implemented';
        notImplemented.style.color = '#aaa';
        notImplemented.style.fontStyle = 'italic';
        notImplemented.style.fontSize = '0.8em';
        settingContainer.appendChild(notImplemented);
      }
      
      categoryContent.appendChild(settingContainer);
    });
    
    content.appendChild(section);
  });
  
  // Reset button
  const resetButton = document.createElement('button');
  resetButton.textContent = 'Reset to Defaults';
  resetButton.style.backgroundColor = '#555';
  resetButton.style.border = 'none';
  resetButton.style.color = 'white';
  resetButton.style.padding = '5px 10px';
  resetButton.style.borderRadius = '3px';
  resetButton.style.cursor = 'pointer';
  resetButton.style.width = '100%';
  resetButton.style.marginTop = '10px';
  
  resetButton.addEventListener('click', () => {
    // Reset settings to defaults
    FPSBodySettings.CAMERA_OFFSET.set(0, 16, 33);
    FPSBodySettings.DEBUG_VISUALIZATION = false;
    
    // Update UI elements with new values
    document.querySelectorAll('#fpsControlPanelContent input').forEach(input => {
      if (input instanceof HTMLInputElement) {
        const containerDiv = input.closest('div')?.parentElement;
        if (!containerDiv) return;
        
        // Find the setting this input corresponds to
        let foundSetting: Setting | undefined;
        for (const category of categories) {
          foundSetting = category.settings.find(s => 
            containerDiv.querySelector('div')?.textContent === s.name
          );
          if (foundSetting) break;
        }
        
        if (foundSetting) {
          if (input.type === 'range') {
            input.value = foundSetting.get().toString();
            const valueDisplay = input.nextElementSibling as HTMLElement;
            if (valueDisplay) {
              valueDisplay.textContent = Number(input.value).toFixed(2);
            }
          } else if (input.type === 'checkbox') {
            input.checked = foundSetting.get();
          }
        }
      }
    });
    
    // Force settings update event
    const refreshEvent = new CustomEvent('fps-settings-changed', { 
      detail: { settings: FPSBodySettings } 
    });
    document.dispatchEvent(refreshEvent);
    
    console.log('FPS Camera settings reset to defaults');
  });
  
  content.appendChild(resetButton);
  
  // Apply button to force refresh settings
  const applyButton = document.createElement('button');
  applyButton.textContent = 'Apply Changes';
  applyButton.style.backgroundColor = '#3a7d34';
  applyButton.style.border = 'none';
  applyButton.style.color = 'white';
  applyButton.style.padding = '5px 10px';
  applyButton.style.borderRadius = '3px';
  applyButton.style.cursor = 'pointer';
  applyButton.style.width = '100%';
  applyButton.style.marginTop = '10px';
  applyButton.style.marginBottom = '5px';
  
  applyButton.addEventListener('click', () => {
    // Force refresh by triggering events
    const refreshEvent = new CustomEvent('fps-settings-changed', { 
      detail: { settings: FPSBodySettings } 
    });
    document.dispatchEvent(refreshEvent);
    console.log('Applied FPS Camera settings');
  });
  
  content.appendChild(applyButton);
  
  // Add panel to document body
  document.body.appendChild(panel);
  
  // Setup event listener for settings changes
  document.addEventListener('fps-settings-changed', () => {
    // This will be used by other systems to react to setting changes
    console.log('FPS settings changed event triggered');
  });
  
  return panel;
} 

================================================
File: /src/ecs/systems/player/fpsBodySystem.ts
================================================
/**
 * Simplified FPS Full Body Camera System
 */
import { defineQuery } from 'bitecs';
import * as THREE from 'three';
import { Player, LocalPlayer, FPController, MeshRef } from '../../components';
import { ECS } from '../../world';

// Simplified settings for FPS body camera system
export const FPSBodySettings = {
  // Camera position relative to head
  CAMERA_OFFSET: new THREE.Vector3(0, 16, 33),
  
  // Debug visualization
  DEBUG_VISUALIZATION: false,
};

export function initFPSBodySystem(world: ECS) {
  // Query for player entities
  const localPlayerQuery = defineQuery([LocalPlayer, FPController, MeshRef]);
  const playerQuery = defineQuery([Player, FPController, MeshRef]);
  
  // Reference objects
  let playerModel: THREE.Group | null = null;
  let skeletonHelper: THREE.SkeletonHelper | null = null;
  let headBone: THREE.Bone | null = null;
  
  // Camera holder
  let cameraHolder: THREE.Object3D | null = null;
  
  // Current state
  let isSetup = false;
  
  // Add event listener for settings changes
  document.addEventListener('fps-settings-changed', () => {
    if (cameraHolder && isSetup) {
      // Update camera position from settings
      cameraHolder.position.copy(FPSBodySettings.CAMERA_OFFSET);
      console.log('FPS camera settings updated');
    }
  });
  
  // Setup function - called when player model is loaded and ready
  function setupFPSBody(w: ECS, playerEntity: number) {
    if (isSetup) return;
    
    const holder = w.ctx.maps.mesh.get(playerEntity);
    if (!holder) return;
    
    // Find the player model
    holder.traverse((child) => {
      if (child.type === 'Group' && child.children.length > 0) {
        playerModel = child as THREE.Group;
      }
    });
    
    if (!playerModel) {
      console.log("Player model not found, waiting...");
      return;
    }
    
    // Create camera holder
    cameraHolder = new THREE.Object3D();
    cameraHolder.name = "fpsBodyCameraHolder";
    
    // Find head bone
    playerModel.traverse((object) => {
      if (object instanceof THREE.Bone) {
        // Find head bone
        if (object.name === 'mixamorigHead') {
          headBone = object;
        }
        
        if (FPSBodySettings.DEBUG_VISUALIZATION) {
          // Add tiny markers to visualize bone positions
          const marker = new THREE.Mesh(
            new THREE.SphereGeometry(0.02, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
          );
          object.add(marker);
        }
      }
    });
    
    // If we found the head bone, set up the camera
    if (headBone) {
      // Attach camera holder to head bone
      headBone.add(cameraHolder);
      
      // Position the camera holder at the eye position
      cameraHolder.position.copy(FPSBodySettings.CAMERA_OFFSET);
      
      // Add skeleton helper for debug visualization
      if (FPSBodySettings.DEBUG_VISUALIZATION && playerModel) {
        skeletonHelper = new THREE.SkeletonHelper(playerModel);
        w.ctx.three.scene.add(skeletonHelper);
      }
      
      // Move camera to the new setup
      w.ctx.three.camera.position.set(0, 0, 0);
      w.ctx.three.camera.rotation.set(0, 0, 0);
      
      // FIX: Rotate camera 180 degrees so it faces forward instead of backward
      const fixRotation = new THREE.Euler(0, Math.PI, 0);
      const fixQuaternion = new THREE.Quaternion().setFromEuler(fixRotation);
      cameraHolder.quaternion.multiply(fixQuaternion);
      
      // Add camera to holder
      cameraHolder.add(w.ctx.three.camera);
      
      // Fix for clipping plane issues - adjust near and far planes
      if (w.ctx.three.camera instanceof THREE.PerspectiveCamera) {
        w.ctx.three.camera.near = 0.1;
        w.ctx.three.camera.far = 10000;
        w.ctx.three.camera.updateProjectionMatrix();
      }
      
      console.log("Simplified FPS Body Camera setup complete!");
      isSetup = true;
    } else {
      console.warn("Head bone not found in the model - cannot setup FPS camera");
    }
  }
  
  // Function to ensure camera remains properly attached to head
  function ensureCameraFixedToHead() {
    if (!isSetup || !headBone || !cameraHolder) return;
    
    // Force update world matrices to ensure correct positioning
    headBone.updateWorldMatrix(true, false);
    
    // Make sure camera holder has the correct offset
    cameraHolder.position.copy(FPSBodySettings.CAMERA_OFFSET);
    
    // Ensure camera is correctly oriented
    cameraHolder.updateMatrixWorld(true);
  }
  
  // Main system function
  return (w: ECS) => {
    // Get entities
    const localEntities = localPlayerQuery(w);
    const entities = localEntities.length > 0 ? localEntities : playerQuery(w);
    
    if (entities.length === 0) return w;
    
    // Just use the first player entity
    const pid = entities[0];
    
    // Setup if not already done
    if (!isSetup) {
      setupFPSBody(w, pid);
      if (!isSetup) return w; // Exit if setup not completed
      
      // Ensure scene has proper render settings
      if (w.ctx.three && w.ctx.three.scene) {
        console.log("Ensuring proper scene setup");
        w.ctx.three.scene.background = new THREE.Color(0x87CEEB); // Sky blue
        
        // Make sure fog is disabled as it can cause visual issues
        w.ctx.three.scene.fog = null;
        
        // Fix for scene renderer
        if (w.ctx.three.renderer) {
          // Enable logarithmic depth buffer to fix z-fighting at large distances
          (w.ctx.three.renderer as any).physicallyCorrectLights = true;
          w.ctx.three.renderer.shadowMap.enabled = true;
          
          // Fix for position shifting with distance from origin
          w.ctx.three.renderer.setPixelRatio(window.devicePixelRatio);
          
          console.log("Enhanced renderer setup complete");
        }
      }
    }
    
    // Ensure camera is correctly positioned
    ensureCameraFixedToHead();
    
    // Update skeleton helper if available
    if (skeletonHelper) {
      skeletonHelper.update();
    }
    
    // Apply player pitch directly to camera
    if (pid !== undefined && FPController.pitch[pid] !== undefined) {
      w.ctx.three.camera.rotation.x = FPController.pitch[pid];
    }
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/player/index.ts
================================================
/**
 * Main player system that initializes and combines movement, look and shoot sub-systems
 */
import { addComponent, addEntity } from 'bitecs';
import * as THREE from 'three';
import {
  MeshRef, Player, LocalPlayer, RigidBodyRef, Transform, FPController, NetworkId, Health, AnimationState
} from '../../components';
import { ECS } from '../../world';
import { MovementState, PlayerAnimationState, PlayerConfig } from '../../config';
import { initPlayerMovementSystem } from './movementSystem';
import { initPlayerLookSystem } from './lookSystem';
import { initPlayerShootSystem } from './shootSystem';
import { initPlayerAnimationSystem } from './animationSystem';
import { initFPSBodySystem } from './fpsBodySystem.js';
import { createControlPanel } from './controlPanel.js';

// Configuration for the player system
export const PlayerSystemConfig = {
  // Flag to enable the full-body FPS camera
  // When false, uses the traditional separate camera/model approach
  USE_FULLBODY_FPS: true,
  
  // Control panel configuration
  SHOW_CONTROL_PANEL: true
};

export function initPlayerSystem(world: ECS) {
  const { rapier, physics, three, maps } = world.ctx;

  /* entity + mesh holder ------------------------------------------- */
  const pid = addEntity(world);
  addComponent(world, Player,       pid);
  addComponent(world, LocalPlayer,  pid); // Local player for network compatibility
  addComponent(world, NetworkId,    pid); // NetworkId for multiplayer
  addComponent(world, Transform,    pid);
  addComponent(world, MeshRef,      pid);
  addComponent(world, RigidBodyRef, pid);
  addComponent(world, FPController, pid);
  addComponent(world, Health,       pid);
  addComponent(world, AnimationState, pid);
  
  // Initialize network components
  NetworkId.id[pid] = 0; // Will be set by server
  Health.current[pid] = PlayerConfig.MAX_HEALTH;
  Health.max[pid] = PlayerConfig.MAX_HEALTH;
  AnimationState.state[pid] = PlayerAnimationState.IDLE;
  
  // Initialize controller state
  FPController.pitch[pid] = 0;
  FPController.vertVel[pid] = 0;
  FPController.moveState[pid] = MovementState.GROUNDED;
  FPController.lastGrounded[pid] = performance.now();
  FPController.lastJump[pid] = 0;
  FPController.lastShot[pid] = 0;
  FPController.jumpRequested[pid] = 0;
  FPController.lastJumpRequest[pid] = 0;

  // Create mesh holder
  const holder = new THREE.Object3D();
  holder.position.set(0, 3, 6);
  three.scene.add(holder);
  maps.mesh.set(pid, holder);

  // Set up camera - different setup depending on camera mode
  if (!PlayerSystemConfig.USE_FULLBODY_FPS) {
    // Traditional setup: camera directly parented to holder
    const cameraOffset = new THREE.Object3D();
    cameraOffset.position.set(0, 1.6, 0); // Eye height of ~1.6m
    holder.add(cameraOffset);
    cameraOffset.add(three.camera);
  } else {
    // For full-body FPS, just add a temporary reference
    // The actual camera setup happens in the FPS body system
    const tempCameraHolder = new THREE.Object3D();
    tempCameraHolder.position.set(0, 1.6, 0);
    holder.add(tempCameraHolder);
    tempCameraHolder.add(three.camera);
  }

  // Initialize Quaternion in Transform component
  const quaternion = new THREE.Quaternion();
  holder.getWorldQuaternion(quaternion);
  Transform.qx[pid] = quaternion.x;
  Transform.qy[pid] = quaternion.y;
  Transform.qz[pid] = quaternion.z;
  Transform.qw[pid] = quaternion.w;

  /* Rapier kinematic capsule --------------------------------------- */
  const rb = physics.createRigidBody(
    rapier.RigidBodyDesc.kinematicPositionBased()
          .setTranslation(holder.position.x, holder.position.y, holder.position.z)
          .setCcdEnabled(true)
  );
  const collider = physics.createCollider(
    rapier.ColliderDesc.capsule(0.9, 0.3).setFriction(0.2), rb
  );

  const kcc = physics.createCharacterController(0.01);
  kcc.setApplyImpulsesToDynamicBodies(true);
  kcc.setUp({ x: 0, y: 1, z: 0 });
  kcc.enableAutostep(0.5, 0.3, true);
  kcc.enableSnapToGround(0.3);

  maps.rb.set(pid, rb);
  RigidBodyRef.id[pid] = rb.handle;
  
  // Store KCC and collider for use in movement system
  world.ctx.kcc = kcc;
  world.ctx.playerCollider = collider;
  
  // Add to entity handle map for collision detection
  if (world.ctx.entityHandleMap) {
    world.ctx.entityHandleMap.set(rb.handle, pid);
  } else {
    world.ctx.entityHandleMap = new Map<number, number>();
    world.ctx.entityHandleMap.set(rb.handle, pid);
  }

  // Initialize sub-systems
  const movementSystem = initPlayerMovementSystem(world);
  const lookSystem = initPlayerLookSystem(world);
  const shootSystem = initPlayerShootSystem(world);
  const animationSystem = initPlayerAnimationSystem(world);
  
  // Initialize FPS body system if enabled
  const fpsBodySystem = PlayerSystemConfig.USE_FULLBODY_FPS ? 
    initFPSBodySystem(world) : null;
  
  // Create control panel for camera settings if enabled
  if (PlayerSystemConfig.SHOW_CONTROL_PANEL) {
    createControlPanel();
  }

  /* Combined system ------------------------------------------------- */
  return (w: ECS) => {
    // Ensure the correct order of system evaluation:
    // 1. Look system (camera rotation)
    // 2. Movement system (uses rotation for movement direction)
    // 3. Shoot system (uses camera direction)
    // 4. Animation system (based on movement state)
    // 5. FPS body system (if enabled, updates camera position/rotation)
    
    lookSystem(w);     // Handle camera rotation first
    movementSystem(w); // Apply movement based on new rotation
    shootSystem(w);    // Handle shooting based on camera direction
    animationSystem(w); // Update animations
    
    // Apply FPS body system if enabled
    if (PlayerSystemConfig.USE_FULLBODY_FPS && fpsBodySystem) {
      fpsBodySystem(w);
    }
    
    return w;
  };
}

================================================
File: /src/ecs/systems/player/lookSystem.ts
================================================
/**
 * Player look system - handles camera movement via mouse input
 */
import { defineQuery } from 'bitecs';
import * as THREE from 'three';
import { Player, LocalPlayer, FPController, Transform } from '../../components';
import { ECS } from '../../world';
import { InputState } from '../input';
import { PlayerConfig } from '../../config';

export function initPlayerLookSystem(_world: ECS) {
  // Query specifically for local player first
  const localPlayerQuery = defineQuery([LocalPlayer, FPController]);
  const playerQuery = defineQuery([Player, FPController]);

  return (w: ECS) => {
    const input = w.input as InputState;

    // Skip if pointer isn't locked
    if (!input.pointerLocked) {
      input.dx = input.dy = 0;
      return w;
    }

    // Process local player entities first, fallback to Player tag if needed
    const localEntities = localPlayerQuery(w);
    const entities = localEntities.length > 0 ? localEntities : playerQuery(w);
    
    for (const eid of entities) {
      // Get the player object that holds the camera
      const holder = w.ctx.maps.mesh.get(eid);
      if (!holder) continue;
      
      // Update horizontal rotation (yaw)
      // CRITICAL FIX: Use negative sign for correct mouse movement direction
      holder.rotation.y = (holder.rotation.y - input.dx * PlayerConfig.MOUSE_SENSITIVITY) % (Math.PI * 2);
      if (holder.rotation.y < 0) holder.rotation.y += Math.PI * 2;

      // Update vertical look (pitch) with clamping
      FPController.pitch[eid] = THREE.MathUtils.clamp(
        FPController.pitch[eid] - input.dy * PlayerConfig.MOUSE_SENSITIVITY, 
        -Math.PI / 2,  // Look up limit
        Math.PI / 2    // Look down limit
      );
      
      // Apply pitch to camera
      const camera = w.ctx.three.camera;
      if (camera) {
        camera.rotation.x = FPController.pitch[eid];
      }
      
      // Update Transform component with the correct rotation values
      // This is critical for network synchronization
      const quaternion = new THREE.Quaternion();
      holder.getWorldQuaternion(quaternion);
      
      // Update ECS components with the current state
      Transform.qx[eid] = quaternion.x;
      Transform.qy[eid] = quaternion.y;
      Transform.qz[eid] = quaternion.z;
      Transform.qw[eid] = quaternion.w;
    }
    
    // Reset mouse deltas
    input.dx = input.dy = 0;
    
    return w;
  };
}

================================================
File: /src/ecs/systems/player/movementSystem.ts
================================================
/**
 * Player movement system - handles movement, jumping, and physics integration
 */
import { defineQuery } from 'bitecs';
import { Player, LocalPlayer, RigidBodyRef, FPController, Transform } from '../../components';
import { ECS } from '../../world';
import { InputState } from '../input';
import { vec2Pool, vec3Pool } from '../../utils/mathUtils';
import { PlayerConfig, MovementState } from '../../config';
import * as THREE from 'three';

export function initPlayerMovementSystem(_world: ECS) {
  // Query for either Player or LocalPlayer entities with required components
  const playerQuery = defineQuery([Player, RigidBodyRef, FPController]);
  const localPlayerQuery = defineQuery([LocalPlayer, RigidBodyRef, FPController]);
  
  // Reused vector objects to avoid allocations
  const dir = vec3Pool.get();
  const horiz = vec2Pool.get();
  
  // Track the previous jump state to require releasing space before jumping again
  let prevJump = false;

  return (w: ECS) => {
    const input = w.input as InputState;
    // Input check removed - initInputSystem is guaranteed to run first
    
    const now = performance.now();
    
    // Process both player and localPlayer entities
    // In most cases, entities will have both components
    const entities = new Set([...playerQuery(w), ...localPlayerQuery(w)]);
    
    for (const eid of entities) {
      const rb = w.ctx.maps.rb.get(eid);
      const kcc = w.ctx.kcc; // Character controller from player init
      const playerCollider = w.ctx.playerCollider;
      
      // Skip if we don't have all required components
      if (!rb || !kcc || !playerCollider) continue;
      
      // Get the player mesh holder
      const holder = w.ctx.maps.mesh.get(eid);
      if (!holder) continue;
      
      /* movement state + gravity ------------------------------------- */
      const grounded = kcc.computedGrounded();
      if (grounded) FPController.lastGrounded[eid] = now;

      if (grounded) {
        FPController.moveState[eid] = MovementState.GROUNDED;
      } else {
        FPController.moveState[eid] = FPController.vertVel[eid] > 0 ? 
          MovementState.JUMPING : MovementState.FALLING;
      }
      
      // Handle jump buffering - store jump request timing
      // Only allow a new jump request if space was released since last jump
      const jumpPressed = input.jump && !prevJump;
      if (jumpPressed && FPController.jumpRequested[eid] === 0) {
        FPController.jumpRequested[eid] = 1;
        FPController.lastJumpRequest[eid] = now;
      } else if (!input.jump) {
        FPController.jumpRequested[eid] = 0;
      }

      // Check if we can jump with either direct input or buffered input
      const canJump = (grounded || now - FPController.lastGrounded[eid] < PlayerConfig.COYOTE_MS) && 
                      now - FPController.lastJump[eid] > PlayerConfig.JUMP_CD_MS;
      
      // Execute jump if conditions met, including buffered jumps
      if (canJump && (jumpPressed || (now - FPController.lastJumpRequest[eid] < PlayerConfig.JUMP_BUFFER_MS))) {
        FPController.vertVel[eid] = PlayerConfig.JUMP_VEL;
        FPController.lastJump[eid] = now;
        FPController.jumpRequested[eid] = 0;
      }

      // Store previous jump state for next frame
      prevJump = input.jump;

      if (FPController.moveState[eid] !== MovementState.GROUNDED) {
        // Apply gravity with framerate-independent scaling
        FPController.vertVel[eid] = Math.max(
          FPController.vertVel[eid] - PlayerConfig.GRAVITY * w.time.dt, 
          PlayerConfig.TERMINAL_FALL
        );
      } else {
        FPController.vertVel[eid] *= 0.8;
        if (Math.abs(FPController.vertVel[eid]) < 0.1) FPController.vertVel[eid] = 0;
      }

      /* directional input -------------------------------------------- */
      dir.set(
        (input.rt ? 1 : 0) - (input.lf ? 1 : 0),
        0,
        (input.bk ? 1 : 0) - (input.fw ? 1 : 0)
      );
      
      if (dir.lengthSq() > 0) dir.normalize();
      
      // Get a temporary up vector, use it, then release it
      const upVector = vec3Pool.get().set(0, 1, 0);
      dir.applyAxisAngle(upVector, holder.rotation.y);
      vec3Pool.release(upVector);

      // Base speed calculation
      const speed = PlayerConfig.WALK_SPEED *
                    (FPController.moveState[eid] === MovementState.GROUNDED ? 
                      1 : PlayerConfig.AIR_CONTROL) *
                    (input.sprint ? PlayerConfig.SPRINT_FACTOR : 1);

      horiz.set(dir.x * speed, dir.z * speed);

      /* KCC integration ---------------------------------------------- */
      // Always scale movement by delta time for frame independence
      const dt = w.time.shouldRunPhysics ? w.time.fixedDt! : w.time.dt;
      
      const requested = {
        x: horiz.x * dt,
        y: FPController.vertVel[eid] * dt,
        z: horiz.y * dt
      };
      
      // Now safe to use playerCollider since we checked it above
      kcc.computeColliderMovement(playerCollider, requested);
      const actual = kcc.computedMovement();

      if (FPController.vertVel[eid] > 0 && actual.y < requested.y * 0.9) {
        FPController.vertVel[eid] = 0; // head hit
      }

      const p = rb.translation();
      rb.setNextKinematicTranslation({
        x: p.x + actual.x,
        y: p.y + actual.y,
        z: p.z + actual.z
      });
      
      holder.position.set(p.x + actual.x, p.y + actual.y, p.z + actual.z);
      
      // Update the Transform component for network sync
      Transform.x[eid] = holder.position.x;
      Transform.y[eid] = holder.position.y;
      Transform.z[eid] = holder.position.z;
      
      // Update rotation in Transform component for network sync
      const quaternion = new THREE.Quaternion();
      holder.getWorldQuaternion(quaternion);
      Transform.qx[eid] = quaternion.x;
      Transform.qy[eid] = quaternion.y;
      Transform.qz[eid] = quaternion.z;
      Transform.qw[eid] = quaternion.w;
    }
    
    return w;
  };
}

================================================
File: /src/ecs/systems/player/shootSystem.ts
================================================
import { defineQuery, hasComponent, addEntity, addComponent } from 'bitecs';
import * as THREE from 'three';
import { Player, LocalPlayer, FPController, Transform, Projectile, Lifespan, MeshRef, Velocity, RigidBodyRef } from '../../components'; // Import required components
import { ECS } from '../../world';
import { InputState } from '../input';
import { WeaponConfig } from '../../config';
import { vec3Pool } from '../../utils/mathUtils'; // Keep for direction calculation

// Removed playerQuery, system now receives eid
// const playerQuery = defineQuery([LocalPlayer, FPController]);

// Server now dictates shoot cooldown, but we keep local tracking for client-side feedback
let prevShoot = false;
let lastShotTime = 0; // Client-side visual feedback delay

export function initPlayerShootSystem(_world: ECS) {
    // Query for either Player or LocalPlayer entities with FPController
    const playerQuery = defineQuery([Player, FPController]);
    const localPlayerQuery = defineQuery([LocalPlayer, FPController]);
    
    // Keep track of the last shooting state to detect button press
    let prevShoot = false;

    return (w: ECS) => {
        const input = w.input as InputState;
        if (!input) return w;

        const now = performance.now();

        // Process both player and localPlayer entities
        // In most cases, entities will have both components
        const entities = new Set([...playerQuery(w), ...localPlayerQuery(w)]);

        for (const eid of entities) {
            // Get player object
            const holder = w.ctx.maps.mesh.get(eid);
            if (!holder) continue;
            
            // Only shoot on button press (not held)
            const shootPressed = input.shoot && !prevShoot;
            
            // Check cooldown - lastShot is stored in player component
            if (shootPressed && now - FPController.lastShot[eid] > WeaponConfig.SHOOT_CD_MS) {
                spawnBullet(w, w.ctx.three.camera, w.ctx.rapier);
                FPController.lastShot[eid] = now;
            }
        }
        
        // Update previous button state
        prevShoot = input.shoot;
        
        return w;
    };
}

// Bullet spawn helper function
function spawnBullet(
    w: ECS, camera: THREE.Camera,
    R: typeof import('@dimforge/rapier3d-compat')
) {
    const { physics, maps } = w.ctx;

    const eid = addEntity(w);
    addComponent(w, Projectile,   eid);
    addComponent(w, Lifespan,     eid);
    addComponent(w, RigidBodyRef, eid);
    addComponent(w, MeshRef,      eid);
    addComponent(w, Transform,    eid);
    addComponent(w, Velocity,     eid);

    Lifespan.ttl[eid]  = WeaponConfig.BULLET_TTL_MS;
    Lifespan.born[eid] = performance.now();

    /* mesh */
    const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(0.1, 8, 8),
        new THREE.MeshStandardMaterial({
            color: 0xff9900, roughness: 0.3, metalness: 0.7,
            emissive: 0xff9900, emissiveIntensity: 0.5
        })
    );
    mesh.castShadow = true;

    // Get direction from camera (reuse vectors)
    const dir = vec3Pool.get();
    camera.getWorldDirection(dir).normalize();
    
    // Get spawn position (reuse vectors)
    const spawn = vec3Pool.get();
    camera.getWorldPosition(spawn).addScaledVector(dir, WeaponConfig.BULLET_SPAWN_DISTANCE);
    
    // Apply to mesh
    mesh.position.copy(spawn);

    // Add to scene
    w.ctx.three.scene.add(mesh);
    maps.mesh.set(eid, mesh);

    /* rigid body */
    // Store velocity for client-side prediction
    Velocity.x[eid] = dir.x * WeaponConfig.BULLET_SPEED;
    Velocity.y[eid] = dir.y * WeaponConfig.BULLET_SPEED;
    Velocity.z[eid] = dir.z * WeaponConfig.BULLET_SPEED;

    // Create a rigid body with CCD enabled to prevent tunneling at high speeds
    const rb = physics.createRigidBody(
        R.RigidBodyDesc.dynamic()
            .setTranslation(spawn.x, spawn.y, spawn.z)
            .setCcdEnabled(true)
            .setLinvel(dir.x * WeaponConfig.BULLET_SPEED, 
                      dir.y * WeaponConfig.BULLET_SPEED, 
                      dir.z * WeaponConfig.BULLET_SPEED)
    );

    // Create a small spherical collider
    physics.createCollider(
        R.ColliderDesc.ball(0.1)
            .setDensity(2.0)
            .setFriction(0.0)
            .setRestitution(0.2),
        rb
    );

    maps.rb.set(eid, rb);
    RigidBodyRef.id[eid] = rb.handle;
    
    // Add to entity handle map for collision detection
    if (w.ctx.entityHandleMap) {
        w.ctx.entityHandleMap.set(rb.handle, eid);
    }
    
    // Release pooled vectors
    vec3Pool.release(dir);
    vec3Pool.release(spawn);
}

/**
 * Creates a physics-based projectile for remote player shots
 * Used by network system when receiving shot events from other players
 */
export function createVisualProjectile(world: ECS, position: THREE.Vector3, direction: THREE.Vector3, color = 0x00aaff): number {
    const eid = addEntity(world);
    addComponent(world, Projectile, eid);
    addComponent(world, Lifespan, eid);
    addComponent(world, MeshRef, eid);
    addComponent(world, Transform, eid);
    addComponent(world, Velocity, eid);
    
    Lifespan.ttl[eid] = WeaponConfig.BULLET_TTL_MS;
    Lifespan.born[eid] = performance.now();
    
    Transform.x[eid] = position.x;
    Transform.y[eid] = position.y;
    Transform.z[eid] = position.z;
    Transform.qx[eid] = 0; Transform.qy[eid] = 0; Transform.qz[eid] = 0; Transform.qw[eid] = 1;
    
    Velocity.x[eid] = direction.x * WeaponConfig.BULLET_SPEED;
    Velocity.y[eid] = direction.y * WeaponConfig.BULLET_SPEED;
    Velocity.z[eid] = direction.z * WeaponConfig.BULLET_SPEED;
    
    const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 8, 8),
        new THREE.MeshBasicMaterial({ color })
    );
    mesh.position.copy(position);
    world.ctx.three.scene.add(mesh);
    world.ctx.maps.mesh.set(eid, mesh);
    
    return eid;
}

================================================
File: /src/ecs/systems/projectile.ts
================================================
import { defineQuery, hasComponent, removeEntity } from 'bitecs';
import { Lifespan, Projectile, Velocity, Transform, MeshRef, RigidBodyRef } from '../components';
import { ECS } from '../world';
import * as THREE from 'three';

export function initProjectileSystem(_world: ECS) {
  // Query for all projectiles, whether physics-based or visual-only
  const projectileQuery = defineQuery([Projectile, Lifespan]);
  
  // Separate query for visual-only projectiles (those without RigidBody)
  const visualProjectileQuery = defineQuery([Projectile, Lifespan, Velocity, Transform, MeshRef]);
  const physicsProjectileQuery = defineQuery([Projectile, Lifespan, RigidBodyRef]);

  return (w: ECS) => {
    const now = performance.now();
    const delta = w.time.dt; // Use world delta time

    const entitiesToRemove: number[] = [];

    // First update visual-only projectiles with simple kinematic movement
    for (const eid of visualProjectileQuery(w)) {
      // Skip if entity already has a RigidBody (will be handled by physics system)
      if (hasComponent(w, RigidBodyRef, eid)) continue;
      
      // --- Simple Kinematic Movement ---
      Transform.x[eid] += Velocity.x[eid] * delta;
      Transform.y[eid] += Velocity.y[eid] * delta;
      Transform.z[eid] += Velocity.z[eid] * delta;

      // Sync mesh position with Transform
      const mesh = w.ctx.maps.mesh.get(eid);
      if (mesh) {
        mesh.position.set(Transform.x[eid], Transform.y[eid], Transform.z[eid]);
      }
    }

    // Check all projectiles for lifespan and deletion flags
    for (const eid of projectileQuery(w)) {
      // --- Check Lifespan ---
      if (now - Lifespan.born[eid] > Lifespan.ttl[eid]) {
        entitiesToRemove.push(eid);
        continue;
      }

      // --- Check for Deletion Flag (from collision detection) ---
      const mesh = w.ctx.maps.mesh.get(eid);
      if (mesh?.userData?.markedForDeletion === true) {
        if (!entitiesToRemove.includes(eid)) { // Avoid duplicates
          entitiesToRemove.push(eid);
        }
      }
    }

    // --- Remove Entities ---
    for (const eid of entitiesToRemove) {
      // Get and remove the mesh
      const mesh = w.ctx.maps.mesh.get(eid);
      if (mesh) {
        w.ctx.three.scene.remove(mesh);
        if (mesh instanceof THREE.Mesh) {
          mesh.geometry?.dispose();
          if (mesh.material) {
            if (Array.isArray(mesh.material)) {
              mesh.material.forEach(material => material?.dispose());
            } else {
              mesh.material.dispose();
            }
          }
        }
        w.ctx.maps.mesh.delete(eid);
      }

      // Remove Rapier body if it exists
      const rb = w.ctx.maps.rb.get(eid);
      if (rb) {
        w.ctx.physics.removeRigidBody(rb);
        w.ctx.maps.rb.delete(eid);
        
        // Also remove from entity handle map if it exists
        if (w.ctx.entityHandleMap) {
          // Search for this entity's handle
          for (const [handle, entityId] of w.ctx.entityHandleMap.entries()) {
            if (entityId === eid) {
              w.ctx.entityHandleMap.delete(handle);
              break;
            }
          }
        }
      }

      // Remove the entity if it still exists
      if (hasComponent(w, Projectile, eid)) {
        removeEntity(w, eid);
      }
    }

    return w;
  };
}

================================================
File: /src/ecs/systems/renderSync.ts
================================================
import { defineQuery, hasComponent, exitQuery } from 'bitecs';
import { ECS } from '../world';
import {
  MeshRef, RigidBodyRef, Transform, LocalPlayer, RemotePlayer, InterpolationTarget, Player, FPController
} from '../components';
import { vec3Pool, quatPool, interpolatePositions, interpolateRotations } from '../utils/mathUtils';
import * as THREE from 'three'; // Import THREE

export function initRenderSyncSystem(_world: ECS) {
    const localPlayerQuery = defineQuery([LocalPlayer, MeshRef, RigidBodyRef, Transform, FPController]);
    const remotePlayerQuery = defineQuery([RemotePlayer, MeshRef, InterpolationTarget, Transform]); // Remote players use InterpolationTarget & Transform
    const otherRbQuery = defineQuery([MeshRef, RigidBodyRef]); // Query for non-player rigid bodies
    const allMeshQuery = defineQuery([MeshRef]); // For cleanup

    const exitMeshQuery = exitQuery(allMeshQuery);

    // Storage for interpolation - keyed by Entity ID
    const interpolationData = new Map<number, {
        prevPos: THREE.Vector3;
        prevRot: THREE.Quaternion;
        prevTimestamp: number;
    }>();

    // Reusable THREE objects
    const currentPos = new THREE.Vector3();
    const currentRot = new THREE.Quaternion();
    const targetPos = new THREE.Vector3();
    const targetRot = new THREE.Quaternion();


    return (w: ECS) => {
        const now = Date.now(); // Current render time

        // --- Cleanup exited entities ---
        for (const eid of exitMeshQuery(w)) {
            interpolationData.delete(eid);
            // Note: Mesh and RB removal is handled elsewhere (e.g., projectileSystem, networkSystem)
        }

        // --- Sync Local Player ---
        // Local player's visual mesh should follow the *kinematic* rigid body
        const localPlayers = localPlayerQuery(w);
        if (localPlayers.length > 0) {
            const eid = localPlayers[0];
            const mesh = w.ctx.maps.mesh.get(eid)!;
            const rb = w.ctx.maps.rb.get(eid);
            if (mesh && rb) {
                 // Get current physics translation (position)
                 const p = rb.translation();
                 
                 // CRITICAL FIX: Only update the position from physics
                 // Do NOT update the rotation - lookSystem handles this
                 mesh.position.set(p.x, p.y, p.z);
                 
                 // Update Transform position components
                 Transform.x[eid] = p.x;
                 Transform.y[eid] = p.y;
                 Transform.z[eid] = p.z;
                 
                 // Transform rotation components should be updated by lookSystem
                 // DO NOT update Transform rotation components here
            }
        }


        // --- Sync and Interpolate Remote Players ---
        const remoteEntities = remotePlayerQuery(w);
        for (const eid of remoteEntities) {
            const mesh = w.ctx.maps.mesh.get(eid)!;
            if (!mesh) continue;

            // Get target state from InterpolationTarget component
            targetPos.set(InterpolationTarget.targetX[eid], InterpolationTarget.targetY[eid], InterpolationTarget.targetZ[eid]);
            targetRot.set(InterpolationTarget.targetQX[eid], InterpolationTarget.targetQY[eid], InterpolationTarget.targetQZ[eid], InterpolationTarget.targetQW[eid]);
            const targetTimestamp = InterpolationTarget.timestamp[eid];

             // Get current state from Transform component (this is the *visual* state)
             currentPos.set(Transform.x[eid], Transform.y[eid], Transform.z[eid]);
             currentRot.set(Transform.qx[eid], Transform.qy[eid], Transform.qz[eid], Transform.qw[eid]);


            // Simple Lerp for now - replace with time-based interpolation later
            const lerpFactor = 0.2; // Adjust for smoothness
            currentPos.lerp(targetPos, lerpFactor);
            
            // Use slower slerp for rotation to avoid jitter
            const rotLerpFactor = 0.15;
            currentRot.slerp(targetRot, rotLerpFactor);


            // Update the Transform component with the interpolated visual state
            Transform.x[eid] = currentPos.x;
            Transform.y[eid] = currentPos.y;
            Transform.z[eid] = currentPos.z;
            Transform.qx[eid] = currentRot.x;
            Transform.qy[eid] = currentRot.y;
            Transform.qz[eid] = currentRot.z;
            Transform.qw[eid] = currentRot.w;

            // Apply interpolated state to the mesh
            mesh.position.copy(currentPos);
            mesh.quaternion.copy(currentRot);

             // Update animation mixer if it exists on the mesh
             const animData = mesh.userData; // Assuming mixer is stored in userData
             if (animData?.mixer) {
                 animData.mixer.update(w.time.dt);
             }
        }


        // --- Sync Other Rigid Bodies (Cubes, etc.) ---
        const otherRbEntities = otherRbQuery(w);
        for (const eid of otherRbEntities) {
            // Skip if it's a player (handled above)
            if (hasComponent(w, LocalPlayer, eid) || hasComponent(w, RemotePlayer, eid) || hasComponent(w, Player, eid)) continue;

            const mesh = w.ctx.maps.mesh.get(eid)!;
            const rb = w.ctx.maps.rb.get(eid);
            if (!mesh || !rb) continue;

             // Read directly from Rapier body for dynamic objects
             const p = rb.translation();
             const r = rb.rotation();

             // Apply directly to mesh (or use interpolation if desired)
             mesh.position.set(p.x, p.y, p.z);
             mesh.quaternion.set(r.x, r.y, r.z, r.w);

             // Update Transform component for consistency (optional for non-player RB)
             Transform.x[eid] = p.x; Transform.y[eid] = p.y; Transform.z[eid] = p.z;
             Transform.qx[eid] = r.x; Transform.qy[eid] = r.y; Transform.qz[eid] = r.z; Transform.qw[eid] = r.w;
        }

        // --- Update Transform for non-RB Meshes (if any) ---
         // This part remains the same as before, handling meshes without RBs
         for (const eid of allMeshQuery(w)) {
             if (hasComponent(w, RigidBodyRef, eid) || hasComponent(w, LocalPlayer, eid) || hasComponent(w, RemotePlayer, eid)) continue;

             const mesh = w.ctx.maps.mesh.get(eid)!;
             if (!mesh) continue;

             mesh.getWorldPosition(currentPos);
             mesh.getWorldQuaternion(currentRot);

             Transform.x[eid] = currentPos.x; Transform.y[eid] = currentPos.y; Transform.z[eid] = currentPos.z;
             Transform.qx[eid] = currentRot.x; Transform.qy[eid] = currentRot.y; Transform.qz[eid] = currentRot.z; Transform.qw[eid] = currentRot.w;
         }


        return w;
    };
}

================================================
File: /src/ecs/systems/timeStep.ts
================================================
/**
 * Time step system that manages fixed time steps for physics
 */
import { ECS } from '../world';
import { updateFixedTimestep } from '../timeUtils';
import { TimeStepConfig } from '../config';

// Fixed timestep configuration constants are now directly imported from TimeStepConfig

export function initTimeStepSystem(_world: ECS) {
  return (w: ECS) => {
    // Calculate delta time in seconds
    const now = performance.now();
    // Use a minimum delta time to prevent tiny stutters during fast displays
    const dt = Math.max(TimeStepConfig.MIN_DT, (now - w.time.then) * 0.001); // Convert ms to seconds
    w.time.then = now;
    w.time.dt = dt;
    
    // Update fixed timestep values
    updateFixedTimestep(w, dt);
    
    return w;
  };
} 

================================================
File: /src/ecs/timeUtils.ts
================================================
/**
 * Time utilities for managing fixed timestep and frame timing
 */
import { ECS } from './world';
import { TimeStepConfig } from './config';

/**
 * Update time accumulator and calculate physics steps
 */
export function updateFixedTimestep(world: ECS, deltaTime: number): void {
  // Cap deltaTime to prevent jumps after pauses/tab switches
  const dt = Math.min(deltaTime, TimeStepConfig.MAX_FRAME_TIME);
  
  // Add to accumulator
  world.time.accumulator += dt;
  
  // Calculate how many physics steps to take
  const steps = Math.floor(world.time.accumulator / TimeStepConfig.FIXED_DT);
  const clampedSteps = Math.min(steps, TimeStepConfig.MAX_STEPS);
  
  // Store in world time
  world.time.shouldRunPhysics = clampedSteps > 0;
  world.time.physicsSteps = clampedSteps;
  world.time.fixedDt = TimeStepConfig.FIXED_DT;
  
  // Calculate interpolation alpha
  if (steps > 0) {
    world.time.accumulator -= clampedSteps * TimeStepConfig.FIXED_DT;
    world.time.alpha = world.time.accumulator / TimeStepConfig.FIXED_DT;
  } else {
    world.time.alpha = 0;
  }
} 

================================================
File: /src/ecs/utils/eventUtils.ts
================================================
/**
 * Event utility functions for proper listener management
 */

// Track attached listeners for cleanup
const attachedListeners: Array<{
  target: EventTarget;
  type: string;
  listener: EventListenerOrEventListenerObject;
  options?: boolean | AddEventListenerOptions;
}> = [];

/**
 * Safely attach an event listener with tracking for easy cleanup
 * @param target The EventTarget to attach to (window, document, etc.)
 * @param type Event type (click, keydown, etc.)
 * @param listener The event listener function
 * @param options Optional addEventListener options
 */
export function safeAddEventListener(
  target: EventTarget,
  type: string,
  listener: EventListenerOrEventListenerObject,
  options?: boolean | AddEventListenerOptions
): void {
  target.addEventListener(type, listener, options);
  attachedListeners.push({ target, type, listener, options });
}

/**
 * Remove all previously attached event listeners
 */
export function removeAllEventListeners(): void {
  for (const { target, type, listener, options } of attachedListeners) {
    target.removeEventListener(type, listener, options);
  }
  attachedListeners.length = 0;
}

/**
 * Setup handlers to clean up event listeners on page unload
 */
export function setupEventCleanup(): void {
  // Only set up once
  if ((window as any).__eventCleanupInitialized) return;
  
  window.addEventListener('beforeunload', removeAllEventListeners);
  (window as any).__eventCleanupInitialized = true;
} 

================================================
File: /src/ecs/utils/mathUtils.ts
================================================
/**
 * Math utilities including vector/quaternion pooling
 */
import * as THREE from 'three';

// Default pool size configuration
export const ObjectPoolConfig = {
  INITIAL_SIZE: 20  // Reduced from 50 to conserve memory
};

// A simple vector/quaternion pool to avoid allocations
class ObjectPool<T> {
  private pool: T[] = [];
  private createFn: () => T;
  private resetFn: (obj: T) => void;
  
  constructor(createFn: () => T, resetFn: (obj: T) => void, initialSize = ObjectPoolConfig.INITIAL_SIZE) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    
    // Pre-allocate initial pool
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn());
    }
  }
  
  get(): T {
    if (this.pool.length === 0) {
      return this.createFn();
    }
    return this.pool.pop()!;
  }
  
  release(obj: T): void {
    this.resetFn(obj);
    this.pool.push(obj);
  }
}

// Vector3 pool
export const vec3Pool = new ObjectPool<THREE.Vector3>(
  () => new THREE.Vector3(),
  (v) => v.set(0, 0, 0)
);

// Quaternion pool
export const quatPool = new ObjectPool<THREE.Quaternion>(
  () => new THREE.Quaternion(),
  (q) => q.set(0, 0, 0, 1)
);

// Euler pool
export const eulerPool = new ObjectPool<THREE.Euler>(
  () => new THREE.Euler(),
  (e) => e.set(0, 0, 0)
);

// Vector2 pool
export const vec2Pool = new ObjectPool<THREE.Vector2>(
  () => new THREE.Vector2(),
  (v) => v.set(0, 0)
);

// Interpolation helpers
export function interpolatePositions(
  dest: THREE.Vector3,
  prev: THREE.Vector3, 
  current: THREE.Vector3, 
  alpha: number
): THREE.Vector3 {
  return dest.lerpVectors(prev, current, alpha);
}

export function interpolateRotations(
  dest: THREE.Quaternion,
  prev: THREE.Quaternion, 
  current: THREE.Quaternion, 
  alpha: number
): THREE.Quaternion {
  return dest.slerpQuaternions(prev, current, alpha);
}

// Convert numeric tuple to BigInt64 for use as map key
export function createEntityPairKey(a: number, b: number): bigint {
  // Ensure a < b to make the key consistent regardless of order
  if (a > b) [a, b] = [b, a];
  
  // Convert to BigInt and combine into single 64-bit value
  // This allows for efficient storage without string conversions
  return (BigInt(a) << 32n) | BigInt(b & 0xFFFFFFFF);
}

/**
 * Get direction vector from one point to another
 * @param fromPos Starting position
 * @param toPos Target position
 * @param outVec Optional output vector (if not provided, one will be pooled)
 * @returns Normalized direction vector (caller must vec3Pool.release(outVec) when done)
 */
export function directionFromTo(
  fromPos: { x: number, y: number, z: number },
  toPos: { x: number, y: number, z: number },
  outVec = vec3Pool.get()
): THREE.Vector3 {
  return outVec.set(
    toPos.x - fromPos.x,
    toPos.y - fromPos.y,
    toPos.z - fromPos.z
  ).normalize();
} 

================================================
File: /src/ecs/world.ts
================================================
import { createWorld, pipe, IWorld } from 'bitecs';
import { initInputSystem, InputState } from './systems/input';
import { initPlayerSystem }    from './systems/player';
import { initProjectileSystem }from './systems/projectile';
import { initPhysicsSystem }   from './systems/physics';
import { initRenderSyncSystem }from './systems/renderSync';
import { initDebugVisSystem }  from './systems/debugVis';
import { initCollisionSystem } from './systems/collision';
import { initTimeStepSystem }  from './systems/timeStep';
import { initGrassSystem }     from './systems/grass';
import { initNetworkSystem, NetworkState } from './systems/network/client'; // Import network system
import { initHealthSystem } from './systems/healthSystem'; // Import health system
import * as THREE from 'three';
import type * as RAPIER from '@dimforge/rapier3d-compat';

export function createECS(ctx: ECSContext) {
  const world = createWorld() as ECS;
  world.ctx  = ctx;
  world.time = {
    dt: 0,
    then: performance.now(),
    accumulator: 0
  };
  world.network = { // Initialize network state
      connected: false,
      connecting: false,
      socket: null,
      messageQueue: [],
      pendingUpdates: new Map(),
      lastSentTime: 0,
      lastPingTime: 0
  };
  world.players = new Map(); // Map NetworkId -> EntityId

  // Create Rapier event queue if not already done in scene context creation
  if (!ctx.eventQueue) {
    ctx.eventQueue = new ctx.rapier.EventQueue(true);
  }

  const pipeline = pipe(
    initTimeStepSystem(world),
    initInputSystem(world),
    initNetworkSystem(world),   // Network system runs early to process incoming messages
    initPlayerSystem(world),
    initPhysicsSystem(world),
    initCollisionSystem(world), // Keep for non-player collisions (e.g., projectile-cube)
    initProjectileSystem(world),// Manages visual lifetime of local/remote projectiles
    initHealthSystem(world),    // Handles health updates and death/respawn events
    initGrassSystem(world),
    initDebugVisSystem(world),
    initRenderSyncSystem(world) // Render sync runs last
  );

  return { world, pipeline };
}

/* Types shared with scene & systems */
export interface ECSContext {
  rapier: typeof RAPIER;
  physics: RAPIER.World;
  three: {
    scene: THREE.Scene;
    camera: THREE.Camera;
    renderer: THREE.WebGLRenderer;
  };
  maps: {
    rb: Map<number, RAPIER.RigidBody>; // EntityId -> RigidBody
    mesh: Map<number, THREE.Object3D>; // EntityId -> Mesh
  };
  eventQueue?: RAPIER.EventQueue;
  kcc?: RAPIER.KinematicCharacterController;
  playerCollider?: RAPIER.Collider;
  entityHandleMap?: Map<number, number>; // RB Handle -> EntityId
  localPlayerId: number | null; // Added to store the local player's network ID
}

// Extend IWorld with our custom properties
export interface ECS extends IWorld {
  ctx: ECSContext;
  time: {
    dt: number;
    then: number;
    accumulator: number;
    fixedDt?: number;
    alpha?: number;
    physicsSteps?: number;
    shouldRunPhysics?: boolean;
    prevPlayerPos?: THREE.Vector3;
  };
  input?: InputState;
  network: NetworkState; // Add network state object
  players: Map<number, number>; // Add map for NetworkId -> EntityId mapping
}

================================================
File: /src/gameloop.ts
================================================
/**
 * Game loop module for managing main animation loop
 */
import Stats from 'three/examples/jsm/libs/stats.module.js';
import { ECS } from './ecs/world';

/**
 * Set up stats.js performance monitor
 */
export function setupStats(): Stats {
  const stats = new Stats();
  stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
  stats.dom.style.position = 'absolute';
  stats.dom.style.left = '0px';
  stats.dom.style.top = '0px';
  document.body.appendChild(stats.dom);
  return stats;
}

/**
 * Start the game loop
 */
export function startGameLoop(world: ECS, pipeline: (w: ECS) => ECS): void {
  const stats = setupStats();
  
  // Start animation loop
  const raf = (_t: number) => {
    // Begin stats measurement
    stats.begin();
    
    // Run all systems
    pipeline(world);
    
    // Render the scene
    world.ctx.three.renderer.render(world.ctx.three.scene, world.ctx.three.camera);
    
    // End stats measurement
    stats.end();
    
    // Request next frame
    requestAnimationFrame(raf);
  };
  
  // Start the loop
  requestAnimationFrame(raf);
} 

================================================
File: /src/main.ts
================================================
import * as RAPIER from '@dimforge/rapier3d-compat';
import { createContext, populateScene } from './ecs/scene';
import { createECS } from './ecs/world';
import { startGameLoop } from './gameloop';
import { network } from './ecs/systems/network/client'; // Import network client

const canvas = document.getElementById('c') as HTMLCanvasElement;

async function main() {
  console.log("Initializing Rapier...");
  await RAPIER.init();
  console.log("Rapier initialized.");

  console.log("Creating context...");
  const ctx = await createContext(canvas, RAPIER);
  console.log("Context created.");

  console.log("Creating ECS...");
  const { world, pipeline } = createECS(ctx);
  console.log("ECS created.");

  console.log("Populating scene...");
  populateScene(world, ctx);
  console.log("Scene populated.");

  console.log("Connecting to network...");
  await network.connect(world); // Connect the network client, passing the world
  console.log("Network connection initiated.");

  console.log("Starting game loop...");
  startGameLoop(world, pipeline);
  console.log("Game loop started.");
}

main().catch(error => {
    console.error("Initialization failed:", error);
    // Display a user-friendly error message on the page
    const errorDiv = document.createElement('div');
    errorDiv.style.position = 'fixed';
    errorDiv.style.top = '0';
    errorDiv.style.left = '0';
    errorDiv.style.width = '100%';
    errorDiv.style.padding = '20px';
    errorDiv.style.backgroundColor = 'red';
    errorDiv.style.color = 'white';
    errorDiv.style.textAlign = 'center';
    errorDiv.style.zIndex = '10000';
    errorDiv.textContent = `Fatal Error: Failed to initialize the game. Please check the console for details and try refreshing. Error: ${error.message}`;
    document.body.appendChild(errorDiv);
});

================================================
File: /tsconfig.json
================================================
{
    "compilerOptions": {
      "target": "ES2020",
      "module": "ESNext",
      "lib": ["ES2020", "DOM"],
      "moduleResolution": "Bundler",
      "strict": true,
      "noImplicitReturns": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "skipLibCheck": true,
      "allowImportingTsExtensions": true,
      "noEmit": true,
      "types": ["vite/client"]
    },
    "include": ["src"]
  }
  

================================================
File: /vite.config.ts
================================================
import { defineConfig } from 'vite';
import wasm from 'vite-plugin-wasm';
import topLevelAwait from 'vite-plugin-top-level-await';

export default defineConfig({
  plugins: [wasm(), topLevelAwait()],
  build: { target: 'esnext' },
  server: { host: true }
});
    </codebase>
</context>
