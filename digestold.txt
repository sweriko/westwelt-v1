<goal>
I recently created a bunch of files for a multiplayer integration, and it kinda works, but in the process, I broke a few things and made other worse.
I want you to use this backup of my previous version as reference to fix some of those issues:
-I want the old bullet logic back, I want projectile/rigid body based bullets that correctly interact with the world
-currently, i can only see the opponents playermodel, but not my own anymore, and i can only see the opponents playermodel doing the idle animation, ensure that walking animation flags are broadcasted via the server to other players to do client side processing/applying of the walking animation to that playermodel, also I noticed that the opponents playermodel is wrongly oriented by 180° (model is looking in the opposite direction of where the player actually is looking at), and it also has a y offset, making that playermodel float above the ground
-the playercontroller seems messed up? i cant jump anymore, or the player collider is halfway stuck underground? idk
-in the f12 logs i also see a bunch of these warnings for basically all the bones
""
THREE.PropertyBinding: No target node found for track: mixamorigHips.position. animationSystem.ts:105 
""
</goal>


<context>
   (old) <codebase>
Directory structure:
└── /./
    ├── index.html
    ├── package.json
    ├── public/
    │   ├── models/
    │   │   └── playermodel.glb
    │   └── textures/
    ├── src/
    │   ├── ecs/
    │   │   ├── components/
    │   │   ├── components.ts
    │   │   ├── config.ts
    │   │   ├── scene.ts
    │   │   ├── systems/
    │   │   │   ├── collision.ts
    │   │   │   ├── debugVis.ts
    │   │   │   ├── grass.ts
    │   │   │   ├── input.ts
    │   │   │   ├── network/
    │   │   │   ├── physics.ts
    │   │   │   ├── player/
    │   │   │   │   ├── animationSystem.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── lookSystem.ts
    │   │   │   │   ├── movementSystem.ts
    │   │   │   │   └── shootSystem.ts
    │   │   │   ├── projectile.ts
    │   │   │   ├── renderSync.ts
    │   │   │   └── timeStep.ts
    │   │   ├── timeUtils.ts
    │   │   ├── utils/
    │   │   │   ├── eventUtils.ts
    │   │   │   └── mathUtils.ts
    │   │   └── world.ts
    │   ├── gameloop.ts
    │   └── main.ts
    ├── tsconfig.json
    └── vite.config.ts

================================================
File: /index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Rapier × Three × bitecs starter</title>
  <style>html,body{margin:0;height:100%;overflow:hidden}</style>
</head>
<body>
  <canvas id="c"></canvas>
  <script type="module" src="/src/main.ts"></script>
</body>
</html>


================================================
File: /package.json
================================================
{
  "name": "rapier-three-bitecs-starter",
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@dimforge/rapier3d-compat": "^0.16.1",
    "bitecs": "^0.3.40",
    "three": "^0.176.0"
  },
  "devDependencies": {
    "@types/three": "^0.158.0",
    "typescript": "^5.2.2",
    "vite": "^6.3.1",
    "vite-plugin-top-level-await": "^1.5.0",
    "vite-plugin-wasm": "^3.4.1"
  }
}


================================================
File: /src/ecs/components.ts
================================================
import { Types, defineComponent } from 'bitecs';

/** World-space transform (quat-pos) */
export const Transform = defineComponent({
  x: Types.f32, y: Types.f32, z: Types.f32,
  qx: Types.f32, qy: Types.f32, qz: Types.f32, qw: Types.f32
});

/** Linear velocity – used for projectiles */
export const Velocity = defineComponent({ x: Types.f32, y: Types.f32, z: Types.f32 });

/** TTL in milliseconds (bullets) */
export const Lifespan = defineComponent({ ttl: Types.f32, born: Types.f32 });

/** Debug visualization flag - used to store current debug state */
export const DebugVis = defineComponent({ active: Types.ui8 });

/** First-person controller state */
export const FPController = defineComponent({
  pitch: Types.f32,        // Camera pitch angle
  vertVel: Types.f32,      // Vertical velocity
  moveState: Types.ui8,    // 0=Grounded, 1=Jumping, 2=Falling
  lastGrounded: Types.f32, // Time when last grounded
  lastJump: Types.f32,     // Time when last jumped
  lastShot: Types.f32,     // Time when last shot
  jumpRequested: Types.ui8,// Jump buffer flag
  lastJumpRequest: Types.f32 // Time when jump was requested
});

/** Debug visualization mesh references */
export const DebugMeshRef = defineComponent({ id: Types.ui32 });

/** Trajectory for debug visualization */
export const Trajectory = defineComponent({
  // No data needed, just a tag to indicate an entity has a trajectory
});

/** Collision event data */
export const CollisionEvent = defineComponent({
  entity1: Types.ui32,     // First entity in collision
  entity2: Types.ui32,     // Second entity in collision
  impulse: Types.f32,      // Collision impulse magnitude
  time: Types.f32          // When collision occurred
});

/** Tags */
export const Player   = defineComponent();
export const Projectile = defineComponent();
export const CubeTag  = defineComponent();

/** Foreign-object indirection – store handles in JS Maps */
export const RigidBodyRef = defineComponent({ id: Types.ui32 });
export const MeshRef      = defineComponent({ id: Types.ui32 });


================================================
File: /src/ecs/config.ts
================================================
/**
 * Global configuration values
 */

export const PlayerConfig = {
  // Movement
  WALK_SPEED: 8,
  SPRINT_FACTOR: 1.8,
  AIR_CONTROL: 0.7,
  JUMP_VEL: 14,
  GRAVITY: 20,
  TERMINAL_FALL: -20,
  
  // Timing
  JUMP_CD_MS: 300,
  COYOTE_MS: 150,
  JUMP_BUFFER_MS: 200,
  
  // Look
  MOUSE_SENSITIVITY: 0.0035
};

export const WeaponConfig = {
  SHOOT_CD_MS: 200,
  BULLET_SPEED: 40,
  BULLET_TTL_MS: 5000,
  BULLET_SPAWN_DISTANCE: 1.5
};

export const PhysicsConfig = {
  IMPACT_FORCE: 20.0,
  SOLVER_ITERATIONS: 4,     // More iterations for better stability
  CCD_SUBSTEPS: 4,          // Increase CCD substeps for better bullet collisions
  VELOCITY_THRESHOLD: 30.0  // Velocity magnitude threshold for enabling CCD
};

export const TimeStepConfig = {
  FIXED_DT: 1/60,          // 60Hz physics update
  MAX_STEPS: 5,            // Max physics steps per frame to prevent spiral of death
  MAX_FRAME_TIME: 0.25,    // Maximum time to spend catching up
  MIN_DT: 1/240            // Minimum sensible delta (240Hz)
};

export const SceneConfig = {
  // Ground
  GROUND_COLOR: 0x1a5f2a,
  GROUND_SIZE: 200,
  
  // Sky
  SKY_COLOR: 0x87CEEB,
  
  // Cubes
  CUBE_STACK_SIZE: 6,
  EXTRA_CUBES: 20,
  CUBE_RESTITUTION: 0.4,
  CUBE_FRICTION: 0.5,
  
  // Lighting
  AMBIENT_LIGHT_INTENSITY: 0.8,
  DIRECTIONAL_LIGHT_INTENSITY: 1.0
};

// Movement state enum values
export const MovementState = {
  GROUNDED: 0,
  JUMPING: 1,
  FALLING: 2
}; 

================================================
File: /src/ecs/scene.ts
================================================
/**********************************************************************
 * scene.ts – Three + Rapier initialisation & scene population
 *********************************************************************/
import * as THREE  from 'three';
import { addComponent, addEntity } from 'bitecs';
import {
  CubeTag, MeshRef, RigidBodyRef, Transform
} from './components';
import { ECS, ECSContext } from './world';
import { SceneConfig } from './config';

/* ------------------------------------------------------------------ */
/* createContext – bootstrap renderer / physics / camera              */
export async function createContext(
  canvas: HTMLCanvasElement,
  RAPIER: typeof import('@dimforge/rapier3d-compat')
): Promise<ECSContext> {
  /* Rapier ---------------------------------------------------------- */
  const rapier = RAPIER;
  const physics = new rapier.World({ x: 0, y: -9.81, z: 0 });

  /* Three renderer -------------------------------------------------- */
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type    = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(SceneConfig.SKY_COLOR);
  scene.fog        = new THREE.FogExp2(0x88BBFF, 0.0025);

  const camera = new THREE.PerspectiveCamera(
    75, window.innerWidth / window.innerHeight, 0.1, 1000
  );

  // Set up window resize handler
  setupWindowResize(camera, renderer);

  // Create context object
  const ctx: ECSContext = {
    rapier, physics,
    three: { scene, camera, renderer },
    maps : { mesh: new Map(), rb: new Map() }
  };

  // Set up lighting, sky and ground
  setupLighting(ctx);
  setupSky(ctx);
  setupGround(ctx);

  return ctx;
}

/* ------------------------------------------------------------------ */
/* Helper function to set up window resize handling                   */
function setupWindowResize(camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer) {
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

/* ------------------------------------------------------------------ */
/* Helper function to set up scene lighting                           */
function setupLighting(ctx: ECSContext) {
  const scene = ctx.three.scene;
  
  // Add ambient light
  scene.add(new THREE.AmbientLight(
    0xffffff, SceneConfig.AMBIENT_LIGHT_INTENSITY
  ));

  // Add directional light with shadows
  const dirLight = new THREE.DirectionalLight(
    0xffffff, SceneConfig.DIRECTIONAL_LIGHT_INTENSITY
  );
  dirLight.position.set(5, 10, 7);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.set(2048, 2048);
  dirLight.shadow.camera.left = -20;
  dirLight.shadow.camera.right = 20;
  dirLight.shadow.camera.top = 20;
  dirLight.shadow.camera.bottom = -20;
  dirLight.shadow.camera.near = 0.5;
  dirLight.shadow.camera.far  = 50;
  scene.add(dirLight);
}

/* ------------------------------------------------------------------ */
/* Helper function to create sky dome                                 */
function setupSky(ctx: ECSContext) {
  const scene = ctx.three.scene;
  const sky = new THREE.SphereGeometry(400, 32, 15).scale(-1, 1, 1);
  scene.add(new THREE.Mesh(
    sky, 
    new THREE.MeshBasicMaterial({ 
      color: SceneConfig.SKY_COLOR, 
      side: THREE.BackSide 
    })
  ));
}

/* ------------------------------------------------------------------ */
/* Helper function to create ground plane                             */
function setupGround(ctx: ECSContext) {
  const scene = ctx.three.scene;
  const { rapier, physics } = ctx;
  
  const HALF_H = 0.05;                 // 0.1 m thick collider
  const GROUND_Y = -HALF_H;
  const SIZE = SceneConfig.GROUND_SIZE;

  // Create ground mesh
  const groundMesh = new THREE.Mesh(
    new THREE.PlaneGeometry(SIZE, SIZE).rotateX(-Math.PI / 2),
    new THREE.MeshStandardMaterial({ 
      color: SceneConfig.GROUND_COLOR, 
      roughness: 0.8, 
      metalness: 0.2 
    })
  );
  groundMesh.receiveShadow = true;
  groundMesh.position.y    = GROUND_Y;
  scene.add(groundMesh);

  // Create ground collider
  const groundBody = physics.createRigidBody(
    rapier.RigidBodyDesc.fixed().setTranslation(0, GROUND_Y, 0)
  );
  physics.createCollider(
    rapier.ColliderDesc.cuboid(SIZE/2, HALF_H, SIZE/2), groundBody
  );
}

/* ------------------------------------------------------------------ */
/* populateScene – central cube stack + scattered cubes               */
export function populateScene(world: ECS, ctx: ECSContext): void {
  const { rapier, physics, maps, three } = ctx;
  
  // Create shared geometry and materials for cube factory
  const geometries = new Map<number, THREE.BoxGeometry>();
  const materials = new Map<number, THREE.MeshStandardMaterial>();
  
  // Cube factory function with reused geometries/materials
  const makeCube = (
    x: number, y: number, z: number,
    size = 1, color = Math.random() * 0xffffff
  ) => {
    /* Three mesh ---------------------------------------------------- */
    // Reuse or create geometry
    if (!geometries.has(size)) {
      geometries.set(size, new THREE.BoxGeometry(size, size, size));
    }
    
    // Reuse material if same color (within tolerance) or create new
    let material: THREE.MeshStandardMaterial | undefined;
    for (const [existingColor, existingMaterial] of materials.entries()) {
      // Allow for small color differences (hex representation)
      if (Math.abs(existingColor - color) < 100) {
        material = existingMaterial;
        break;
      }
    }
    
    if (!material) {
      material = new THREE.MeshStandardMaterial({ 
        color, 
        roughness: 0.7, 
        metalness: 0.3 
      });
      materials.set(color, material);
    }
    
    const mesh = new THREE.Mesh(geometries.get(size)!, material);
    mesh.castShadow = mesh.receiveShadow = true;
    mesh.position.set(x, y, z);
    three.scene.add(mesh);

    /* Rapier body --------------------------------------------------- */
    const rb = physics.createRigidBody(
      rapier.RigidBodyDesc.dynamic()
            .setTranslation(x, y, z)
            .setCcdEnabled(true)
    );
    physics.createCollider(
      rapier.ColliderDesc.cuboid((size * 0.98) / 2, (size * 0.98) / 2, (size * 0.98) / 2)
            .setRestitution(SceneConfig.CUBE_RESTITUTION)
            .setFriction(SceneConfig.CUBE_FRICTION),
      rb
    );

    /* ECS entity ---------------------------------------------------- */
    const eid = addEntity(world);
    addComponent(world, CubeTag,     eid);
    addComponent(world, Transform,   eid);
    addComponent(world, MeshRef,     eid);
    addComponent(world, RigidBodyRef,eid);

    maps.mesh.set(eid, mesh);
    maps.rb.set(eid, rb);
    RigidBodyRef.id[eid] = rb.handle;
    
    // Update handle map
    if (world.ctx.entityHandleMap) {
      world.ctx.entityHandleMap.set(rb.handle, eid);
    }
  };

  /* Create cube stacks */
  const stackSize = SceneConfig.CUBE_STACK_SIZE;
  const halfStack = stackSize / 2;
  
  // Make a cube stack
  for (let y = 0; y < stackSize; ++y)
    for (let x = 0; x < stackSize; ++x)
      for (let z = 0; z < stackSize; ++z)
        makeCube(x - halfStack, y + 0.5, z - halfStack);

  /* extra cubes */
  for (let i = 0; i < SceneConfig.EXTRA_CUBES; i++)
    makeCube(
      (Math.random() - 0.5) * 20,
      10 + Math.random() * 10,
      (Math.random() - 0.5) * 20,
      0.5 + Math.random() * 1.5
    );
}


================================================
File: /src/ecs/systems/collision.ts
================================================
import { defineQuery, addComponent, addEntity, hasComponent } from 'bitecs';
import { Projectile, CubeTag, RigidBodyRef, CollisionEvent } from '../components';
import { ECS } from '../world';
import { vec3Pool, createEntityPairKey } from '../utils/mathUtils';
import { PhysicsConfig } from '../config';

export function initCollisionSystem(world: ECS) {
  const projectileQuery = defineQuery([Projectile, RigidBodyRef]);
  const cubeQuery = defineQuery([CubeTag, RigidBodyRef]);
  
  // Last processed collision time to avoid duplicates
  const processedCollisions = new Map<bigint, number>();
  
  // Cache of rigid body handles to entity IDs
  // Initialize entity handle mapping
  if (!world.ctx.entityHandleMap) {
    world.ctx.entityHandleMap = new Map<number, number>();
  }
  
  // Helper to mark entities for deletion outside the hot collision loop
  function markEntityForDeletion(eid: number) {
    const mesh = world.ctx.maps.mesh.get(eid);
    if (mesh) {
      if (!mesh.userData) mesh.userData = {};
      mesh.userData.markedForDeletion = true;
    }
  }
  
  return (w: ECS) => {
    const now = performance.now();
    
    // Clean up old processed collisions (older than 200ms)
    for (const [key, time] of processedCollisions.entries()) {
      if (now - time > 200) {
        processedCollisions.delete(key);
      }
    }
    
    // Skip if no event queue is available
    if (!w.ctx.eventQueue) {
      return w;
    }
    
    // Cache query results once per tick
    const projectiles = projectileQuery(w);
    const cubes = cubeQuery(w);
    
    // Update entity handle map for any new entities
    for (const eid of projectiles) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb && !w.ctx.entityHandleMap!.has(rb.handle)) {
        w.ctx.entityHandleMap!.set(rb.handle, eid);
      }
    }
    
    for (const eid of cubes) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb && !w.ctx.entityHandleMap!.has(rb.handle)) {
        w.ctx.entityHandleMap!.set(rb.handle, eid);
      }
    }
    
    // Process collision events from Rapier physics
    w.ctx.eventQueue.drainCollisionEvents((handle1: number, handle2: number, started: boolean) => {
      // We only care about collision starts
      if (!started) return;
      
      // Get entity IDs from rigid body handles
      const entity1 = w.ctx.entityHandleMap!.get(handle1);
      const entity2 = w.ctx.entityHandleMap!.get(handle2);
      
      if (!entity1 || !entity2) return;
      
      // Use hasComponent for O(1) lookups instead of array.includes()
      const isProjectile1 = hasComponent(w, Projectile, entity1);
      const isProjectile2 = hasComponent(w, Projectile, entity2);
      const isCube1 = hasComponent(w, CubeTag, entity1);
      const isCube2 = hasComponent(w, CubeTag, entity2);
      
      // Skip if not a projectile-cube collision
      if (!((isProjectile1 && isCube2) || (isProjectile2 && isCube1))) {
        return;
      }
      
      // Determine which is which
      const projectileEid = isProjectile1 ? entity1 : entity2;
      const cubeEid = isCube1 ? entity1 : entity2;
      
      // Create a unique ID for this collision using BigInt
      const collisionId = createEntityPairKey(projectileEid, cubeEid);
      
      // Skip if we've already processed this collision recently
      if (processedCollisions.has(collisionId)) return;
      
      // Mark collision as processed
      processedCollisions.set(collisionId, now);
      
      // Get the cube and projectile rigid bodies
      const cubeRB = w.ctx.maps.rb.get(cubeEid);
      const projectileRB = w.ctx.maps.rb.get(projectileEid);
      
      if (!cubeRB || !projectileRB) return;
      
      // Calculate impact direction - from bullet to cube center
      const bulletPos = projectileRB.translation();
      const cubePos = cubeRB.translation();
      
      // Direction vector from bullet to cube center (where to push the cube)
      // Use pooled vector
      const impactDir = vec3Pool.get().set(
        cubePos.x - bulletPos.x,
        cubePos.y - bulletPos.y,
        cubePos.z - bulletPos.z
      ).normalize();
      
      // If direction is zero (e.g., direct center hit), use reversed bullet velocity
      if (impactDir.lengthSq() < 0.001) {
        const vel = projectileRB.linvel();
        impactDir.set(-vel.x, -vel.y, -vel.z).normalize();
      }
      
      // Apply impulse force at contact point in direction from bullet to cube
      cubeRB.applyImpulseAtPoint(
        { 
          x: impactDir.x * PhysicsConfig.IMPACT_FORCE, 
          y: impactDir.y * PhysicsConfig.IMPACT_FORCE, 
          z: impactDir.z * PhysicsConfig.IMPACT_FORCE 
        },
        {
          x: bulletPos.x,
          y: bulletPos.y,
          z: bulletPos.z
        },
        true
      );
      
      // Add some random torque for realistic effect
      cubeRB.applyTorqueImpulse(
        {
          x: (Math.random() - 0.5) * PhysicsConfig.IMPACT_FORCE * 0.3,
          y: (Math.random() - 0.5) * PhysicsConfig.IMPACT_FORCE * 0.3,
          z: (Math.random() - 0.5) * PhysicsConfig.IMPACT_FORCE * 0.3
        },
        true
      );
      
      // Create a collision event entity
      const eventEid = addEntity(w);
      addComponent(w, CollisionEvent, eventEid);
      CollisionEvent.entity1[eventEid] = projectileEid;
      CollisionEvent.entity2[eventEid] = cubeEid;
      CollisionEvent.impulse[eventEid] = PhysicsConfig.IMPACT_FORCE;
      CollisionEvent.time[eventEid] = now;
      
      // Mark projectile for destruction
      markEntityForDeletion(projectileEid);
      
      // Release pooled vector
      vec3Pool.release(impactDir);
    });
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/debugVis.ts
================================================
import { defineQuery } from 'bitecs';
import { DebugVis, Projectile, Player, RigidBodyRef } from '../components';
import { ECS } from '../world';
import * as THREE from 'three';
import { vec3Pool } from '../utils/mathUtils';

// Maximum number of points in trajectory
const MAX_TRAJECTORY_POINTS = 100;

export function initDebugVisSystem(world: ECS) {
  const debugQuery = defineQuery([DebugVis]);
  const playerQuery = defineQuery([Player, RigidBodyRef]);
  const projectileQuery = defineQuery([Projectile, RigidBodyRef]);
  
  // Store trajectory data
  const trajectoryLines = new Map<number, THREE.Line>();
  const trajectories = new Map<number, {
    count: number,  // Current number of points
    maxCount: number  // Maximum capacity
  }>();
  
  // Store pre-allocated buffers to avoid creating new ones each frame
  const positionBuffers = new Map<number, {
    array: Float32Array,
    attribute: THREE.BufferAttribute
  }>();
  
  // Shared line material for all trajectories
  const lineMaterial = new THREE.LineBasicMaterial({ 
    color: 0xff9900, 
    transparent: true, 
    opacity: 0.7 
  });
  
  // Create player capsule mesh for debug
  let playerCapsule: THREE.Mesh | null = null;
  
  // Create a simple cylinder geometry
  const createCylinderGeometry = (radius: number, height: number, widthSegments = 16): THREE.BufferGeometry => {
    // Create cylinder body
    return new THREE.CylinderGeometry(
      radius, radius, height - radius * 2, widthSegments, 1, true
    );
  };
  
  // Initialize the debug capsule and materials
  const wireframeMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    wireframe: true,
    transparent: true,
    opacity: 0.7
  });
  
  // Create the capsule mesh once at initialization
  const capsuleGeometry = createCylinderGeometry(0.3, 1.8, 16);
  playerCapsule = new THREE.Mesh(capsuleGeometry, wireframeMaterial);
  world.ctx.three.scene.add(playerCapsule);
  playerCapsule.visible = false; // Hidden by default
  
  return (w: ECS) => {
    // First check if debug visualization is enabled
    const debugEnts = debugQuery(w);
    const debugId = debugEnts.length > 0 ? debugEnts[0] : -1;
    const debugActive = debugId !== -1 && DebugVis.active[debugId] === 1;
    
    // Update player capsule visibility and position
    if (playerCapsule) {
      playerCapsule.visible = debugActive;
      
      // Update position if visible
      if (debugActive) {
        const playerEnts = playerQuery(w);
        if (playerEnts.length > 0) {
          const playerEid = playerEnts[0];
          const playerObj = w.ctx.maps.mesh.get(playerEid);
          if (playerObj) {
            playerCapsule.position.copy(playerObj.position);
            playerCapsule.position.y -= 0.3; // Adjust to match center of capsule
            playerCapsule.rotation.y = playerObj.rotation.y;
          }
        }
      }
    }
    
    // Update projectile trajectories
    for (const projectileEid of projectileQuery(w)) {
      // Get current position for this projectile
      const rb = w.ctx.maps.rb.get(projectileEid);
      if (!rb) continue;
      
      // Get position and add to trajectory
      const pos = rb.translation();
      const currentPos = vec3Pool.get().set(pos.x, pos.y, pos.z);
      
      // Initialize trajectory and buffer if needed
      if (!trajectories.has(projectileEid)) {
        // Create trajectory tracking object
        trajectories.set(projectileEid, {
          count: 0,
          maxCount: MAX_TRAJECTORY_POINTS
        });
        
        // Pre-allocate the Float32Array with maximum size
        const posArray = new Float32Array(MAX_TRAJECTORY_POINTS * 3);
        const posAttribute = new THREE.BufferAttribute(posArray, 3);
        positionBuffers.set(projectileEid, {
          array: posArray,
          attribute: posAttribute
        });
      }
      
      // Get the trajectory data
      const trajectory = trajectories.get(projectileEid)!;
      // Get the buffer
      const buffer = positionBuffers.get(projectileEid)!;
      
      // Add current position directly to the buffer
      if (trajectory.count < MAX_TRAJECTORY_POINTS) {
        // We have room, add at the end
        const idx = trajectory.count * 3;
        buffer.array[idx] = currentPos.x;
        buffer.array[idx + 1] = currentPos.y;
        buffer.array[idx + 2] = currentPos.z;
        trajectory.count++;
      } else {
        // Shift all points one position back using copyWithin (much faster than loop)
        buffer.array.copyWithin(0, 3);
        
        // Add new point at the end
        const idx = (trajectory.count - 1) * 3;
        buffer.array[idx] = currentPos.x;
        buffer.array[idx + 1] = currentPos.y;
        buffer.array[idx + 2] = currentPos.z;
      }
      
      // Mark buffer for update
      buffer.attribute.needsUpdate = true;
      
      // Release the pooled vector
      vec3Pool.release(currentPos);
      
      // Only update/show trajectory lines if debug is active
      if (debugActive) {
        if (trajectoryLines.has(projectileEid)) {
          // Update existing line - reuse the geometry
          const line = trajectoryLines.get(projectileEid)!;
          line.visible = true;
          
          // Get the pre-allocated buffer and update it
          const buffer = positionBuffers.get(projectileEid)!;
          
          // Update geometry to draw only the current points
          line.geometry.setDrawRange(0, trajectory.count);
          buffer.attribute.needsUpdate = true;
        } else {
          // Create new line with dynamic buffer geometry
          const geometry = new THREE.BufferGeometry();
          const buffer = positionBuffers.get(projectileEid)!;
          
          // Add attribute to geometry
          geometry.setAttribute('position', buffer.attribute);
          
          // Set initial draw range
          geometry.setDrawRange(0, trajectory.count);
          
          // Use the shared material
          const line = new THREE.Line(geometry, lineMaterial);
          trajectoryLines.set(projectileEid, line);
          w.ctx.three.scene.add(line);
        }
      } else {
        // Hide lines if debug is disabled
        if (trajectoryLines.has(projectileEid)) {
          trajectoryLines.get(projectileEid)!.visible = false;
        }
      }
    }
    
    // Clean up trajectories for removed projectiles
    for (const [eid, line] of trajectoryLines.entries()) {
      const projectileExists = projectileQuery(w).includes(eid);
      
      // Check if projectile is marked for deletion
      const mesh = w.ctx.maps.mesh.get(eid);
      const markedForDeletion = mesh?.userData?.markedForDeletion === true;
      
      if (!projectileExists || markedForDeletion) {
        // Remove the trajectory line
        w.ctx.three.scene.remove(line);
        line.geometry.dispose();
        if (line.material instanceof THREE.Material) {
          line.material.dispose();
        } else if (Array.isArray(line.material)) {
          line.material.forEach(mat => mat.dispose());
        }
        trajectoryLines.delete(eid);
        trajectories.delete(eid);
        positionBuffers.delete(eid);
      }
    }
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/grass.ts
================================================
import * as THREE from 'three';
import { ECS } from '../world';
import { defineQuery, enterQuery, exitQuery } from 'bitecs';
import { CubeTag, Transform } from '../components';

// Custom shader material class for grass
class ShaderManager {
  private static instance: ShaderManager;
  private shaderCache: Record<string, { vertex: string, fragment: string }> = {};
  
  private constructor() {
    this.initShaders();
  }

  public static getInstance(): ShaderManager {
    if (!ShaderManager.instance) {
      ShaderManager.instance = new ShaderManager();
    }
    return ShaderManager.instance;
  }

  private initShaders(): void {
    // Define grass shader
    const grassVertexShader = `
      uniform vec2 grassSize;
      uniform vec4 grassParams;
      uniform vec4 grassDraw;
      uniform float time;
      uniform vec3 playerPos;
      uniform mat4 viewMatrixInverse;

      attribute float vertIndex;

      varying vec4 vGrassParams;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      varying vec2 vUv;

      // Math utility functions
      float saturate(float x) {
        return clamp(x, 0.0, 1.0);
      }

      float linearstep(float minValue, float maxValue, float v) {
        return clamp((v - minValue) / (maxValue - minValue), 0.0, 1.0);
      }

      float easeOut(float x, float t) {
        return 1.0 - pow(1.0 - x, t);
      }

      float easeIn(float x, float t) {
        return pow(x, t);
      }

      // Hash functions
      vec2 hash22(vec2 p) {
        p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
        return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
      }

      vec4 hash42(vec2 p) {
        vec4 p4 = fract(vec4(p.xyxy) * vec4(0.1031, 0.1030, 0.0973, 0.1099));
        p4 += dot(p4, p4.wzxy + 33.33);
        return fract((p4.xxyz + p4.yzzw) * p4.zywx) * 2.0 - 1.0;
      }

      // Noise function for wind
      float noise12(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        
        // Smooth interpolation
        vec2 u = f * f * (3.0 - 2.0 * f);
        
        // Hash corners
        float a = dot(hash22(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));
        float b = dot(hash22(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));
        float c = dot(hash22(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));
        float d = dot(hash22(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));
        
        // Mix
        return mix(mix(a, b, u.x), mix(c, d, u.x), u.y) * 0.5 + 0.5;
      }

      // Matrix utility functions
      mat3 rotateX(float theta) {
        float c = cos(theta);
        float s = sin(theta);
        return mat3(
          vec3(1.0, 0.0, 0.0),
          vec3(0.0, c, -s),
          vec3(0.0, s, c)
        );
      }

      mat3 rotateY(float theta) {
        float c = cos(theta);
        float s = sin(theta);
        return mat3(
          vec3(c, 0.0, s),
          vec3(0.0, 1.0, 0.0),
          vec3(-s, 0.0, c)
        );
      }

      mat3 rotateAxis(vec3 axis, float angle) {
        axis = normalize(axis);
        float s = sin(angle);
        float c = cos(angle);
        float oc = 1.0 - c;
        
        return mat3(
          oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
          oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
          oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c
        );
      }

      void main() {
        vec3 grassOffset = vec3(position.x, 0.0, position.y);

        // Blade world position
        vec3 grassBladeWorldPos = (modelMatrix * vec4(grassOffset, 1.0)).xyz;
        float heightmapSample = 0.0;
        float heightmapSampleHeight = 1.0;

        vec4 hashVal1 = hash42(vec2(grassBladeWorldPos.x, grassBladeWorldPos.z));

        float highLODOut = smoothstep(grassDraw.x * 0.5, grassDraw.x, distance(cameraPosition, grassBladeWorldPos));
        float lodFadeIn = smoothstep(grassDraw.x, grassDraw.y, distance(cameraPosition, grassBladeWorldPos));

        // Check terrain type
        float isSandy = 0.0;
        float grassAllowedHash = hashVal1.w - isSandy;
        float isGrassAllowed = step(0.0, grassAllowedHash);

        float randomAngle = hashVal1.x * 2.0 * 3.14159;
        float randomShade = clamp(hashVal1.y * 0.5 + 0.5, 0.5, 1.0);
        float randomHeight = mix(0.75, 1.5, hashVal1.z * 0.5 + 0.5) * mix(1.0, 0.0, lodFadeIn) * isGrassAllowed * heightmapSampleHeight;
        float randomWidth = (1.0 - isSandy) * heightmapSampleHeight;
        float randomLean = mix(0.1, 0.4, hashVal1.w * 0.5 + 0.5);

        vec2 hashGrassColour = hash22(vec2(grassBladeWorldPos.x, grassBladeWorldPos.z)) * 0.5 + 0.5;
        float leanAnimation = (noise12(vec2(time * 0.35) + grassBladeWorldPos.xz * 137.423) * 2.0 - 1.0) * 0.1;

        float GRASS_SEGMENTS = grassParams.x;
        float GRASS_VERTICES = grassParams.y;

        // Figure out vertex id
        float vertID = mod(float(vertIndex), GRASS_VERTICES);

        // 1 = front, -1 = back
        float zSide = -(floor(vertIndex / GRASS_VERTICES) * 2.0 - 1.0);

        // 0 = left, 1 = right
        float xSide = mod(vertID, 2.0);

        float heightPercent = (vertID - xSide) / (GRASS_SEGMENTS * 2.0);

        // Select grass blade variation (0-4 for 5 variations)
        float bladeVariation = floor(hashVal1.x * 5.0);

        float grassTotalHeight = grassSize.y * randomHeight;
        float grassTotalWidthHigh = easeOut(1.0 - heightPercent, 2.0);
        float grassTotalWidthLow = 1.0 - heightPercent;
        float grassTotalWidth = grassSize.x * mix(grassTotalWidthHigh, grassTotalWidthLow, highLODOut) * randomWidth;

        // Shift verts
        float x = (xSide - 0.5) * grassTotalWidth;
        float y = heightPercent * grassTotalHeight;

        float windDir = noise12(grassBladeWorldPos.xz * 0.05 + 0.05 * time) * 6.28318;
        float windNoiseSample = noise12(grassBladeWorldPos.xz * 0.25 + time * 1.0) * 2.0 - 1.0;
        float windLeanAngle = mix(0.25, 1.0, clamp(windNoiseSample * 0.5 + 0.5, 0.0, 1.0));
        windLeanAngle = easeIn(windLeanAngle, 2.0) * 1.25;
        vec3 windAxis = vec3(cos(windDir), 0.0, sin(windDir));

        windLeanAngle *= heightPercent;

        float distToPlayer = distance(grassBladeWorldPos.xz, playerPos.xz);
        float playerFalloff = smoothstep(2.5, 1.0, distToPlayer);
        float playerLeanAngle = mix(0.0, 0.2, playerFalloff * linearstep(0.5, 0.0, windLeanAngle));
        vec3 grassToPlayer = normalize(vec3(playerPos.x, 0.0, playerPos.z) - vec3(grassBladeWorldPos.x, 0.0, grassBladeWorldPos.z));
        vec3 playerLeanAxis = vec3(grassToPlayer.z, 0, -grassToPlayer.x);

        randomLean += leanAnimation;

        float easedHeight = mix(easeIn(heightPercent, 2.0), 1.0, highLODOut);
        float curveAmount = -randomLean * easedHeight;

        float ncurve1 = -randomLean * easedHeight;
        vec3 n1 = vec3(0.0, (heightPercent + 0.01), 0.0);
        n1 = rotateX(ncurve1) * n1;

        float ncurve2 = -randomLean * easedHeight * 0.9;
        vec3 n2 = vec3(0.0, (heightPercent + 0.01) * 0.9, 0.0);
        n2 = rotateX(ncurve2) * n2;

        vec3 ncurve = normalize(n1 - n2);

        mat3 grassMat = rotateAxis(playerLeanAxis, playerLeanAngle) * rotateAxis(windAxis, windLeanAngle) * rotateY(randomAngle);

        vec3 grassFaceNormal = vec3(0.0, 0.0, 1.0);
        grassFaceNormal = grassMat * grassFaceNormal;
        grassFaceNormal *= zSide;

        vec3 grassVertexNormal = vec3(0.0, -ncurve.z, ncurve.y);
        vec3 grassVertexNormal1 = rotateY(3.14159 * 0.3 * zSide) * grassVertexNormal;

        grassVertexNormal1 = grassMat * grassVertexNormal1;
        grassVertexNormal1 *= zSide;

        vec3 grassVertexPosition = vec3(x, y, 0.0);
        grassVertexPosition = rotateX(curveAmount) * grassVertexPosition;
        grassVertexPosition = grassMat * grassVertexPosition;

        grassVertexPosition += grassOffset;

        vGrassParams = vec4(heightPercent, grassBladeWorldPos.y, highLODOut, xSide);
        
        const float SKY_RATIO = 0.15;
        vec3 UP = vec3(0.0, 1.0, 0.0);
        float skyFadeIn = (1.0 - highLODOut) * SKY_RATIO;
        vNormal = normalize(mix(UP, grassVertexNormal1, skyFadeIn));

        vec3 pos = grassVertexPosition;

        vec3 viewDir = normalize(cameraPosition - grassBladeWorldPos);
        vec3 viewDirXZ = normalize(vec3(viewDir.x, 0.0, viewDir.z));
        vec3 grassFaceNormalXZ = normalize(vec3(grassFaceNormal.x, 0.0, grassFaceNormal.z));

        float viewDotNormal = saturate(dot(grassFaceNormal, viewDirXZ));
        float viewSpaceThickenFactor = easeOut(1.0 - viewDotNormal, 4.0) * smoothstep(0.0, 0.2, viewDotNormal);

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        
        // Thicken effect for better visibility
        mvPosition.x += viewSpaceThickenFactor * (xSide - 0.5) * grassTotalWidth * 0.5 * zSide;
        
        gl_Position = projectionMatrix * mvPosition;
        
        vPosition = pos;
        vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
        
        // Map UV to select one of the 5 blade variations
        // Each blade is 143px wide in a 715px texture (1/5 = 0.2 of the total width)
        // X coordinate: map the xSide (0-1) to a 0.2 width segment based on variation
        float uvX = (xSide * 0.2) + (bladeVariation * 0.2);
        vUv = vec2(uvX, heightPercent);
      }
    `;
    
    const grassFragmentShader = `
      uniform vec3 diffuse;
      uniform vec3 specular;
      uniform float shininess;
      uniform float opacity;
      uniform float time;
      uniform sampler2D grassTexture;
      
      varying vec4 vGrassParams;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      varying vec2 vUv;
      
      // Light data (mimic Three.js directional light)
      struct DirectionalLight {
        vec3 direction;
        vec3 color;
      };
      
      const DirectionalLight directionalLight = DirectionalLight(
        normalize(vec3(-0.5, 0.8, 0.5)),
        vec3(1.0, 1.0, 1.0)
      );
      
      // Utility functions
      float saturate(float x) {
        return clamp(x, 0.0, 1.0);
      }
      
      float easeIn(float x, float t) {
        return pow(x, t);
      }
      
      vec3 calculateLighting(vec3 normal, vec3 viewDir, vec3 baseColor) {
        // Ambient term
        vec3 ambient = vec3(0.3) * baseColor;
        
        // Diffuse term with wrapped lighting for softer look
        float wrap = 0.5;
        float NdotL = saturate((dot(normal, directionalLight.direction) + wrap) / (1.0 + wrap));
        vec3 diffuseLight = NdotL * directionalLight.color * baseColor;
        
        // Simple specular for highlights
        vec3 halfVector = normalize(directionalLight.direction + viewDir);
        float NdotH = max(0.0, dot(normal, halfVector));
        vec3 specularLight = pow(NdotH, shininess) * specular * directionalLight.color;
        
        // Back-lighting for translucency effect
        float backLight = saturate((dot(viewDir, -directionalLight.direction) + wrap) / (1.0 + wrap));
        float backFalloff = 0.5;
        vec3 backScatter = directionalLight.color * pow(backLight, 1.0) * backFalloff * baseColor * (1.0 - vGrassParams.z);
        
        return ambient + diffuseLight + specularLight + backScatter;
      }
      
      void main() {
        // Grass color processing
        float heightPercent = vGrassParams.x;
        float lodFadeIn = vGrassParams.z;
        
        // Sample the grass texture
        vec4 texSample = texture2D(grassTexture, vUv);
        
        // Use texture color directly
        vec3 baseColor = texSample.rgb;
        
        // Apply ambient occlusion at the base for natural grounding
        float ao = mix(0.25, 1.0, easeIn(heightPercent, 2.0));
        baseColor *= ao;
        
        // Lighting calculation
        vec3 viewDir = normalize(cameraPosition - vWorldPosition);
        vec3 litColor = calculateLighting(normalize(vNormal), viewDir, baseColor);
        
        // Use alpha from texture if available
        float alpha = texSample.a;
        if (alpha < 0.5) discard; // Discard pixels with low alpha
        
        gl_FragColor = vec4(litColor, 1.0);
      }
    `;
    
    this.shaderCache['GRASS'] = {
      vertex: grassVertexShader,
      fragment: grassFragmentShader
    };
  }

  public getShader(name: string): { vertex: string, fragment: string } {
    if (!this.shaderCache[name]) {
      console.error(`Shader ${name} not found`);
      return { vertex: '', fragment: '' };
    }
    return this.shaderCache[name];
  }
}

// Custom shader material class that works with our shader system
class CustomShaderMaterial extends THREE.ShaderMaterial {
  constructor(type: string, parameters: THREE.ShaderMaterialParameters = {}) {
    const shaderManager = ShaderManager.getInstance();
    const shader = shaderManager.getShader(type);
    
    if (!parameters.uniforms) {
      parameters.uniforms = {};
    }
    
    parameters.vertexShader = shader.vertex;
    parameters.fragmentShader = shader.fragment;
    
    super(parameters);
    
    // Set some default values
    this.transparent = parameters.transparent !== undefined ? parameters.transparent : false;
    this.side = parameters.side !== undefined ? parameters.side : THREE.FrontSide;
    this.depthWrite = parameters.depthWrite !== undefined ? parameters.depthWrite : true;
    this.depthTest = parameters.depthTest !== undefined ? parameters.depthTest : true;
  }
  
  setFloat(name: string, value: number): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value = value;
    }
  }
  
  setVector2(name: string, value: THREE.Vector2): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setVector3(name: string, value: THREE.Vector3): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setVector4(name: string, value: THREE.Vector4): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setMatrix(name: string, value: THREE.Matrix4): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value: value.clone() };
    } else {
      this.uniforms[name].value.copy(value);
    }
  }
  
  setTexture(name: string, value: THREE.Texture): void {
    if (!this.uniforms[name]) {
      this.uniforms[name] = { value };
    } else {
      this.uniforms[name].value = value;
    }
  }
}

// Simple math utility functions
const setSeed = (seed: number): void => {
  // Use a simple random number generator
  Math.random = () => {
    const x = Math.sin(seed++) * 10000;
    return x - Math.floor(x);
  };
};

const randRange = (min: number, max: number): number => {
  return Math.random() * (max - min) + min;
};

// Constants for grass rendering
const NUM_GRASS = (32 * 32) * 3;
const GRASS_SEGMENTS_LOW = 1;
const GRASS_SEGMENTS_HIGH = 6;
const GRASS_VERTICES_LOW = (GRASS_SEGMENTS_LOW + 1) * 2;
const GRASS_VERTICES_HIGH = (GRASS_SEGMENTS_HIGH + 1) * 2;
const GRASS_LOD_DIST = 25;
const GRASS_MAX_DIST = 180;
const GRASS_PATCH_SIZE = 5 * 2;
const GRASS_WIDTH = 0.1;
const GRASS_HEIGHT = 1.5;

// Grass component implementation
class GrassComponent {
  private meshesLow: THREE.Mesh[] = [];
  private meshesHigh: THREE.Mesh[] = [];
  private group: THREE.Group;
  private totalTime: number = 0;
  private grassMaterialLow: CustomShaderMaterial;
  private grassMaterialHigh: CustomShaderMaterial;
  private geometryLow: THREE.InstancedBufferGeometry;
  private geometryHigh: THREE.InstancedBufferGeometry;
  private readonly _scene: THREE.Scene;
  private grassTexture: THREE.Texture;

  constructor(scene: THREE.Scene, private camera: THREE.PerspectiveCamera) {
    this._scene = scene;
    this.group = new THREE.Group();
    this.group.name = "GRASS";
    
    // Load grass texture
    this.grassTexture = new THREE.TextureLoader().load('/textures/grassblade.png');
    this.grassTexture.wrapS = THREE.ClampToEdgeWrapping;
    this.grassTexture.wrapT = THREE.ClampToEdgeWrapping;
    this.grassTexture.minFilter = THREE.LinearFilter;
    this.grassTexture.magFilter = THREE.LinearFilter;
    this.grassTexture.generateMipmaps = true;
    // The texture contains 5 blades horizontally, prevent texture bleeding between variants
    this.grassTexture.anisotropy = 16; // Improves appearance at angles
    
    // Initialize grass materials
    this.grassMaterialLow = this.createGrassMaterial(true);
    this.grassMaterialHigh = this.createGrassMaterial(false);
    
    // Create grass geometries
    this.geometryLow = this.createGrassGeometry(GRASS_SEGMENTS_LOW);
    this.geometryHigh = this.createGrassGeometry(GRASS_SEGMENTS_HIGH);
    
    // Add group to scene
    scene.add(this.group);
  }

  private createGrassMaterial(isLowDetail: boolean): CustomShaderMaterial {
    const material = new CustomShaderMaterial('GRASS', {
      uniforms: {
        grassSize: { value: new THREE.Vector2(GRASS_WIDTH, GRASS_HEIGHT) },
        grassParams: { value: new THREE.Vector4(
          isLowDetail ? GRASS_SEGMENTS_LOW : GRASS_SEGMENTS_HIGH,
          isLowDetail ? GRASS_VERTICES_LOW : GRASS_VERTICES_HIGH,
          0, 0
        )},
        grassDraw: { value: new THREE.Vector4(GRASS_LOD_DIST, GRASS_MAX_DIST, 0, 0) },
        time: { value: 0.0 },
        playerPos: { value: new THREE.Vector3(0, 0, 0) },
        viewMatrixInverse: { value: new THREE.Matrix4() },
        diffuse: { value: new THREE.Color(0xffffff) },
        specular: { value: new THREE.Color(0x111111) },
        shininess: { value: 30 },
        grassTexture: { value: this.grassTexture }
      },
      transparent: true,
      alphaTest: 0.5,
      side: THREE.DoubleSide
    });
    
    return material;
  }

  private createGrassGeometry(segments: number): THREE.InstancedBufferGeometry {
    setSeed(0);

    const VERTICES = (segments + 1) * 2;

    // Create indices
    const indices: number[] = [];
    for (let i = 0; i < segments; ++i) {
      const vi = i * 2;
      indices[i*12+0] = vi + 0;
      indices[i*12+1] = vi + 1;
      indices[i*12+2] = vi + 2;

      indices[i*12+3] = vi + 2;
      indices[i*12+4] = vi + 1;
      indices[i*12+5] = vi + 3;

      const fi = VERTICES + vi;
      indices[i*12+6] = fi + 2;
      indices[i*12+7] = fi + 1;
      indices[i*12+8] = fi + 0;

      indices[i*12+9]  = fi + 3;
      indices[i*12+10] = fi + 1;
      indices[i*12+11] = fi + 2;
    }

    // Create offsets
    const offsets: number[] = [];
    for (let i = 0; i < NUM_GRASS; ++i) {
      offsets.push(randRange(-GRASS_PATCH_SIZE * 0.5, GRASS_PATCH_SIZE * 0.5));
      offsets.push(randRange(-GRASS_PATCH_SIZE * 0.5, GRASS_PATCH_SIZE * 0.5));
      offsets.push(0);
    }

    // Create vertex IDs
    const vertID = new Uint8Array(VERTICES*2);
    for (let i = 0; i < VERTICES*2; ++i) {
      vertID[i] = i;
    }

    // Create instanced geometry
    const geo = new THREE.InstancedBufferGeometry();
    geo.instanceCount = NUM_GRASS;
    geo.setAttribute('vertIndex', new THREE.Uint8BufferAttribute(vertID, 1));
    geo.setAttribute('position', new THREE.InstancedBufferAttribute(new Float32Array(offsets), 3));
    geo.setIndex(indices);
    geo.boundingSphere = new THREE.Sphere(new THREE.Vector3(0, 0, 0), 1 + GRASS_PATCH_SIZE * 2);

    return geo;
  }

  private createGrassMesh(distToCell: number): THREE.Mesh {
    const isLowDetail = distToCell > GRASS_LOD_DIST;
    const geometry = isLowDetail ? this.geometryLow : this.geometryHigh;
    const material = isLowDetail ? this.grassMaterialLow : this.grassMaterialHigh;
    
    const mesh = new THREE.Mesh(geometry, material);
    if (!mesh) {
      throw new Error("Failed to create grass mesh");
    }
    mesh.receiveShadow = true;
    mesh.castShadow = false;
    mesh.visible = false;
    
    if (isLowDetail) {
      this.meshesLow.push(mesh);
    } else {
      this.meshesHigh.push(mesh);
    }
    
    this.group.add(mesh);
    return mesh;
  }

  update(deltaTime: number, playerPosition: THREE.Vector3): void {
    this.totalTime += deltaTime;

    // Update material time uniforms
    this.grassMaterialLow.setFloat('time', this.totalTime);
    this.grassMaterialHigh.setFloat('time', this.totalTime);
    
    // Update player position
    this.grassMaterialLow.setVector3('playerPos', playerPosition);
    this.grassMaterialHigh.setVector3('playerPos', playerPosition);
    
    // Update view matrix
    this.grassMaterialLow.setMatrix('viewMatrixInverse', this.camera.matrixWorld);
    this.grassMaterialHigh.setMatrix('viewMatrixInverse', this.camera.matrixWorld);

    // Make all grass patches invisible initially
    for (const child of this.group.children) {
      child.visible = false;
    }

    // Create frustum for culling
    const frustum = new THREE.Frustum();
    const projScreenMatrix = new THREE.Matrix4();
    projScreenMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(projScreenMatrix);
    
    // Calculate base cell position
    const baseCellPos = new THREE.Vector3().copy(this.camera.position);
    baseCellPos.divideScalar(GRASS_PATCH_SIZE);
    baseCellPos.floor();
    baseCellPos.multiplyScalar(GRASS_PATCH_SIZE);
    
    // Copy meshes arrays for reuse
    const meshesLow = [...this.meshesLow];
    const meshesHigh = [...this.meshesHigh];
    
    // Camera position flattened to XZ plane for distance calculation
    const cameraPosXZ = new THREE.Vector3(this.camera.position.x, 0, this.camera.position.z);
    
    // Spawn grass patches
    let totalGrass = 0;
    let totalVerts = 0;
    
    for (let x = -22; x < 22; x++) {
      for (let z = -22; z < 22; z++) {
        // Current cell position
        const currentCell = new THREE.Vector3(
          baseCellPos.x + x * GRASS_PATCH_SIZE, 
          0,
          baseCellPos.z + z * GRASS_PATCH_SIZE
        );
        
        // Create AABB for culling
        const aabb = new THREE.Box3().setFromCenterAndSize(
          currentCell,
          new THREE.Vector3(GRASS_PATCH_SIZE, 1000, GRASS_PATCH_SIZE)
        );
        
        // Calculate distance to cell
        const distToCell = aabb.distanceToPoint(cameraPosXZ);
        
        // Skip if too far
        if (distToCell > GRASS_MAX_DIST) {
          continue;
        }
        
        // Skip if outside frustum
        if (!frustum.intersectsBox(aabb)) {
          continue;
        }
        
        // Create or reuse grass mesh based on distance
        if (distToCell > GRASS_LOD_DIST) {
          const mesh = meshesLow.length > 0 ? meshesLow.pop()! : this.createGrassMesh(distToCell);
          mesh.position.copy(currentCell);
          mesh.visible = true;
          totalVerts += GRASS_VERTICES_LOW;
        } else {
          const mesh = meshesHigh.length > 0 ? meshesHigh.pop()! : this.createGrassMesh(distToCell);
          mesh.position.copy(currentCell);
          mesh.visible = true;
          totalVerts += GRASS_VERTICES_HIGH;
        }
        
        totalGrass += 1;
      }
    }
  }
}

let grassComponent: GrassComponent | null = null;

// Initialize the grass system
export function initGrassSystem(world: ECS) {
  const { scene, camera } = world.ctx.three;
  
  // Create the grass component on system init
  grassComponent = new GrassComponent(scene, camera as THREE.PerspectiveCamera);
  
  // Return the system function
  return function grassSystem(world: ECS) {
    // Get player position from the camera
    const playerPosition = world.ctx.three.camera.position.clone();
    
    // Update grass with elapsed time and player position
    if (grassComponent) {
      grassComponent.update(world.time.dt, playerPosition);
    }
    
    return world;
  };
} 

================================================
File: /src/ecs/systems/input.ts
================================================
import { addComponent, addEntity } from 'bitecs';
import { DebugVis } from '../components';
import { ECS } from '../world';
import { safeAddEventListener, setupEventCleanup } from '../utils/eventUtils';

// Add property to Window interface
declare global {
  interface Window {
    listenersAttached?: boolean;
  }
}

export interface InputState {
  fw: boolean; bk: boolean; lf: boolean; rt: boolean;
  sprint: boolean;
  shoot: boolean; jump: boolean;
  pointerLocked: boolean;
  dx: number; dy: number;
  debugActive: boolean;
}

export function initInputSystem(world: ECS) {
  const state: InputState = {
    fw: false, bk: false, lf: false, rt: false,
    sprint: false,
    shoot: false, jump: false,
    pointerLocked: false,
    dx: 0, dy: 0,
    debugActive: false
  };
  
  // Keep track of whether V was pressed last frame
  let vWasPressed = false;
  
  // Create a singleton debug entity and add the component to it
  const debugId = addEntity(world); // Create a new entity, don't assume ID 0
  addComponent(world, DebugVis, debugId);
  DebugVis.active[debugId] = 0; // 0 = off, 1 = on

  /* keyboard ------------------------------------------------------- */
  const key = (code: string, v: boolean) => {
    if (code === 'KeyW' || code === 'ArrowUp')    state.fw     = v;
    if (code === 'KeyS' || code === 'ArrowDown')  state.bk     = v;
    if (code === 'KeyA' || code === 'ArrowLeft')  state.lf     = v;
    if (code === 'KeyD' || code === 'ArrowRight') state.rt     = v;
    if (code === 'Space')                         state.jump   = v;
    if (code === 'ShiftLeft' || code === 'ShiftRight') state.sprint = v;
    
    // Handle V key press for debug visualization toggle
    if (code === 'KeyV') {
      // Toggle on key down only
      if (v && !vWasPressed) {
        // Toggle debug state
        const newState = DebugVis.active[debugId] === 0 ? 1 : 0;
        DebugVis.active[debugId] = newState;
        state.debugActive = newState === 1;
        console.log(`Debug visualization: ${state.debugActive ? 'ON' : 'OFF'}`);
      }
      vWasPressed = v;
    }
  };
  
  // Only attach event listeners once
  if (!window.listenersAttached) {
    safeAddEventListener(window, 'keydown', e => key((e as KeyboardEvent).code, true));
    safeAddEventListener(window, 'keyup',   e => key((e as KeyboardEvent).code, false));

    /* mouse ---------------------------------------------------------- */
    const canvas = document.getElementById('c') as HTMLCanvasElement;
    safeAddEventListener(canvas, 'click', () => canvas.requestPointerLock());

    safeAddEventListener(document, 'pointerlockchange', () => {
      state.pointerLocked = !!document.pointerLockElement;
    });

    safeAddEventListener(window, 'mousemove', e => {
      if (!state.pointerLocked) return;
      state.dx += (e as MouseEvent).movementX;
      state.dy += (e as MouseEvent).movementY;
    });

    safeAddEventListener(window, 'mousedown', e => { if ((e as MouseEvent).button === 0) state.shoot = true; });
    safeAddEventListener(window, 'mouseup',   e => { if ((e as MouseEvent).button === 0) state.shoot = false; });
    
    // Set up event cleanup
    setupEventCleanup();
    
    // Mark listeners as attached
    window.listenersAttached = true;
  }

  return (w: ECS) => { 
    // Set the input state on the world
    w.input = state;
    return w;
  };
}


================================================
File: /src/ecs/systems/physics.ts
================================================
import { defineQuery, exitQuery } from 'bitecs';
import { RigidBodyRef } from '../components';
import { ECS } from '../world';
import { PhysicsConfig, TimeStepConfig } from '../config';

export function initPhysicsSystem(_world: ECS) {
  const rbq = defineQuery([RigidBodyRef]);
  const exit = exitQuery(rbq);

  /* cleanup on entity removal */
  return (w: ECS) => {
    // Skip physics if we're not on a physics frame
    if (!w.time.shouldRunPhysics) {
      return w;
    }
    
    // Get all active rigid bodies
    const rigidBodies = [];
    for (const eid of rbq(w)) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb) rigidBodies.push(rb);
    }
    
    // Dynamically enable CCD on fast-moving objects
    for (const rb of rigidBodies) {
      try {
        // Different versions of Rapier have different APIs
        // Check if the body is dynamic (only dynamic bodies can have CCD)
        const isDynamic = rb.bodyType && 
                         rb.bodyType() === w.ctx.rapier.RigidBodyType.Dynamic;
        
        if (isDynamic) {
          const vel = rb.linvel();
          const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y + vel.z * vel.z);
          
          // Enable CCD for fast moving objects 
          // Check if this version of Rapier supports CCD toggling
          if (speed > PhysicsConfig.VELOCITY_THRESHOLD && rb.enableCcd) {
            rb.enableCcd(true);
          } 
          // Disable CCD for slower objects to improve performance
          else if (speed < PhysicsConfig.VELOCITY_THRESHOLD * 0.8 && rb.enableCcd) {
            rb.enableCcd(false);
          }
        }
      } catch (e) {
        // Skip CCD handling if the API doesn't match
      }
    }
    
    // Configure physics parameters if the API supports it
    try {
      if (w.ctx.physics.integrationParameters) {
        // Set solver iterations for more accurate simulation
        w.ctx.physics.integrationParameters.numSolverIterations = PhysicsConfig.SOLVER_ITERATIONS;
        
        // Increase CCD substeps - critical for bullet physics!
        w.ctx.physics.integrationParameters.maxCcdSubsteps = PhysicsConfig.CCD_SUBSTEPS;
      }
    } catch (e) {
      // Skip if the API doesn't support this
    }
    
    // Always use the fixed timestep from the time system
    const dt = w.time.fixedDt || TimeStepConfig.FIXED_DT;
    
    // Process physics step with fixed timestep - handle type issues with assertions
    if (w.ctx.eventQueue) {
      // Call step with the correct argument order based on Rapier type definitions
      // Type assertion needed due to version differences in Rapier API
      (w.ctx.physics.step as any)(w.ctx.eventQueue, dt);
    } else {
      // Type assertion needed due to differences in Rapier API versions
      (w.ctx.physics.step as any)(dt);
    }

    /* purge removed RigidBodies */
    for (const eid of exit(w)) {
      const rb = w.ctx.maps.rb.get(eid);
      if (rb) {
        w.ctx.physics.removeRigidBody(rb);
        w.ctx.maps.rb.delete(eid);
      }
    }
    return w;
  };
}


================================================
File: /src/ecs/systems/player/animationSystem.ts
================================================
/**
 * Player animation system - handles player model loading, animation states and transitions
 */
import { defineQuery } from 'bitecs';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { Player, MeshRef, FPController } from '../../components';
import { ECS } from '../../world';
import { MovementState } from '../../config';

// Animation state constants
const AnimationState = {
  IDLE: 'idle',
  WALKING: 'walking'
};

export function initPlayerAnimationSystem(world: ECS) {
  const playerQuery = defineQuery([Player, MeshRef, FPController]);
  
  // Animation variables
  let playerModel: THREE.Group | null = null;
  let mixer: THREE.AnimationMixer | null = null;
  let animations: Map<string, THREE.AnimationAction> = new Map();
  let currentAnimation: string | null = null;
  let activeAction: THREE.AnimationAction | null = null;
  
  // Movement tracking
  let movementState = "idle"; // Current movement state: "idle" or "walking"
  let movementTimer = 0; // Timer to prevent rapid state changes
  let movementBuffer = [false, false, false, false, false]; // Buffer last 5 movement samples
  let bufferIndex = 0;
  
  // Regular check to ensure animation is playing
  let animationCheckTimer = 0;
  
  // Load player model
  const loader = new GLTFLoader();
  loader.load('/models/playermodel.glb', (gltf) => {
    console.log('Player model loaded:', gltf);
    
    // Store the model for later use
    playerModel = gltf.scene;
    
    // Set up animation mixer
    mixer = new THREE.AnimationMixer(playerModel);
    
    // Process animations
    gltf.animations.forEach((clip) => {
      // Create actions for each animation clip
      if (mixer) {
        const action = mixer.clipAction(clip);
        
        // Store by name for easier access
        if (clip.name.toLowerCase().includes('idle')) {
          animations.set(AnimationState.IDLE, action);
          console.log(`Animation loaded: ${clip.name} (IDLE)`);
        } else if (clip.name.toLowerCase().includes('walk')) {
          animations.set(AnimationState.WALKING, action);
          console.log(`Animation loaded: ${clip.name} (WALKING)`);
        } else {
          console.log(`Other animation loaded: ${clip.name}`);
        }
      }
    });
    
    // Configure all animations
    animations.forEach(action => {
      // Ensure animations loop infinitely and never stop
      action.setLoop(THREE.LoopRepeat, Infinity);
      action.clampWhenFinished = false;
      action.timeScale = 1;
      action.setEffectiveWeight(1);
      action.enabled = true;
      
      // Disable automatic deactivation
      action.zeroSlopeAtEnd = false;
      action.zeroSlopeAtStart = false;
    });
    
    // Add model to scene and player
    if (playerModel) {
      // Scale and position adjustments
      playerModel.scale.set(1, 1, 1);
      
      // Get player entity and attach model to player
      const playerEntities = playerQuery(world);
      if (playerEntities.length > 0) {
        const pid = playerEntities[0];
        const holder = world.ctx.maps.mesh.get(pid);
        
        if (holder) {
          // Position the model relative to the player's position
          // Fix: Adjust Y position to prevent sinking into ground
          playerModel.position.set(0, -0.9, 0);
          playerModel.rotation.y = Math.PI; // Face the camera by default
          
          // Add model to player holder
          holder.add(playerModel);
          
          // Log bone names for debugging/reference
          console.log("--------- BONE NAMES ---------");
          playerModel.traverse((object) => {
            if (object instanceof THREE.Bone) {
              console.log("Bone:", object.name);
            }
          });
          
          // Start with idle animation
          setAnimation("idle");
        }
      }
    }
  });
  
  // Simple animation switch without complex crossfading
  function setAnimation(state: string) {
    // Ignore if we're already in this state or animations not loaded
    if (state === movementState || !animations.has(state === "walking" ? AnimationState.WALKING : AnimationState.IDLE)) {
      return;
    }
    
    // Update state
    movementState = state;
    console.log(`Changing animation to ${state}`);
    
    // Get the new animation
    let newAction: THREE.AnimationAction | null = null;
    
    if (state === "walking") {
      const walkAction = animations.get(AnimationState.WALKING);
      if (walkAction) {
        newAction = walkAction;
      }
    } else {
      const idleAction = animations.get(AnimationState.IDLE);
      if (idleAction) {
        newAction = idleAction;
      }
    }
    
    // Only proceed if we have a valid action
    if (!newAction) return;
    
    // Fade between animations - smoother transition
    if (activeAction && activeAction !== newAction) {
      // Prepare new action
      newAction.reset();
      newAction.setEffectiveWeight(1);
      newAction.enabled = true;
      newAction.play();
      
      // Fade from current to new
      newAction.crossFadeFrom(activeAction, 0.2, true);
    } else {
      // First animation or direct switch
      newAction.enabled = true;
      newAction.reset();
      newAction.play();
    }
    
    // Update current animation state
    activeAction = newAction;
    currentAnimation = state === "walking" ? AnimationState.WALKING : AnimationState.IDLE;
    
    // Set timeout before next state change is allowed
    movementTimer = 0.3; // 300ms debounce
  }
  
  // Ensure an animation is playing (fallback to idle)
  function ensureAnimationPlaying() {
    if (!mixer || !animations.size) return;
    
    // Check if any action is currently running
    let isAnimationActive = false;
    
    // Check if the active action is properly running
    if (activeAction && activeAction.isRunning()) {
      isAnimationActive = true;
    }
    
    if (!isAnimationActive) {
      console.log("No active animation detected, resetting to idle");
      
      // Force idle animation to play
      const idleAction = animations.get(AnimationState.IDLE);
      if (idleAction) {
        // Stop all potentially paused actions
        mixer.stopAllAction();
        
        // Reset action state
        idleAction.reset();
        idleAction.setEffectiveWeight(1);
        idleAction.enabled = true;
        idleAction.play();
        
        // Update current state
        activeAction = idleAction;
        currentAnimation = AnimationState.IDLE;
        movementState = "idle";
      }
    }
  }
  
  // Check if player is moving based on position buffer
  function isPlayerMoving() {
    // Count true values in buffer
    const movingFrames = movementBuffer.filter(moving => moving).length;
    // Consider moving if at least 3 of the last 5 frames showed movement
    return movingFrames >= 3;
  }
  
  return (w: ECS) => {
    // Update timers
    if (movementTimer > 0) {
      movementTimer -= w.time.dt;
    }
    
    // Increment animation check timer
    animationCheckTimer += w.time.dt;
    
    // Only continue if animations are loaded
    if (!mixer || !playerModel) {
      return w;
    }
    
    // Check animation state regularly to prevent T-pose
    if (animationCheckTimer > 1.0) { // Check every second
      ensureAnimationPlaying();
      animationCheckTimer = 0;
    }
    
    // Update animation mixer
    mixer.update(w.time.dt);
    
    // Process all player entities (usually just one)
    for (const eid of playerQuery(w)) {
      const holder = w.ctx.maps.mesh.get(eid);
      
      if (holder) {
        // Initialize previous position if needed
        if (!w.time.prevPlayerPos) {
          w.time.prevPlayerPos = new THREE.Vector3(holder.position.x, holder.position.y, holder.position.z);
          continue; // Skip this frame as we need two positions to compare
        }
        
        // Calculate horizontal movement (ignore Y)
        const deltaX = holder.position.x - w.time.prevPlayerPos.x;
        const deltaZ = holder.position.z - w.time.prevPlayerPos.z;
        const movementSq = deltaX * deltaX + deltaZ * deltaZ;
        
        // Store in moving buffer (true if moving, false if not)
        movementBuffer[bufferIndex] = movementSq > 0.0005;
        bufferIndex = (bufferIndex + 1) % movementBuffer.length;
        
        // Determine movement state
        const isMoving = isPlayerMoving();
        
        // Only change animation if debounce timer is up
        if (movementTimer <= 0) {
          if (isMoving && movementState !== "walking") {
            setAnimation("walking");
          } else if (!isMoving && movementState !== "idle") {
            setAnimation("idle");
          }
        }
        
        // Store current position for next frame
        w.time.prevPlayerPos.set(holder.position.x, holder.position.y, holder.position.z);
      }
    }
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/player/index.ts
================================================
/**
 * Main player system that initializes and combines movement, look and shoot sub-systems
 */
import { addComponent, addEntity } from 'bitecs';
import * as THREE from 'three';
import {
  MeshRef, Player, RigidBodyRef, Transform, FPController
} from '../../components';
import { ECS } from '../../world';
import { MovementState } from '../../config';
import { initPlayerMovementSystem } from './movementSystem';
import { initPlayerLookSystem } from './lookSystem';
import { initPlayerShootSystem } from './shootSystem';
import { initPlayerAnimationSystem } from './animationSystem';

export function initPlayerSystem(world: ECS) {
  const { rapier, physics, three, maps } = world.ctx;

  /* entity + mesh holder ------------------------------------------- */
  const pid = addEntity(world);
  addComponent(world, Player,       pid);
  addComponent(world, Transform,    pid);
  addComponent(world, MeshRef,      pid);
  addComponent(world, RigidBodyRef, pid);
  addComponent(world, FPController, pid);
  
  // Initialize controller state
  FPController.pitch[pid] = 0;
  FPController.vertVel[pid] = 0;
  FPController.moveState[pid] = MovementState.GROUNDED;
  FPController.lastGrounded[pid] = performance.now();
  FPController.lastJump[pid] = 0;
  FPController.lastShot[pid] = 0;
  FPController.jumpRequested[pid] = 0;
  FPController.lastJumpRequest[pid] = 0;

  const holder = new THREE.Object3D();
  holder.position.set(0, 3, 6);
  three.scene.add(holder);
  maps.mesh.set(pid, holder);

  // Position the camera in the holder
  const cameraOffset = new THREE.Object3D();
  cameraOffset.position.set(0, 1.6, 0); // Eye height of ~1.6m
  holder.add(cameraOffset);
  cameraOffset.add(three.camera);

  /* Rapier kinematic capsule --------------------------------------- */
  const rb = physics.createRigidBody(
    rapier.RigidBodyDesc.kinematicPositionBased()
          .setTranslation(holder.position.x, holder.position.y, holder.position.z)
          .setCcdEnabled(true)
  );
  const collider = physics.createCollider(
    rapier.ColliderDesc.capsule(0.9, 0.3).setFriction(0.2), rb
  );

  const kcc = physics.createCharacterController(0.01);
  kcc.setApplyImpulsesToDynamicBodies(true);
  kcc.setUp({ x: 0, y: 1, z: 0 });
  kcc.enableAutostep(0.5, 0.3, true);
  kcc.enableSnapToGround(0.3);

  maps.rb.set(pid, rb);
  RigidBodyRef.id[pid] = rb.handle;
  
  // Store KCC and collider for use in movement system
  world.ctx.kcc = kcc;
  world.ctx.playerCollider = collider;

  // Initialize sub-systems
  const movementSystem = initPlayerMovementSystem(world);
  const lookSystem = initPlayerLookSystem(world);
  const shootSystem = initPlayerShootSystem(world);
  const animationSystem = initPlayerAnimationSystem(world);

  /* Combined system ------------------------------------------------- */
  return (w: ECS) => {
    // Run all sub-systems in sequence
    lookSystem(w);
    movementSystem(w);
    shootSystem(w);
    animationSystem(w);
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/player/lookSystem.ts
================================================
/**
 * Player look system - handles camera movement via mouse input
 */
import { defineQuery } from 'bitecs';
import * as THREE from 'three';
import { Player, FPController } from '../../components';
import { ECS } from '../../world';
import { InputState } from '../input';
import { PlayerConfig } from '../../config';

export function initPlayerLookSystem(_world: ECS) {
  const playerQuery = defineQuery([Player, FPController]);

  return (w: ECS) => {
    const input = w.input as InputState;
    // Input check removed - initInputSystem is guaranteed to run first

    // Skip if pointer isn't locked
    if (!input.pointerLocked) {
      input.dx = input.dy = 0;
      return w;
    }

    for (const eid of playerQuery(w)) {
      // Get the player object that holds the camera
      const holder = w.ctx.maps.mesh.get(eid);
      if (!holder) continue;
      
      // Update yaw (horizontal rotation)
      holder.rotation.y = (holder.rotation.y - input.dx * PlayerConfig.MOUSE_SENSITIVITY) % (Math.PI * 2);
      if (holder.rotation.y < 0) holder.rotation.y += Math.PI * 2;

      // Update pitch (vertical look) with clamping
      FPController.pitch[eid] = THREE.MathUtils.clamp(
        FPController.pitch[eid] - input.dy * PlayerConfig.MOUSE_SENSITIVITY, 
        -Math.PI / 2,  // Look up limit
        Math.PI / 2    // Look down limit
      );
      
      // Apply pitch to camera
      const camera = w.ctx.three.camera;
      if (camera) {
        camera.rotation.x = FPController.pitch[eid];
      }
    }
    
    // Reset mouse deltas after processing
    input.dx = input.dy = 0;
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/player/movementSystem.ts
================================================
/**
 * Player movement system - handles movement, jumping, and physics integration
 */
import { defineQuery } from 'bitecs';
import { Player, RigidBodyRef, FPController } from '../../components';
import { ECS } from '../../world';
import { InputState } from '../input';
import { vec2Pool, vec3Pool } from '../../utils/mathUtils';
import { PlayerConfig, MovementState } from '../../config';

export function initPlayerMovementSystem(_world: ECS) {
  const playerQuery = defineQuery([Player, RigidBodyRef, FPController]);
  
  // Reused vector objects to avoid allocations
  const dir = vec3Pool.get();
  const horiz = vec2Pool.get();
  
  // Track the previous jump state to require releasing space before jumping again
  let prevJump = false;

  return (w: ECS) => {
    const input = w.input as InputState;
    // Input check removed - initInputSystem is guaranteed to run first
    
    const now = performance.now();
    
    for (const eid of playerQuery(w)) {
      const rb = w.ctx.maps.rb.get(eid);
      const kcc = w.ctx.kcc; // Character controller from player init
      const playerCollider = w.ctx.playerCollider;
      
      // Skip if we don't have all required components
      if (!rb || !kcc || !playerCollider) continue;
      
      // Get the player mesh holder
      const holder = w.ctx.maps.mesh.get(eid);
      if (!holder) continue;
      
      /* movement state + gravity ------------------------------------- */
      const grounded = kcc.computedGrounded();
      if (grounded) FPController.lastGrounded[eid] = now;

      if (grounded) {
        FPController.moveState[eid] = MovementState.GROUNDED;
      } else {
        FPController.moveState[eid] = FPController.vertVel[eid] > 0 ? 
          MovementState.JUMPING : MovementState.FALLING;
      }
      
      // Handle jump buffering - store jump request timing
      // Only allow a new jump request if space was released since last jump
      const jumpPressed = input.jump && !prevJump;
      if (jumpPressed && FPController.jumpRequested[eid] === 0) {
        FPController.jumpRequested[eid] = 1;
        FPController.lastJumpRequest[eid] = now;
      } else if (!input.jump) {
        FPController.jumpRequested[eid] = 0;
      }

      // Check if we can jump with either direct input or buffered input
      const canJump = (grounded || now - FPController.lastGrounded[eid] < PlayerConfig.COYOTE_MS) && 
                      now - FPController.lastJump[eid] > PlayerConfig.JUMP_CD_MS;
      
      // Execute jump if conditions met, including buffered jumps
      if (canJump && (jumpPressed || (now - FPController.lastJumpRequest[eid] < PlayerConfig.JUMP_BUFFER_MS))) {
        FPController.vertVel[eid] = PlayerConfig.JUMP_VEL;
        FPController.lastJump[eid] = now;
        FPController.jumpRequested[eid] = 0;
      }

      // Store previous jump state for next frame
      prevJump = input.jump;

      if (FPController.moveState[eid] !== MovementState.GROUNDED) {
        // Apply gravity with framerate-independent scaling
        FPController.vertVel[eid] = Math.max(
          FPController.vertVel[eid] - PlayerConfig.GRAVITY * w.time.dt, 
          PlayerConfig.TERMINAL_FALL
        );
      } else {
        FPController.vertVel[eid] *= 0.8;
        if (Math.abs(FPController.vertVel[eid]) < 0.1) FPController.vertVel[eid] = 0;
      }

      /* directional input -------------------------------------------- */
      dir.set(
        (input.rt ? 1 : 0) - (input.lf ? 1 : 0),
        0,
        (input.bk ? 1 : 0) - (input.fw ? 1 : 0)
      );
      
      if (dir.lengthSq() > 0) dir.normalize();
      
      // Get a temporary up vector, use it, then release it
      const upVector = vec3Pool.get().set(0, 1, 0);
      dir.applyAxisAngle(upVector, holder.rotation.y);
      vec3Pool.release(upVector);

      // Base speed calculation
      const speed = PlayerConfig.WALK_SPEED *
                    (FPController.moveState[eid] === MovementState.GROUNDED ? 
                      1 : PlayerConfig.AIR_CONTROL) *
                    (input.sprint ? PlayerConfig.SPRINT_FACTOR : 1);

      horiz.set(dir.x * speed, dir.z * speed);

      /* KCC integration ---------------------------------------------- */
      // Always scale movement by delta time for frame independence
      const dt = w.time.shouldRunPhysics ? w.time.fixedDt! : w.time.dt;
      
      const requested = {
        x: horiz.x * dt,
        y: FPController.vertVel[eid] * dt,
        z: horiz.y * dt
      };
      
      // Now safe to use playerCollider since we checked it above
      kcc.computeColliderMovement(playerCollider, requested);
      const actual = kcc.computedMovement();

      if (FPController.vertVel[eid] > 0 && actual.y < requested.y * 0.9) {
        FPController.vertVel[eid] = 0; // head hit
      }

      const p = rb.translation();
      rb.setNextKinematicTranslation({
        x: p.x + actual.x,
        y: p.y + actual.y,
        z: p.z + actual.z
      });
      
      holder.position.set(p.x + actual.x, p.y + actual.y, p.z + actual.z);
    }
    
    return w;
  };
} 

================================================
File: /src/ecs/systems/player/shootSystem.ts
================================================
/**
 * Player shooting system - handles weapon firing
 */
import { addComponent, addEntity, defineQuery } from 'bitecs';
import * as THREE from 'three';
import { Player, FPController, Projectile, Lifespan, Velocity, MeshRef, RigidBodyRef, Transform } from '../../components';
import { ECS } from '../../world';
import { InputState } from '../input';
import { vec3Pool } from '../../utils/mathUtils';
import { WeaponConfig } from '../../config';

export function initPlayerShootSystem(_world: ECS) {
  const playerQuery = defineQuery([Player, FPController]);
  
  // Track the previous shoot state to detect start of shooting
  let prevShoot = false;

  return (w: ECS) => {
    const input = w.input as InputState;
    // Input check removed - initInputSystem is guaranteed to run first
    
    const now = performance.now();
    
    for (const eid of playerQuery(w)) {
      // Detect shoot button pressed (not held)
      const shootStart = input.shoot && !prevShoot;
      
      if (shootStart && now - FPController.lastShot[eid] > WeaponConfig.SHOOT_CD_MS) {
        spawnBullet(w, w.ctx.three.camera, w.ctx.rapier);
        FPController.lastShot[eid] = now;
      }
    }
    
    // Store shoot state for next frame
    prevShoot = input.shoot;
    
    return w;
  };
}

/* bullet helper ---------------------------------------------------- */
function spawnBullet(
  w: ECS, camera: THREE.Camera,
  R: typeof import('@dimforge/rapier3d-compat')
) {
  const { physics, maps } = w.ctx;

  const eid = addEntity(w);
  addComponent(w, Projectile,   eid);
  addComponent(w, Lifespan,     eid);
  addComponent(w, RigidBodyRef, eid);
  addComponent(w, MeshRef,      eid);
  addComponent(w, Transform,    eid);
  // Velocity component is for future client-side prediction
  addComponent(w, Velocity,     eid);

  Lifespan.ttl[eid]  = WeaponConfig.BULLET_TTL_MS;
  Lifespan.born[eid] = performance.now();

  /* mesh */
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(0.1, 8, 8),
    new THREE.MeshStandardMaterial({
      color: 0xff9900, roughness: 0.3, metalness: 0.7,
      emissive: 0xff9900, emissiveIntensity: 0.5
    })
  );
  mesh.castShadow = true;

  // Get direction from camera (reuse vectors)
  const dir = vec3Pool.get();
  camera.getWorldDirection(dir).normalize();
  
  // Get spawn position (reuse vectors)
  const spawn = vec3Pool.get();
  camera.getWorldPosition(spawn).addScaledVector(dir, WeaponConfig.BULLET_SPAWN_DISTANCE);
  
  // Apply to mesh
  mesh.position.copy(spawn);

  // Add to scene
  w.ctx.three.scene.add(mesh);
  maps.mesh.set(eid, mesh);

  /* rigid body */
  // Store velocity for client-side prediction
  Velocity.x[eid] = dir.x * WeaponConfig.BULLET_SPEED;
  Velocity.y[eid] = dir.y * WeaponConfig.BULLET_SPEED;
  Velocity.z[eid] = dir.z * WeaponConfig.BULLET_SPEED;

  // Create a rigid body with CCD enabled to prevent tunneling at high speeds
  const rb = physics.createRigidBody(
    R.RigidBodyDesc.dynamic()
      .setTranslation(spawn.x, spawn.y, spawn.z)
      .setCcdEnabled(true)
      .setLinvel(dir.x * WeaponConfig.BULLET_SPEED, 
                dir.y * WeaponConfig.BULLET_SPEED, 
                dir.z * WeaponConfig.BULLET_SPEED)
  );

  // Create a small spherical collider
  physics.createCollider(
    R.ColliderDesc.ball(0.1)
      .setDensity(2.0)
      .setFriction(0.0)
      .setRestitution(0.2),
    rb
  );

  maps.rb.set(eid, rb);
  RigidBodyRef.id[eid] = rb.handle;
  
  // Release pooled vectors
  vec3Pool.release(dir);
  vec3Pool.release(spawn);
} 

================================================
File: /src/ecs/systems/projectile.ts
================================================
import { defineQuery, removeEntity } from 'bitecs';
import { Lifespan, Projectile } from '../components';
import { ECS } from '../world';
import * as THREE from 'three';

export function initProjectileSystem(_world: ECS) {
  const projectileQuery = defineQuery([Projectile, Lifespan]);
  
  return (w: ECS) => {
    const now = performance.now();
    
    // Create a list of entities to remove to avoid modifying during iteration
    const entitiesToRemove: number[] = [];
    
    // Process bullet lifetimes and handle destruction
    for (const eid of projectileQuery(w)) {
      // Skip processing if already marked for removal
      if (entitiesToRemove.includes(eid)) continue;
      
      // Get rigid body reference
      const rb = w.ctx.maps.rb.get(eid);
      if (!rb) {
        // Body reference invalid, mark for removal
        entitiesToRemove.push(eid);
        continue;
      }
      
      // Skip if body is no longer valid (prevents "unreachable" errors)
      try {
        // Just check if we can access a property - will throw if body is invalid
        rb.handle;
      } catch (error) {
        // Something's wrong with this rigid body, mark for removal
        console.warn("Invalid rigid body detected, removing entity", eid);
        entitiesToRemove.push(eid);
        continue;
      }
      
      // Check if bullet should be removed due to lifetime
      const expired = now - Lifespan.born[eid] > Lifespan.ttl[eid];
      
      // Check if bullet was marked for deletion by collision system
      const mesh = w.ctx.maps.mesh.get(eid);
      const markedForDeletion = mesh?.userData?.markedForDeletion === true;
      
      // Mark for removal if expired or deletion requested
      if (expired || markedForDeletion) {
        entitiesToRemove.push(eid);
      }
    }
    
    // Remove all entities marked for deletion
    for (const eid of entitiesToRemove) {
      // Get and remove the mesh
      const mesh = w.ctx.maps.mesh.get(eid);
      if (mesh) {
        w.ctx.three.scene.remove(mesh);
        
        // Properly cast to THREE.Mesh to access geometry and material
        if (mesh instanceof THREE.Mesh) {
          if (mesh.geometry) {
            mesh.geometry.dispose();
          }
          
          if (mesh.material) {
            // Handle both single and array materials
            if (Array.isArray(mesh.material)) {
              mesh.material.forEach(material => {
                if (material) material.dispose();
              });
            } else {
              mesh.material.dispose();
            }
          }
        }
        
        w.ctx.maps.mesh.delete(eid);
      }
      
      // Get and remove the rigid body
      const rb = w.ctx.maps.rb.get(eid);
      if (rb) {
        w.ctx.physics.removeRigidBody(rb);
        w.ctx.maps.rb.delete(eid);
      }
      
      // Remove the entity
      removeEntity(w, eid);
    }
    
    return w;
  };
}


================================================
File: /src/ecs/systems/renderSync.ts
================================================
/**********************************************************************
 * renderSync.ts – sync Three meshes with Rapier bodies each frame
 *********************************************************************/
import { defineQuery, hasComponent, exitQuery } from 'bitecs';
import { ECS } from '../world';
import {
  MeshRef, RigidBodyRef, Transform, Player, Projectile
} from '../components';
import { vec3Pool, quatPool, interpolatePositions, interpolateRotations } from '../utils/mathUtils';

export function initRenderSyncSystem(_world: ECS) {
  const q = defineQuery([MeshRef]);
  const rbQuery = defineQuery([MeshRef, RigidBodyRef]);
  
  // Listen for entity deletions with MeshRef component
  const exitMeshQuery = exitQuery(q);
  
  // Storage for previous physics state for interpolation
  const prevPositions = new Map<number, THREE.Vector3>();
  const prevRotations = new Map<number, THREE.Quaternion>();

  return (w: ECS) => {
    // First, handle entity removal through bitECS exitQuery
    for (const eid of exitMeshQuery(w)) {
      // Clean up interpolation data for removed entities
      prevPositions.delete(eid);
      prevRotations.delete(eid);
      
      // Remove from entity handle map if present
      if (w.ctx.entityHandleMap) {
        // Find and remove any entry for this entity ID
        for (const [handle, entityId] of w.ctx.entityHandleMap.entries()) {
          if (entityId === eid) {
            w.ctx.entityHandleMap.delete(handle);
            break;
          }
        }
      }
    }
    
    // Then handle entities marked for deletion
    for (const eid of q(w)) {
      const mesh = w.ctx.maps.mesh.get(eid);
      if (mesh?.userData?.markedForDeletion) {
        // Clean up interpolation data only
        prevPositions.delete(eid);
        prevRotations.delete(eid);
      }
    }
    
    // Alpha for interpolation (0.0 to 1.0)
    const isHighRefreshRate = w.time.dt < 0.01; // Detecting high refresh (>100Hz)
    const alpha = isHighRefreshRate ? 
                  // Less interpolation on high refresh for sharper image
                  Math.min(0.5, w.time.alpha || 0) :
                  // Standard interpolation on normal refresh
                  (w.time.alpha !== undefined ? w.time.alpha : 0);
    
    // Get reusable vectors/quaternions
    const currentPos = vec3Pool.get();
    const currentRot = quatPool.get();
    
    for (const eid of rbQuery(w)) {
      const mesh = w.ctx.maps.mesh.get(eid)!;
      const rb   = w.ctx.maps.rb.get(eid); 
      
      if (!rb) continue;

      // Handle physics-driven objects that aren't the player
      if (!hasComponent(w, Player, eid)) {
        const p = rb.translation();
        const r = rb.rotation();
        
        // Set current position/rotation
        currentPos.set(p.x, p.y, p.z);
        currentRot.set(r.x, r.y, r.z, r.w);
        
        // Initialize previous state on first frame
        if (!prevPositions.has(eid)) {
          prevPositions.set(eid, currentPos.clone());
        }
        if (!prevRotations.has(eid)) {
          prevRotations.set(eid, currentRot.clone());
        }
        
        // Get previous state
        const prevPos = prevPositions.get(eid)!;
        const prevRot = prevRotations.get(eid)!;
        
        // Update previous state only when physics runs
        if (w.time.shouldRunPhysics) {
          prevPos.copy(currentPos);
          prevRot.copy(currentRot);
        }
        
        // On fast-moving objects, reduce interpolation to prevent blur
        const vel = rb.linvel ? rb.linvel() : null;
        const isMovingFast = vel && (vel.x*vel.x + vel.y*vel.y + vel.z*vel.z > 100);
        
        // Skip interpolation entirely for fast-moving objects (like bullets)
        // to avoid the quaternion slerp overhead - just use current position directly
        if (isMovingFast || hasComponent(w, Projectile, eid)) {
          mesh.position.set(currentPos.x, currentPos.y, currentPos.z);
          mesh.quaternion.set(currentRot.x, currentRot.y, currentRot.z, currentRot.w);
        } else {
          // Standard interpolation for normal objects
          const objectAlpha = isHighRefreshRate ? 0.3 : alpha;
          interpolatePositions(mesh.position, prevPos, currentPos, objectAlpha);
          interpolateRotations(mesh.quaternion, prevRot, currentRot, objectAlpha);
        }
        
        continue;
      }

      // Handle the player capsule (position only)
      if (hasComponent(w, Player, eid)) {
        const p = rb.translation();
        
        // Player movement uses same interpolation technique
        currentPos.set(p.x, p.y, p.z);
        
        // Initialize previous state on first frame
        if (!prevPositions.has(eid)) {
          prevPositions.set(eid, currentPos.clone());
        }
        
        // Get previous state
        const prevPos = prevPositions.get(eid)!;
        
        // Update previous state only when physics runs
        if (w.time.shouldRunPhysics) {
          prevPos.copy(currentPos);
        }
        
        // For player, use minimal interpolation on high refresh rate
        const playerAlpha = isHighRefreshRate ? Math.min(0.3, alpha) : alpha;
        
        // Interpolate player position
        interpolatePositions(mesh.position, prevPos, currentPos, playerAlpha);
        continue;
      }
    }

    // Handle remaining kinematic meshes - write transform back into ECS 
    for (const eid of q(w)) {
      // Skip if it has a rigid body (already processed above)
      if (hasComponent(w, RigidBodyRef, eid)) continue;
      
      const mesh = w.ctx.maps.mesh.get(eid)!;
      
      // Use pooled vectors
      const pos = vec3Pool.get();
      const quat = quatPool.get();
      
      mesh.getWorldPosition(pos);
      mesh.getWorldQuaternion(quat);

      Transform.x[eid]  = pos.x;
      Transform.y[eid]  = pos.y;
      Transform.z[eid]  = pos.z;
      Transform.qx[eid] = quat.x;
      Transform.qy[eid] = quat.y;
      Transform.qz[eid] = quat.z;
      Transform.qw[eid] = quat.w;
      
      // Release pooled vectors
      vec3Pool.release(pos);
      quatPool.release(quat);
    }
    
    // Release pooled vectors used for the loop
    vec3Pool.release(currentPos);
    quatPool.release(currentRot);
    
    return w;
  };
}


================================================
File: /src/ecs/systems/timeStep.ts
================================================
/**
 * Time step system that manages fixed time steps for physics
 */
import { ECS } from '../world';
import { updateFixedTimestep } from '../timeUtils';
import { TimeStepConfig } from '../config';

// Fixed timestep configuration constants are now directly imported from TimeStepConfig

export function initTimeStepSystem(_world: ECS) {
  return (w: ECS) => {
    // Calculate delta time in seconds
    const now = performance.now();
    // Use a minimum delta time to prevent tiny stutters during fast displays
    const dt = Math.max(TimeStepConfig.MIN_DT, (now - w.time.then) * 0.001); // Convert ms to seconds
    w.time.then = now;
    w.time.dt = dt;
    
    // Update fixed timestep values
    updateFixedTimestep(w, dt);
    
    return w;
  };
} 

================================================
File: /src/ecs/timeUtils.ts
================================================
/**
 * Time utilities for managing fixed timestep and frame timing
 */
import { ECS } from './world';
import { TimeStepConfig } from './config';

/**
 * Update time accumulator and calculate physics steps
 */
export function updateFixedTimestep(world: ECS, deltaTime: number): void {
  // Cap deltaTime to prevent jumps after pauses/tab switches
  const dt = Math.min(deltaTime, TimeStepConfig.MAX_FRAME_TIME);
  
  // Add to accumulator
  world.time.accumulator += dt;
  
  // Calculate how many physics steps to take
  const steps = Math.floor(world.time.accumulator / TimeStepConfig.FIXED_DT);
  const clampedSteps = Math.min(steps, TimeStepConfig.MAX_STEPS);
  
  // Store in world time
  world.time.shouldRunPhysics = clampedSteps > 0;
  world.time.physicsSteps = clampedSteps;
  world.time.fixedDt = TimeStepConfig.FIXED_DT;
  
  // Calculate interpolation alpha
  if (steps > 0) {
    world.time.accumulator -= clampedSteps * TimeStepConfig.FIXED_DT;
    world.time.alpha = world.time.accumulator / TimeStepConfig.FIXED_DT;
  } else {
    world.time.alpha = 0;
  }
} 

================================================
File: /src/ecs/utils/eventUtils.ts
================================================
/**
 * Event utility functions for proper listener management
 */

// Track attached listeners for cleanup
const attachedListeners: Array<{
  target: EventTarget;
  type: string;
  listener: EventListenerOrEventListenerObject;
  options?: boolean | AddEventListenerOptions;
}> = [];

/**
 * Safely attach an event listener with tracking for easy cleanup
 * @param target The EventTarget to attach to (window, document, etc.)
 * @param type Event type (click, keydown, etc.)
 * @param listener The event listener function
 * @param options Optional addEventListener options
 */
export function safeAddEventListener(
  target: EventTarget,
  type: string,
  listener: EventListenerOrEventListenerObject,
  options?: boolean | AddEventListenerOptions
): void {
  target.addEventListener(type, listener, options);
  attachedListeners.push({ target, type, listener, options });
}

/**
 * Remove all previously attached event listeners
 */
export function removeAllEventListeners(): void {
  for (const { target, type, listener, options } of attachedListeners) {
    target.removeEventListener(type, listener, options);
  }
  attachedListeners.length = 0;
}

/**
 * Setup handlers to clean up event listeners on page unload
 */
export function setupEventCleanup(): void {
  // Only set up once
  if ((window as any).__eventCleanupInitialized) return;
  
  window.addEventListener('beforeunload', removeAllEventListeners);
  (window as any).__eventCleanupInitialized = true;
} 

================================================
File: /src/ecs/utils/mathUtils.ts
================================================
/**
 * Math utilities including vector/quaternion pooling
 */
import * as THREE from 'three';

// Default pool size configuration
export const ObjectPoolConfig = {
  INITIAL_SIZE: 20  // Reduced from 50 to conserve memory
};

// A simple vector/quaternion pool to avoid allocations
class ObjectPool<T> {
  private pool: T[] = [];
  private createFn: () => T;
  private resetFn: (obj: T) => void;
  
  constructor(createFn: () => T, resetFn: (obj: T) => void, initialSize = ObjectPoolConfig.INITIAL_SIZE) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    
    // Pre-allocate initial pool
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn());
    }
  }
  
  get(): T {
    if (this.pool.length === 0) {
      return this.createFn();
    }
    return this.pool.pop()!;
  }
  
  release(obj: T): void {
    this.resetFn(obj);
    this.pool.push(obj);
  }
}

// Vector3 pool
export const vec3Pool = new ObjectPool<THREE.Vector3>(
  () => new THREE.Vector3(),
  (v) => v.set(0, 0, 0)
);

// Quaternion pool
export const quatPool = new ObjectPool<THREE.Quaternion>(
  () => new THREE.Quaternion(),
  (q) => q.set(0, 0, 0, 1)
);

// Euler pool
export const eulerPool = new ObjectPool<THREE.Euler>(
  () => new THREE.Euler(),
  (e) => e.set(0, 0, 0)
);

// Vector2 pool
export const vec2Pool = new ObjectPool<THREE.Vector2>(
  () => new THREE.Vector2(),
  (v) => v.set(0, 0)
);

// Interpolation helpers
export function interpolatePositions(
  dest: THREE.Vector3,
  prev: THREE.Vector3, 
  current: THREE.Vector3, 
  alpha: number
): THREE.Vector3 {
  return dest.lerpVectors(prev, current, alpha);
}

export function interpolateRotations(
  dest: THREE.Quaternion,
  prev: THREE.Quaternion, 
  current: THREE.Quaternion, 
  alpha: number
): THREE.Quaternion {
  return dest.slerpQuaternions(prev, current, alpha);
}

// Convert numeric tuple to BigInt64 for use as map key
export function createEntityPairKey(a: number, b: number): bigint {
  // Ensure a < b to make the key consistent regardless of order
  if (a > b) [a, b] = [b, a];
  
  // Convert to BigInt and combine into single 64-bit value
  // This allows for efficient storage without string conversions
  return (BigInt(a) << 32n) | BigInt(b & 0xFFFFFFFF);
}

/**
 * Get direction vector from one point to another
 * @param fromPos Starting position
 * @param toPos Target position
 * @param outVec Optional output vector (if not provided, one will be pooled)
 * @returns Normalized direction vector (caller must vec3Pool.release(outVec) when done)
 */
export function directionFromTo(
  fromPos: { x: number, y: number, z: number },
  toPos: { x: number, y: number, z: number },
  outVec = vec3Pool.get()
): THREE.Vector3 {
  return outVec.set(
    toPos.x - fromPos.x,
    toPos.y - fromPos.y,
    toPos.z - fromPos.z
  ).normalize();
} 

================================================
File: /src/ecs/world.ts
================================================
import { createWorld, pipe } from 'bitecs';
import { initInputSystem, InputState } from './systems/input.ts';
import { initPlayerSystem }    from './systems/player';
import { initProjectileSystem }from './systems/projectile.ts';
import { initPhysicsSystem }   from './systems/physics.ts';
import { initRenderSyncSystem }from './systems/renderSync.ts';
import { initDebugVisSystem }  from './systems/debugVis.ts';
import { initCollisionSystem } from './systems/collision.ts';
import { initTimeStepSystem }  from './systems/timeStep.ts';
import { initGrassSystem }     from './systems/grass.ts';
import * as THREE from 'three';

// Import Rapier types - use a type-only import to avoid runtime loading
import type * as RAPIER from '@dimforge/rapier3d-compat';

/** Create ECS world + pipeline */
export function createECS(ctx: ECSContext) {
  const world = createWorld() as ECS;
  world.ctx  = ctx;
  world.time = { 
    dt: 0, 
    then: performance.now(),
    accumulator: 0
  };
  
  // Create a collision event queue for Rapier
  const eventQueue = new ctx.rapier.EventQueue(true);
  world.ctx.eventQueue = eventQueue;

  const pipeline = pipe(
    initTimeStepSystem(world),  // Run first to manage fixed timestep
    initInputSystem(world),
    initPlayerSystem(world),
    initPhysicsSystem(world),   // Physics runs before collision system to process contacts
    initCollisionSystem(world), // Now handles Rapier collision events instead of raycasting
    initProjectileSystem(world),
    initGrassSystem(world),     // Add grass system
    initDebugVisSystem(world),
    initRenderSyncSystem(world)
  );

  return { world, pipeline };
}

/* -------------------------------------------------- */
/* Types shared with scene & systems                  */
export interface ECSContext {
  rapier: typeof RAPIER;
  physics: RAPIER.World;
  three: {
    scene: THREE.Scene;
    camera: THREE.Camera;
    renderer: THREE.WebGLRenderer;
  };
  maps: {
    rb: Map<number, RAPIER.RigidBody>;
    mesh: Map<number, THREE.Object3D>;
  };
  eventQueue?: RAPIER.EventQueue; 
  kcc?: RAPIER.KinematicCharacterController; 
  playerCollider?: RAPIER.Collider;
  entityHandleMap?: Map<number, number>; // Map from RB handle to entity ID
}

export interface ECS {
  ctx: ECSContext;
  time: {
    dt: number;
    then: number;
    accumulator: number;
    fixedDt?: number;
    alpha?: number;
    physicsSteps?: number;
    shouldRunPhysics?: boolean;
    prevPlayerPos?: THREE.Vector3; // Store previous player position for animation
  };
  input?: InputState;
}


================================================
File: /src/gameloop.ts
================================================
/**
 * Game loop module for managing main animation loop
 */
import Stats from 'three/examples/jsm/libs/stats.module.js';
import { ECS } from './ecs/world';

/**
 * Set up stats.js performance monitor
 */
export function setupStats(): Stats {
  const stats = new Stats();
  stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
  stats.dom.style.position = 'absolute';
  stats.dom.style.left = '0px';
  stats.dom.style.top = '0px';
  document.body.appendChild(stats.dom);
  return stats;
}

/**
 * Start the game loop
 */
export function startGameLoop(world: ECS, pipeline: (w: ECS) => ECS): void {
  const stats = setupStats();
  
  // Start animation loop
  const raf = (_t: number) => {
    // Begin stats measurement
    stats.begin();
    
    // Run all systems
    pipeline(world);
    
    // Render the scene
    world.ctx.three.renderer.render(world.ctx.three.scene, world.ctx.three.camera);
    
    // End stats measurement
    stats.end();
    
    // Request next frame
    requestAnimationFrame(raf);
  };
  
  // Start the loop
  requestAnimationFrame(raf);
} 

================================================
File: /src/main.ts
================================================
import * as RAPIER from '@dimforge/rapier3d-compat';
import { createContext, populateScene } from './ecs/scene';
import { createECS } from './ecs/world';
import { startGameLoop } from './gameloop';

/* canvas declared in /index.html */
const canvas = document.getElementById('c') as HTMLCanvasElement;

/**
 * Main application entry point
 */
async function main() {
  /* Initialize Rapier WASM module first */
  await RAPIER.init();
  
  /* bootstrap Three + Rapier context (physics world still empty) */
  const ctx = await createContext(canvas, RAPIER);

  /* create ECS world & system pipeline */
  const { world, pipeline } = createECS(ctx);

  /* now that ECS exists, spawn cubes & any other scene content */
  populateScene(world, ctx);
  
  /* Start the game loop */
  startGameLoop(world, pipeline);
}

// Initialize the application
main().catch(console.error);


================================================
File: /tsconfig.json
================================================
{
    "compilerOptions": {
      "target": "ES2020",
      "module": "ESNext",
      "lib": ["ES2020", "DOM"],
      "moduleResolution": "Bundler",
      "strict": true,
      "noImplicitReturns": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "skipLibCheck": true,
      "allowImportingTsExtensions": true,
      "noEmit": true,
      "types": ["vite/client"]
    },
    "include": ["src"]
  }
  

================================================
File: /vite.config.ts
================================================
import { defineConfig } from 'vite';
import wasm from 'vite-plugin-wasm';
import topLevelAwait from 'vite-plugin-top-level-await';

export default defineConfig({
  plugins: [wasm(), topLevelAwait()],
  build: { target: 'esnext' },
  server: { host: true }
});
    </codebase>
</context>


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


